"""
File: This module provides a decoder for the binary traces generated by the DynamoRIO backend

Copyright (C) Microsoft Corporation
SPDX-License-Identifier: MIT
"""

from enum import Enum
from typing import Any, Final, List, Literal
from io import BufferedReader
import sys
import os

from cffi import FFI
from typing_extensions import get_args, cast, assert_never

_MarkerType = Literal["T", "D"]

# ==================================================================================================
# Trace types
# ==================================================================================================
# TODO: autogenerate from trace.hpp
# NOTE: cffi cannot parse CPP constructs (e.g. enum classes, sdt::array) so we
#       need to manually adjust some of the fields.


class TraceEntryType(Enum):
    """
    Enum used for the trace entry type, copied from trace.hpp
    TODO: Cffi cannot parse enum classes, find a way to autogenerate from the header file
    """
    ENTRY_EOT = 0  # end of trace
    ENTRY_PC = 1
    ENTRY_READ = 2
    ENTRY_WRITE = 3
    ENTRY_EXCEPTION = 4
    ENTRY_IND = 5


_TRACE_ENTRY_T: Final[str] = "struct trace_entry_t"
_TRACE_ENTRY_DEF: Final[str] = """
struct trace_entry_t {
    // pc for instructions; address for memory accesses; target for indirect calls
    uint64_t addr;
    // instruction size for instructions; memory access size for memory accesses
    uint32_t size;
    // see trace_entry_type_t
    uint8_t type;
    // unused for now
    uint8_t padding[3]; // NOLINT
};
"""

# ==================================================================================================
# Debug Trace types
# ==================================================================================================
# TODO: autogenerate from debug_trace.hpp
# NOTE: cffi cannot parse CPP constructs (e.g. enum classes, sdt::array) so we
#       need to manually adjust some of the fields.


class DebugTraceEntryType(Enum):
    """
    Enum used for the debug trace entry type, copied from debug_trace.hpp
    TODO: Cffi cannot parse enum classes, find a way to autogenerate from the header file
    """
    ENTRY_EOT = 0  # end of trace
    ENTRY_REG_DUMP = 1
    ENTRY_READ = 2
    ENTRY_WRITE = 3
    ENTRY_LOC = 4
    ENTRY_EXCEPTION = 5
    ENTRY_CHECKPOINT = 6
    ENTRY_ROLLBACK = 7
    ENTRY_ROLLBACK_STORE = 8
    ENTRY_REG_DUMP_EXTENDED = 9


_DEBUG_TRACE_ENTRY_T: Final[str] = "struct debug_trace_entry_t"
_DEBUG_TRACE_ENTRY_DEF: Final[str] = """
struct debug_trace_entry_t {
    // What does this entry contain
    uint8_t type;
    // Nested speculation (0 is architectural)
    uint8_t nesting_level;
    // Unused for now
    uint8_t padding[6]; // NOLINT

    // Union of all possible entry types
    union {
        // ENTRY_REG_DUMP
        struct {
            uint64_t xax;
            uint64_t xbx;
            uint64_t xcx;
            uint64_t xdx;
            uint64_t xsi;
            uint64_t xdi;
            uint64_t pc;
        } regs;
        // ENTRY_REG_EXTENDED
        struct {
            uint64_t rsp;
            uint64_t rbp;
            uint64_t flags;
            uint64_t r8;
            uint64_t r9;
            uint64_t r10;
            uint64_t r11;
        } regs_2;
        // ENTRY_MEM (read or write)
        struct {
            uint64_t address;
            uint64_t value;
            uint64_t size;
        } mem;
        // ENTRY_LOC (module name and offset, for disassembly)
        struct {
            uint64_t offset;
            char module_name[48]; // NOLINT
        } loc;
        // ENTRY_EXCEPTION
        struct {
            int signal;
            uint64_t address;
        } xcpt;
        // ENTRY_CHECKPOINT
        struct {
            uint64_t rollback_pc;
            uint64_t cur_window_size;
            size_t cur_store_log_size;
        } checkpoint;
        // ENTRY_ROLLBACK
        struct {
            unsigned nesting;
            uint64_t rollback_pc;
        } rollback;
        // ENTRY_ROLLBACK_STORE
        struct {
            uint64_t addr;
            uint64_t val;
            size_t size;
            uint64_t nesting_level;
        } rollback_store;
    };
};
"""


# ==================================================================================================
# Decoder
# ==================================================================================================
class TraceDecoder:
    """
    This class provides a unified API for decoding trace entries
    """

    _ffi: FFI
    _trace_entry_size: int
    _debug_trace_entry_size: int

    def __init__(self) -> None:
        self._ffi = FFI()
        # Parse trace defs
        self._ffi.cdef(_TRACE_ENTRY_DEF)
        self._trace_entry_size = self._ffi.sizeof(_TRACE_ENTRY_T)
        # Parse debug trace defs
        self._ffi.cdef(_DEBUG_TRACE_ENTRY_DEF)
        self._debug_trace_entry_size = self._ffi.sizeof(_DEBUG_TRACE_ENTRY_T)

    # ----------------------------------------------------------------------------------------------
    # Public API
    # ----------------------------------------------------------------------------------------------
    def read_trace_marker(self, f: BufferedReader) -> _MarkerType | Literal[""]:
        """
        Get the type of the trace file.
        """
        marker = f.read(1).decode('utf-8')
        if len(marker) == 0:
            return ""
        assert marker in get_args(_MarkerType), f"Unknown trace type marker: {marker}"
        f.read(7)  # skip padding bytes
        return cast(_MarkerType, marker)

    def decode_trace_file(self, file: str) -> List[List[Any]]:
        """ Read a set of traces from a file. """
        with open(file, "rb") as f:
            marker = self.read_trace_marker(f)
            if marker == "":  # empty file
                return []
            assert marker == "T", f"Expected Normal trace (T), got {marker}"

            # Read the traces
            traces = []
            eof = False
            while not eof:

                entries = []
                while True:
                    # Read one entry
                    chunk = f.read(self._trace_entry_size)
                    if len(chunk) < self._trace_entry_size:
                        eof = True
                        break  # no more bytes to read: exit

                    # Decode it
                    entry = self._decode_trace_entry(chunk)
                    entries.append(entry)

                    # If we reached EOT, move on to the next trace
                    if TraceEntryType(entry.type) == TraceEntryType.ENTRY_EOT:
                        traces.append(entries)
                        break

                # Check that the last trace ended with an EOT entry or EXCEPTION
                if eof and len(entries) > 0:
                    last_entry = entries[-1]
                    if TraceEntryType(last_entry.type) != TraceEntryType.ENTRY_EOT:
                        raise ValueError("Trace file does not end with an EOT entry")

        return traces

    def decode_debug_trace_file(self, file: str) -> List[List[Any]]:
        """ Read a debug trace from a file. """
        with open(file, "rb") as f:
            marker = self.read_trace_marker(f)
            if marker == "":  # empty file
                return []
            assert marker == "D", f"Expected Debug trace (D), got {marker}"

            # Read the traces
            traces = []
            eof = False
            while not eof:

                entries = []
                while True:
                    # Read one entry
                    chunk = f.read(self._debug_trace_entry_size)
                    if len(chunk) < self._debug_trace_entry_size:
                        eof = True
                        break  # no more bytes to read: exit

                    # Decode it
                    entry = self._decode_debug_trace_entry(chunk)
                    entries.append(entry)

                    # If we reached EOT, move on to the next trace
                    if DebugTraceEntryType(entry.type) == DebugTraceEntryType.ENTRY_EOT:
                        traces.append(entries)
                        break

                # Check that the last trace ended with an EOT or EXCEPTION entry
                if eof and len(entries) > 0:
                    last_entry = entries[-1]
                    if DebugTraceEntryType(last_entry.type) != DebugTraceEntryType.ENTRY_EOT:
                        raise ValueError("Trace file does not end with an EOT entry")

        return traces

    def is_trace_corrupted(self, trace_path: str) -> bool:
        """
        Check if a trace ends with an EOT or EXCEPTION entry.
        """
        # Handle empty and non-existing traces as corrupted
        if not os.path.exists(trace_path) or os.stat(trace_path).st_size == 0:
            return True

        with open(trace_path, "rb") as f:
            trace_type = self.read_trace_marker(f)
            if trace_type == "":
                return True

            # Decode based on the type
            if trace_type == "T":
                entry_sz = self._ffi.sizeof(_TRACE_ENTRY_T)
                if os.stat(trace_path).st_size < entry_sz:
                    return True

                # Decode last entry
                f.seek(-entry_sz, os.SEEK_END)
                last_entry = self._decode_trace_entry(f.read(entry_sz))

                # Check its type
                last_entry_type = TraceEntryType(last_entry.type)
                return last_entry_type != TraceEntryType.ENTRY_EOT

            if trace_type == "D":
                entry_sz = self._ffi.sizeof(_DEBUG_TRACE_ENTRY_T)
                if os.stat(trace_path).st_size < entry_sz:
                    return True

                # Decode last entry
                f.seek(-entry_sz, os.SEEK_END)
                last_dbg_entry = self._decode_debug_trace_entry(f.read(entry_sz))

                # Check its type
                last_dbg_entry_type = DebugTraceEntryType(last_dbg_entry.type)
                return last_dbg_entry_type != DebugTraceEntryType.ENTRY_EOT

            assert_never(trace_type)

    # ----------------------------------------------------------------------------------------------
    # Private API
    # ----------------------------------------------------------------------------------------------
    def _decode_trace_entry(self, chunk: bytes) -> Any:
        """
        Decode a single entry from a chunk of bytes
        """
        # Decode it with ffi
        entry: Any = self._ffi.new(_TRACE_ENTRY_T + "*")
        self._ffi.memmove(entry, chunk, self._trace_entry_size)

        # Check that the entry type is valid
        try:
            TraceEntryType(entry.type)
        except Exception:
            raise ValueError(f"Error: Unknown trace entry type {str(entry.type)}")

        return entry

    def _decode_debug_trace_entry(self, chunk: bytes) -> Any:
        """
        Decode a single debug entry from a chunk of bytes
        """
        # Decode it with ffi
        entry: Any = self._ffi.new(_DEBUG_TRACE_ENTRY_T + "*")
        self._ffi.memmove(entry, chunk, self._debug_trace_entry_size)

        # Check that the entry type is valid
        try:
            DebugTraceEntryType(entry.type)
        except Exception:
            raise ValueError(f"Error: Unknown debug entry type {str(entry.type)}")

        return entry


def main() -> None:
    """ Standalone decoding interface: pretty-print trace entries from a file """
    if len(sys.argv) != 2:
        print(f"Usage {sys.argv[0]} <TRACE_PATH>")
        sys.exit(1)

    # 1. Create decoder
    decoder = TraceDecoder()

    # 2. Decode file
    with open(sys.argv[1], "rb") as f:
        trace_type = decoder.read_trace_marker(f)
    if trace_type == "":
        print(f"Empty trace file: {sys.argv[1]}")
        sys.exit(1)
    if trace_type == "T":
        parsed_traces = decoder.decode_trace_file(sys.argv[1])
    elif trace_type == "D":
        parsed_traces = decoder.decode_trace_file(sys.argv[1])
        print(f"Only leakage traces allowed: found {len(parsed_traces)} debug traces instead")
        sys.exit(1)
    else:
        assert_never(trace_type)

    # Check that the input contains leakage traces
    if len(parsed_traces) == 0:
        print(f"No traces found in {sys.argv[1]}")
        sys.exit(1)

    # 3. Print all entries
    for nt, trace_ in enumerate(parsed_traces):
        print("-------- TRACE --------")
        for ne, e in enumerate(trace_):
            try:
                # Parse the entry type
                type_ = TraceEntryType(e.type)
                print(f"[{type_.name}] {hex(e.addr)}")
            except Exception:
                raise ValueError(f"Failed to decode entry {ne} of trace {nt}")


if __name__ == '__main__':
    main()
