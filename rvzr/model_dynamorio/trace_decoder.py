"""
File: This module provides a decoder for the binary traces generated by the DynamoRIO backend

Copyright (C) Microsoft Corporation
SPDX-License-Identifier: MIT
"""

from enum import Enum
from typing import Any, Final
from io import BufferedReader
import sys
import os

from cffi import FFI


# -----------------------------------------------------------------------------
# Trace types
# TODO: autogenerate from trace.hpp
# NOTE: cffi cannot parse CPP constructs (e.g. enum classes, sdt::array) so we
#       need to manually adjust some of the fields.
# -----------------------------------------------------------------------------
class TraceEntryType (Enum):
    """
    Enum used for the trace entry type, copied from trace.hpp
    TODO: Cffi cannot parse enum classes, find a way to autogenerate from the header file
    """
    ENTRY_EOT = 0  # end of trace
    ENTRY_PC = 1
    ENTRY_READ = 2
    ENTRY_WRITE = 3
    ENTRY_EXCEPTION = 4


_TRACE_ENTRY_T: Final[str] = "struct trace_entry_t"
_TRACE_ENTRY_DEF: Final[str] = """
struct trace_entry_t {
    // pc for instructions; address for memory accesses
    uint64_t addr;
    // instruction size for instructions; memory access size for memory accesses
    uint32_t size;
    // see trace_entry_type_t
    uint8_t type;
    // unused for now
    uint8_t padding[3]; // NOLINT
};
"""

_TRACE_MARKER: Final[str] = "T"


# -----------------------------------------------------------------------------
# Debug Trace types
# TODO: autogenerate from debug_trace.hpp
# NOTE: cffi cannot parse CPP constructs (e.g. enum classes, sdt::array) so we
#       need to manually adjust some of the fields.
# -----------------------------------------------------------------------------
class DebugTraceEntryType (Enum):
    """
    Enum used for the debug trace entry type, copied from debug_trace.hpp
    TODO: Cffi cannot parse enum classes, find a way to autogenerate from the header file
    """
    ENTRY_EOT = 0  # end of trace
    ENTRY_REG_DUMP = 1
    ENTRY_READ = 2
    ENTRY_WRITE = 3
    ENTRY_LOC = 4
    ENTRY_EXCEPTION = 5
    ENTRY_CHECKPOINT = 6
    ENTRY_ROLLBACK = 7
    ENTRY_ROLLBACK_STORE = 8
    ENTRY_REG_DUMP_EXTENDED = 9


_DEBUG_TRACE_ENTRY_T: Final[str] = "struct debug_trace_entry_t"
_DEBUG_TRACE_ENTRY_DEF: Final[str] = """
struct debug_trace_entry_t {
    // What does this entry contain
    uint8_t type;
    // Nested speculation (0 is architectural)
    uint8_t nesting_level;
    // Unused for now
    uint8_t padding[6]; // NOLINT

    // Union of all possible entry types
    union {
        // ENTRY_REG_DUMP
        struct {
            uint64_t xax;
            uint64_t xbx;
            uint64_t xcx;
            uint64_t xdx;
            uint64_t xsi;
            uint64_t xdi;
            uint64_t pc;
        } regs;
        // ENTRY_REG_EXTENDED
        struct {
            uint64_t rsp;
            uint64_t rbp;
            uint64_t flags;
            uint64_t r8;
            uint64_t r9;
            uint64_t r10;
            uint64_t r11;
        } regs_2;
        // ENTRY_MEM (read or write)
        struct {
            uint64_t address;
            uint64_t value;
            uint64_t size;
        } mem;
        // ENTRY_LOC (module name and offset, for disassembly)
        struct {
            uint64_t offset;
            char module_name[48]; // NOLINT
        } loc;
        // ENTRY_EXCEPTION
        struct {
            int signal;
            uint64_t address;
        } xcpt;
        // ENTRY_CHECKPOINT
        struct {
            uint64_t rollback_pc;
            uint64_t cur_window_size;
            size_t cur_store_log_size;
        } checkpoint;
        // ENTRY_ROLLBACK
        struct {
            unsigned nesting;
            uint64_t rollback_pc;
        } rollback;
        // ENTRY_ROLLBACK_STORE
        struct {
            uint64_t addr;
            uint64_t val;
            size_t size;
            uint64_t nesting_level;
        } rollback_store;
    };
};
"""

_DEBUG_TRACE_MARKER: Final[str] = "D"


# -----------------------------------------------------------------------------
# Decoder
# -----------------------------------------------------------------------------
class TraceDecoder:
    """
    This clas provides a unified API for decoding trace entries
    """

    _ffi: FFI
    _trace_entry_size: int
    _debug_trace_entry_size: int

    def __init__(self) -> None:
        self._ffi = FFI()
        # Parse trace defs
        self._ffi.cdef(_TRACE_ENTRY_DEF)
        self._trace_entry_size = self._ffi.sizeof(_TRACE_ENTRY_T)
        # Parse debug trace defs
        self._ffi.cdef(_DEBUG_TRACE_ENTRY_DEF)
        self._debug_trace_entry_size = self._ffi.sizeof(_DEBUG_TRACE_ENTRY_T)

    def decode_trace_entry(self, chunk: bytes) -> Any:
        """
        Decode a single entry from a chunk of bytes
        """
        # Decode it with ffi
        entry: Any = self._ffi.new(_TRACE_ENTRY_T + "*")
        self._ffi.memmove(entry, chunk, self._trace_entry_size)
        # Check that the entry type is valid
        try:
            TraceEntryType(entry.type)
        except Exception:
            raise ValueError(f"Error: Unknown trace entry type {str(entry.type)}")

        return entry

    def decode_debug_trace_entry(self, chunk: bytes) -> Any:
        """
        Decode a single debug entry from a chunk of bytes
        """
        # Decode it with ffi
        entry: Any = self._ffi.new(_DEBUG_TRACE_ENTRY_T + "*")
        self._ffi.memmove(entry, chunk, self._debug_trace_entry_size)
        # Check that the entry type is valid
        try:
            DebugTraceEntryType(entry.type)
        except Exception:
            raise ValueError(f"Error: Unkown debug entry type {str(entry.type)}")

        return entry

    def decode_trace(self, f: BufferedReader) -> list[Any]:
        """
        Read a complete trace from a file, until an EOT entry is found.
        """
        entries = []
        while True:
            # Read one entry
            chunk = f.read(self._trace_entry_size)
            if len(chunk) < self._trace_entry_size:
                break  # no more bytes to read: exit
            # Decode it
            entry = self.decode_trace_entry(chunk)
            # Append to trace
            entries.append(entry)
            # If we reached EOT we're done
            if TraceEntryType(entry.type) == TraceEntryType.ENTRY_EOT:
                break

        return entries

    def decode_debug_trace(self, f: BufferedReader) -> list[Any]:
        """
        Read a complete debug trace from a file, until an EOT entry is found.
        """
        entries = []
        while True:
            # Read one entry
            chunk = f.read(self._debug_trace_entry_size)
            if len(chunk) < self._debug_trace_entry_size:
                break  # no more bytes to read: exit
            # Decode it
            entry = self.decode_debug_trace_entry(chunk)
            # Append to trace
            entries.append(entry)
            # If we reached EOT we're done
            if DebugTraceEntryType(entry.type) == DebugTraceEntryType.ENTRY_EOT:
                break

        return entries

    def decode_trace_file(self, file: str) -> tuple[list[Any], list[Any]]:
        """
        Decode an entire trace file, which might contain multiple traces.
        """
        traces = []
        debug_traces = []

        with open(file, 'rb') as f:
            while True:
                # Read marker
                marker = f.read(1).decode('utf-8')
                if len(marker) == 0:
                    break  # file has ended

                # Decode based on the marker
                if marker == _TRACE_MARKER:
                    traces.append(self.decode_trace(f))
                elif marker == _DEBUG_TRACE_MARKER:
                    debug_traces.append(self.decode_debug_trace(f))
                else:
                    raise ValueError(f"Error: Unknown trace type marker! Found {marker}")

        return traces, debug_traces

    def is_trace_corrupted(self, trace_path: str) -> bool:
        """
        Check if a trace ends with an EOT or EXCEPTION entry.
        """
        # Handle empty and non-existing traces as corrupted
        if not os.path.exists(trace_path) or os.stat(trace_path).st_size == 0:
            return True

        with open(trace_path, "rb") as f:
            # Read marker
            marker = f.read(1).decode('utf-8')
            # Decode based on the marker
            if marker == _TRACE_MARKER:
                entry_sz = self._ffi.sizeof(_TRACE_ENTRY_T)
                if (os.stat(trace_path).st_size < entry_sz):
                    return True
                # Decode last entry
                f.seek(-entry_sz, os.SEEK_END)
                last_entry = self.decode_trace_entry(f.read(entry_sz))
                # Check its type
                last_entry_type = TraceEntryType(last_entry.type)
                expected = (TraceEntryType.ENTRY_EOT, TraceEntryType.ENTRY_EXCEPTION)
                return last_entry_type not in expected

            if marker == _DEBUG_TRACE_MARKER:
                entry_sz = self._ffi.sizeof(_DEBUG_TRACE_ENTRY_T)
                if (os.stat(trace_path).st_size < entry_sz):
                    return True
                # Decode last entry
                f.seek(-entry_sz, os.SEEK_END)
                last_dbg_entry = self.decode_debug_trace_entry(f.read(entry_sz))
                # Check its type
                last_dbg_entry_type = DebugTraceEntryType(last_dbg_entry.type)
                expected_dbg = (DebugTraceEntryType.ENTRY_EOT, DebugTraceEntryType.ENTRY_EXCEPTION)
                return last_dbg_entry_type not in expected_dbg

            raise ValueError(f"Error: Unknown trace type marker! Found {marker}")


# Sample usage: pretty-print trace entries from a file
if __name__ == '__main__':
    if len(sys.argv) != 2:
        print(f"Usage {sys.argv[0]} <TRACE_PATH>")
        sys.exit(1)

    # 1. Create decoder
    decoder = TraceDecoder()
    # 2. Decode file
    parsed_traces, parsed_gdb_traces = decoder.decode_trace_file(sys.argv[1])

    # Check that the input contains leakage traces
    if len(parsed_traces) == 0:
        print(f"No traces found in {sys.argv[1]}")
        sys.exit(1)
    if len(parsed_gdb_traces) > 0:
        print(f"Only leakage traces allowed: found {len(parsed_gdb_traces)} debug traces instead")
        sys.exit(1)

    # 3. Print all entries
    for nt, trace in enumerate(parsed_traces):
        print("-------- TRACE --------")
        for ne, e in enumerate(trace):
            try:
                # Parse the entry type
                type_ = TraceEntryType(e.type)
                print(f"[{type_.name}] {hex(e.addr)}")
            except Exception:
                raise ValueError(f"Failed to decode entry {ne} of trace {nt}")
