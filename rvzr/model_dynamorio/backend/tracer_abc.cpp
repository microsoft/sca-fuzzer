///
/// File: Abstract Model TracerABC
///
// Copyright (C) Microsoft Corporation
// SPDX-License-Identifier: MIT

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>

#include <dr_api.h> // NOLINT
#include <dr_defines.h>
#include <dr_events.h>
#include <dr_ir_instr.h>
#include <dr_ir_opnd.h>
#include <dr_ir_utils.h>
#include <dr_tools.h>

#include <drmgr.h>
#include <drreg.h>
#include <drvector.h>

#include "observables.hpp"
#include "tracer_abc.hpp"
#include "types/debug_trace.hpp"
#include "types/trace.hpp"

using std::string;
using std::vector;

// =================================================================================================
// Local helper functions for allocating and freeing memory
// =================================================================================================
namespace
{

// We allow these specific registers because they are not used
// in the test cases generated by Revizor (see rvzr/arch/x86/x86_config.py:register_blocklist)
constexpr int REG_IDS[] = {DR_REG_R8, DR_REG_R9, DR_REG_R10, DR_REG_R11, DR_REG_R12}; // NOLINT
constexpr int N_RESERVED_REGS = 5;

/// @brief Flush all traces in binary format
/// @param trace The trace buffer
/// @param enable_bin_output If true, the debug trace will be printed in binary format
///                          Otherwise, it will be printed in human-readable format
/// @return void
void print_traces(vector<trace_entry_t> *trace, bool enable_bin_output = false)
{
    // Print trace marker
    const char marker = trace_entry_t::marker;
    if (enable_bin_output) {
        fwrite(&marker, sizeof(trace_entry_t::marker), 1, stdout);
    } else {
        fprintf(stdout, "%c\n", marker);
    }

    // Print all trace entries
    for (const auto &entry : *trace) {
        if (enable_bin_output) {
            fwrite(&entry, sizeof(trace_entry_t), 1, stdout);
        } else {
            entry.dump(std::cout);
        }
    }

    // Print a marker to indicate the end of the trace (EOT)
    trace_entry_t eot = {0, 0, trace_entry_type_t::ENTRY_EOT};
    if (enable_bin_output) {
        fwrite(&eot, sizeof(trace_entry_t), 1, stdout);
    } else {
        eot.dump(std::cout);
    }
}

/// @brief Flush all debug traces entries into the standard output
/// @param dbg_trace The debug trace buffer
/// @param enable_bin_output If true, the debug trace will be printed in binary format
///                          Otherwise, it will be printed in human-readable format
/// @return void
void print_dbg_traces(vector<debug_trace_entry_t> *dbg_trace, bool enable_bin_output = false)
{
    // Print trace marker
    const char marker = debug_trace_entry_t::marker;
    if (enable_bin_output) {
        fwrite(&marker, sizeof(debug_trace_entry_t::marker), 1, stdout);
    } else {
        fprintf(stdout, "%c\n", marker);
    }

    // Print the debug trace buffer
    for (const auto &entry : *dbg_trace) {
        if (enable_bin_output) {
            fwrite(&entry, sizeof(debug_trace_entry_t), 1, stdout);
        } else {
            entry.dump(std::cout);
        }
    }

    // Print the end of trace marker
    debug_trace_entry_t eot{.type = debug_trace_entry_type_t::ENTRY_EOT};
    if (enable_bin_output) {
        fwrite(&eot, sizeof(trace_entry_t), 1, stdout);
    } else {
        eot.dump(std::cout);
    }
}

} // namespace

// =================================================================================================
// Constructors and Destructors
// =================================================================================================
TracerABC::TracerABC(bool enable_dbg_trace_, bool enable_bin_output_)
    : enable_dbg_trace(enable_dbg_trace_), enable_bin_output(enable_bin_output_)
{
    // Initialize trace buffers
    trace = std::vector<trace_entry_t>();
    dbg_trace = std::vector<debug_trace_entry_t>();
}

// =================================================================================================
// Public Methods
// =================================================================================================
void TracerABC::tracing_start(void * /*wrapctx*/, DR_PARAM_OUT void ** /*user_data*/)
{
    tracing_on = true;
    tracing_finalized = false;
}

void TracerABC::tracing_finalize(void * /*wrapctx*/, DR_PARAM_OUT void * /*user_data*/)
{
    if (tracing_finalized) {
        return;
    }

    // Print the trace buffers
    print_traces(&trace, enable_bin_output);
    if (enable_dbg_trace) {
        print_dbg_traces(&dbg_trace, enable_bin_output);
    }

    // Reset the trace buffers
    trace.clear();
    dbg_trace.clear();

    // Reset the tracing flag
    tracing_on = false;
    tracing_finalized = true;
}

void TracerABC::observe_instruction(instr_obs_t instr, dr_mcontext_t *mc)
{
    // Nothing to do if tracing is off
    if (not tracing_on) {
        return;
    }

    // In debug mode, print all registers at every instruction
    if (enable_dbg_trace) {
        dbg_trace.push_back({.type = debug_trace_entry_type_t::ENTRY_REG_DUMP,
                             .regs{
                                 .xax = mc->xax,
                                 .xbx = mc->xbx,
                                 .xcx = mc->xcx,
                                 .xdx = mc->xdx,
                                 .xsi = mc->xsi,
                                 .xdi = mc->xdi,
                                 .pc = instr.pc,
                             }});
    }

    // The rest of the functionality - if any - is implemented by subclasses
}

void TracerABC::observe_mem_access(bool is_write, void *address, uint64_t size)
{
    // Nothing to do if tracing is off
    if (not tracing_on) {
        return;
    }

    // In debug mode, record all stores and loads (and the corresponding value as well)
    if (enable_dbg_trace) {
        size_t r_size = 0;
        uint64_t val = 0;
        dr_safe_read(address, size, &val, &r_size);

        dbg_trace.push_back({.type = is_write ? debug_trace_entry_type_t::ENTRY_WRITE
                                              : debug_trace_entry_type_t::ENTRY_READ,
                             .mem{
                                 .address = (uint64_t)address,
                                 .value = val,
                                 .size = r_size,
                             }});
    }
    // The rest of the functionality - if any - is implemented by subclasses
}
