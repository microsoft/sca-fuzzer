"""
File: Parsing of assembly files into our internal representation (TestCaseCode).
      This file contains ISA-independent code; see <isa>/<isa>_asm_parser.py for ISA-specific code.

Copyright (C) Microsoft Corporation
SPDX-License-Identifier: MIT
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Dict, List, Final, Optional
from abc import ABC, abstractmethod
from collections import OrderedDict
import re
import os

from .tc_components.test_case_code import TestCaseProgram, Function, BasicBlock, TC_EXIT_LABEL
from .tc_components.instruction import Instruction, LabelOp, Operand, RegisterOp, MemoryOp, \
    ImmediateOp, AgenOp, CondOp, AnyOperand
from .instruction_spec import OT, InstructionSpec, OperandSpec
from .tc_components.actor import ActorPL, ActorMode
from .code_generator import assemble
from .config import CONF

if TYPE_CHECKING:
    from .target_desc import TargetDesc
    from .isa_spec import InstructionSet
    from .elf_parser import ELFParser
    from .code_generator import CodeGenerator

RE_REDUNDANT_SPACES = re.compile(r"(?<![a-zA-Z0-9]) +")
TC_EXIT_LINE = TC_EXIT_LABEL + ":"


class AsmParserError(Exception):
    """ Base exception class for AsmParser module """

    def __init__(self, line_num: int, message: str) -> None:
        full_msg = f"[AsmParser] Error parsing assembly (line {line_num + 1}):\n{message}"
        super().__init__(full_msg)


def asm_parser_assert(condition: bool, line_number: int, explanation: str) -> None:
    """ Raise an AsmParserError if the condition is not met """

    if not condition:
        raise AsmParserError(line_number, explanation)


@dataclass
class _ASMLine:
    """ Metadata for a single line of assembly code """

    def __init__(self, str_: str, line_num: int) -> None:
        self.str = str_
        self.clean_str = str_.strip().lower()
        self.clean_str = RE_REDUNDANT_SPACES.sub("", self.clean_str)
        self.line_num = line_num
        self.patched_line_num = 0
        self.clean_line_num = 0


# ==================================================================================================
# Private: Code Map Builder
# ==================================================================================================
_BBLabel = str
_BasicBlockMap = OrderedDict[_BBLabel, List[_ASMLine]]
_FunctionName = str
_FunctionMap = OrderedDict[_FunctionName, _BasicBlockMap]
_SectionLabel = str
_CodeMap = OrderedDict[_SectionLabel, _FunctionMap]


class _CodeMapBuilder:
    """
    Class responsible for building a dictionary of sections, functions, basic blocks,
    and relationships between them in an assembly file
    """

    section_label: Optional[str] = None
    function_label: Optional[str] = None
    bb_label: Optional[str] = None
    bb_is_autogenerated: bool = False
    code_map: _CodeMap

    def create_code_map(self, lines: List[_ASMLine]) -> _CodeMap:
        """
        Parse lines and build a map of sections, functions, and basic blocks
        in the test case
        :param lines: representation of the assembly file as a list of ASMLine objects
        :return: a dictionary representing the code structure of the test case (_CodeMap)
        """
        self.code_map: _CodeMap = OrderedDict()

        # Parse each line according to its type and accumulate the code structure as we go
        for line_obj in lines:
            line_num = line_obj.line_num
            line = line_obj.clean_str
            type_ = self._get_line_type(line_obj)

            if type_ == "ignore":
                continue

            if type_ == "section":
                self._start_section(line_obj)
                continue

            if type_ == "function":
                self._start_function(line_obj)
                continue
            if self.function_label is None and self.section_label is not None:
                self._create_default_main_function()  # allow for implicit functions

            if type_ == "basic_block":
                self._start_basic_block(line_obj)
                continue

            if type_ == "instruction":
                self._add_instruction(line_obj)
                continue

            if type_ == "opcode":
                self._add_instruction(_ASMLine("opcode", line_num))
                continue

            if type_ == "macro":
                str_ = self._macro_label_to_instr(line, line_num)
                self._add_instruction(_ASMLine(str_, line_num))

        return self.code_map

    def _get_line_type(self, line: _ASMLine) -> str:
        # pylint: disable=too-many-return-statements
        # NOTE: This is a selector, so it is expected to have many returns

        line_str = line.clean_str
        if line_str[0] != ".":
            return "instruction"
        if line_str.startswith(".global") or line_str.startswith(".intel_syntax"):
            return "ignore"
        if line_str.startswith(".section"):
            return "section"
        if line_str.startswith(".function_"):
            return "function"
        if line_str.startswith(".macro"):
            return "macro"
        if line_str[:4] == ".bcd " or line_str[:5] in [".byte", ".long", ".quad"] \
           or line_str[6:] in [".value", ".2byte", ".4byte", ".8byte"]:
            return "opcode"
        if line_str[-1] == ":":
            return "basic_block"
        raise NotImplementedError(f"Line {line.line_num}: Unknown line type: {line_str}")

    def _start_section(self, line: _ASMLine) -> None:
        line_str = line.clean_str
        words = line.clean_str.split()
        assert len(words) == 2, \
            f"Line {line.line_num}: Invalid section label {line_str}; expected .section <label>"

        # exit section does not represent any actor; ignore it
        if words[1] == "exit":
            return

        # parse the section label
        sub_words = words[1].split(".")
        assert len(sub_words) == 3, \
            f"Line {line.line_num}: Invalid section label: {line_str}"

        label = sub_words[2]
        assert label in CONF.get_actors_conf(), \
            f"Line {line.line_num}: Actor {label} was not defined in the config file"

        # update the parser state to reflect that a new section has started
        if label not in self.code_map:
            self.code_map[label] = OrderedDict()
        self.section_label = label
        self.function_label = None
        self.bb_label = None

    def _start_function(self, line: _ASMLine) -> None:
        assert self.section_label is not None, \
            f"Line {line.line_num}: Function started before a .section was declared"

        # get label
        line_str = line.clean_str
        assert line_str[-1] == ":", f"Invalid function header: {line_str}"
        label = line_str[:-1]

        # update the parser state to reflect that a new function has started
        self.function_label = label
        self.code_map[self.section_label][label] = OrderedDict()

        default_start_bb = ".bb_" + label.removeprefix(".function_") + ".entry"
        self.bb_label = default_start_bb
        self.bb_is_autogenerated = True
        self.code_map[self.section_label][label][default_start_bb] = []

    def _create_default_main_function(self) -> None:
        assert self.section_label is not None, \
            "Function started before a .section was declared"

        default_label = f".function_{self.section_label}_0"
        self.function_label = default_label
        self.code_map[self.section_label][default_label] = OrderedDict()

        default_start_bb = f".bb_{self.section_label}_0.entry"
        self.bb_label = default_start_bb
        self.bb_is_autogenerated = True
        self.code_map[self.section_label][default_label][default_start_bb] = []

    def _start_basic_block(self, line: _ASMLine) -> None:
        assert self.section_label is not None, \
            f"Line {line.line_num}: Basic block started before a .section was declared"
        assert self.function_label is not None, \
            f"Line {line.line_num}: Basic block started before a .function was declared"
        assert self.bb_label is not None, \
            f"Line {line.line_num}: Default basic block was not created"

        # get label
        line_str = line.clean_str
        assert line_str[-1] == ":", f"Invalid basic block header: {line_str}"
        label = line_str[:-1]

        # overwrite default BB added to every function, if it is still empty
        bb_map = self.code_map[self.section_label][self.function_label]
        if len(bb_map) == 1 and len(bb_map[self.bb_label]) == 0 \
           and self.bb_is_autogenerated:
            del self.code_map[self.section_label][self.function_label][self.bb_label]

        # update the parser state to reflect that a new basic block has started
        self.bb_label = label
        self.bb_is_autogenerated = False
        assert label not in self.code_map[self.section_label][self.function_label], \
            f"Line {line.line_num}: Duplicate basic block label: {label}"
        self.code_map[self.section_label][self.function_label][label] = []

    def _add_instruction(self, line: _ASMLine) -> None:
        assert self.section_label is not None, \
            f"Line {line.line_num}: Instruction found before a .section was declared"
        assert self.function_label is not None, \
            f"Line {line.line_num}: Instruction found before a .function was declared"
        assert self.bb_label is not None, \
            f"Line {line.line_num}: Instruction found before a basic block was declared"

        self.code_map[self.section_label][self.function_label][self.bb_label].append(line)

    def _macro_label_to_instr(self, line: str, line_num: int) -> str:
        """
        This function replaces label-like macros with a pseudo-instruction MACRO
        As such, we simplify further parsing of the test case
        """
        # get rid of the NOP placeholder
        words = line.split(":")
        asm_parser_assert(len(words) == 2, line_num, "Invalid macro declaration")
        asm_parser_assert(words[1][:3] == "nop", line_num, "Patching error")

        # get the macro name and its arguments
        subwords = words[0].split(".")
        asm_parser_assert(len(subwords) >= 3, line_num, f"Invalid macro: {line}")
        asm_parser_assert(len(subwords) <= 7, line_num, f"Invalid macro: {line}")
        macro_id = subwords[2]
        args = '.'.join(subwords[3:])
        if args:
            instr = f"macro .{macro_id}, .{args}"
        else:
            instr = f"macro .{macro_id}, .noarg"

        return instr


# ==================================================================================================
# Private: Patching of assembly files
# ==================================================================================================
class _AsmPatcher:
    _main_function_label: str = ""
    _macro_placeholder_str: Optional[str] = None

    def set_macro_placeholder(self, macro_placeholder_str: str) -> None:
        """
        Assign a string to be used as a placeholder for macro instructions.

        This method exist to allow re-use of the _AsmPatcher class between different ISAs.
        """
        assert self._macro_placeholder_str is None, \
            "Macro placeholder string was already set"
        self._macro_placeholder_str = macro_placeholder_str

    def patch_asm(self, asm_file: str, patched_asm_file: str) -> None:
        """
        Ensure that the assembly file is in the correct format for parsing:
        - all function labels are exposed by adding a global label
        - NOP is added at the end of each function to make size calculations easier
        - .function_0 is inserted at the beginning of the file if it is missing
        - .test_case_exit is within the .data.main section and contains a single NOP
        """
        self._main_function_label = ""
        self._pre_clean(asm_file, patched_asm_file)

        # apply the patches
        self._add_exit_section(patched_asm_file)
        self._add_default_main(patched_asm_file)
        self._add_macro_placeholders(patched_asm_file)
        self._add_default_measurements(patched_asm_file)

    def _is_instruction(self, line: str) -> bool:
        return line != '' and line[0] != '#' \
            and (line[0] != '.' or line[:4] == ".bcd"
                 or line[:5] in [".byte", ".long", ".quad"] or line[:6] == '.macro'
                 or line[6:] in [".value", ".2byte", ".4byte", ".8byte"])

    def _pre_clean(self, asm_file: str, patched_asm_file: str) -> None:
        with open(asm_file, "r") as f:
            with open(patched_asm_file, "w") as patched:
                for line in f:
                    line = line.strip().lower()
                    patched.write(line + "\n")

    def _add_exit_section(self, patched_asm_file: str) -> None:
        prev_line = ""
        with open(patched_asm_file, "r") as f:
            with open(patched_asm_file + ".tmp", "w") as patched:
                for line in f:
                    line = line[:-1]
                    if ".test_case_exit:" in line:
                        if ".data.main" not in prev_line or "measurement_end" in prev_line:
                            patched.write(".section .data.main\n")
                        patched.write(".test_case_exit:" + "nop" + "\n")
                        continue
                    patched.write(line + "\n")
                    prev_line = line
        os.rename(patched_asm_file + ".tmp", patched_asm_file)

    def _add_default_main(self, patched_asm_file: str) -> None:
        main_function_label = ""
        with open(patched_asm_file, "r") as f:
            with open(patched_asm_file + ".tmp", "w") as patched:
                for line in f:
                    line = line[:-1]

                    # if we already have a main function, just copy the rest of the file
                    if main_function_label:
                        patched.write(line + "\n")
                        continue

                    # reached the end of the file
                    if ".test_case_exit:" in line:
                        main_function_label = ".function_0"
                        patched.write(".function_0:\n")
                        patched.write(line + "\n")
                        continue

                    # found the main function
                    if line.startswith(".function_"):
                        main_function_label = line[:-1]
                        patched.write(line + "\n")
                        continue

                    # found an instruction before the main function
                    if self._is_instruction(line):
                        patched.write(".function_0:\n")
                        main_function_label = ".function_0"
                        patched.write(line + "\n")
                        continue

                    # copy non-instruction lines
                    patched.write(line + "\n")

        self._main_function_label = main_function_label
        os.rename(patched_asm_file + ".tmp", patched_asm_file)

    def _add_macro_placeholders(self, patched_asm_file: str) -> None:
        """ add NOP placeholders after macros """
        assert self._macro_placeholder_str is not None, \
            "set_macro_placeholder() was not called before patching"

        with open(patched_asm_file, "r") as f:
            with open(patched_asm_file + ".tmp", "w") as patched:
                for line in f:
                    line = line.lower()
                    if line.startswith(".macro"):
                        if "nop" not in line:
                            patched.write(line[:-1] + self._macro_placeholder_str + "\n")
                        else:
                            assert self._macro_placeholder_str in line, \
                                "Unexpected NOP placeholder: " + line
                            patched.write(line)
                    else:
                        patched.write(line)
        os.rename(patched_asm_file + ".tmp", patched_asm_file)

    def _add_default_measurements(self, patched_asm_file: str) -> None:
        assert self._macro_placeholder_str is not None, \
            "set_macro_placeholder() was not called before patching"

        # identify if the file already has the measurement macros;
        # this information is used by multiple patching steps
        has_measurement_start = False
        has_measurement_end = False
        with open(patched_asm_file, "r") as f:
            for line in f:
                line = line.lower()
                if line.startswith(".macro.measurement_start"):
                    has_measurement_start = True
                elif line.startswith(".macro.measurement_end"):
                    has_measurement_end = True

        # add .macro.measurement_start after .function_0
        if not has_measurement_start:
            with open(patched_asm_file, "r") as f:
                with open(patched_asm_file + ".tmp", "w") as patched:
                    for line in f:
                        line = line.lower()
                        patched.write(line)
                        if line.startswith(self._main_function_label):
                            patched.write(".macro.measurement_start:" + self._macro_placeholder_str
                                          + "\n")
            os.rename(patched_asm_file + ".tmp", patched_asm_file)

        # add .macro.measurement_end before .test_case_exit
        if not has_measurement_end:
            with open(patched_asm_file, "r") as f:
                with open(patched_asm_file + ".tmp", "w") as patched:
                    prev_line = ""
                    for line in f:
                        line = line.lower()
                        if line.startswith(".test_case_exit:"):
                            if prev_line.startswith(".section"):
                                patched.write(".function_end:\n")
                            patched.write(".macro.measurement_end:" + self._macro_placeholder_str
                                          + "\n")
                        patched.write(line)
                        prev_line = line
            os.rename(patched_asm_file + ".tmp", patched_asm_file)


# ==================================================================================================
# Public (intended for <isa>/asm_parser.py): Line parsing
# ==================================================================================================
class AsmLineParser(ABC):
    """
    Class responsible for parsing an assembly line into an Instruction object.

    This class is a common ISA-independent functionality with hooks to be implemented by
    ISA-specific subclasses.
    """
    _instruction_map: Final[Dict[str, List[InstructionSpec]]]
    _curr_ln: int
    _comment_char: str  # set by subclasses

    def __init__(self, isa_spec: InstructionSet, target_desc: TargetDesc) -> None:
        self._instruction_map = self._build_instruction_map(isa_spec)
        self._target_desc = target_desc
        self._curr_ln = -1

    # ----------------------------------------------------------------------------------------------
    # Hooks for ISA-specific subclasses
    @abstractmethod
    def _tokenize(self, line: str) -> List[str]:
        """ Tokenize the line and store the results internally """

    @abstractmethod
    def _get_instruction_name(self, line: str, tokens: List[str]) -> str:
        """ Get the instruction name from the line, based on the tokenized data """

    @abstractmethod
    def _get_instruction_operands(self, line: str, name: str, tokens: List[str]) -> List[str]:
        """ Get the instruction operands from the line, based on the tokenized data """

    @abstractmethod
    def _get_initial_candidate_specs(self, line: str, name: str) -> List[InstructionSpec]:
        """ Get a list of candidate specs for the given assembly line """

    @abstractmethod
    def _check_if_spec_matches(self, spec: InstructionSpec, operands_raw: List[str]) -> bool:
        """ Check if the given spec matches the given list of operand strings """

    # ----------------------------------------------------------------------------------------------
    # Common ISA-independent Functionality
    @staticmethod
    def _build_instruction_map(isa_spec: InstructionSet) -> Dict[str, List[InstructionSpec]]:
        instruction_map: Dict[str, List[InstructionSpec]] = {}
        for spec in isa_spec.instructions_unfiltered:
            if spec.name in instruction_map:
                instruction_map[spec.name].append(spec)
            else:
                instruction_map[spec.name] = [spec]

            # add an entry for direct opcodes
            opcode_spec = InstructionSpec("opcode", "opcode")
            instruction_map["opcode"] = [opcode_spec]

            # entry for macros
            macro_spec = InstructionSpec("macro", "macro")
            macro_spec.operands = [
                OperandSpec([], OT.LABEL, False, False),
                OperandSpec([], OT.LABEL, False, False)
            ]
            instruction_map["macro"] = [macro_spec]
        return instruction_map

    def parse_line(self, line: str, line_num: int) -> Instruction:
        """ Implementation of the AsmLineParser interface for x86 assembly lines (Intel syntax) """
        self._curr_ln = line_num

        # Identify the line type
        line = line.lower()
        is_instrumentation = "instrumentation" in line
        is_noremove = "noremove" in line

        # Remove comments
        if self._comment_char in line:
            line = line.split(self._comment_char)[0].strip()

        # Get instruction name and operands
        tokens = self._tokenize(line)
        name = self._get_instruction_name(line, tokens)
        operands_raw = self._get_instruction_operands(line, name, tokens)

        # Find a matching spec
        spec = self._find_matching_spec(line, name, operands_raw)

        # generate a corresponding Instruction
        inst = self._create_instruction(spec, operands_raw, is_instrumentation, is_noremove)
        inst.assign_line_num(line_num)

        return inst

    def _find_matching_spec(self, line: str, name: str, operands_raw: List[str]) -> InstructionSpec:
        """ Find the InstructionSpec that matches the given assembly line """

        # Get candidate specs
        specs = self._get_initial_candidate_specs(line, name)
        if len(specs) == 0:
            raise AsmParserError(self._curr_ln, f"Unknown instruction {line}")

        # find a matching spec
        matching_specs: List[InstructionSpec] = []
        for spec_candidate in specs:
            if self._check_if_spec_matches(spec_candidate, operands_raw):
                matching_specs.append(spec_candidate)
        if len(matching_specs) == 0:
            raise AsmParserError(self._curr_ln, f"Could not find a matching spec for {line}")

        # we might find several matches if the instruction has a magic operand value
        if len(matching_specs) > 1:
            magic_value_specs = list(filter(lambda x: (x.has_magic_value), matching_specs))
            if magic_value_specs:
                matching_specs = magic_value_specs

        # at this point we should have only one spec, but even if we don't, all of them should
        # be equivalent. Just pick the first
        return matching_specs[0]

    def _create_instruction(self, spec: InstructionSpec, operands_raw: List[str],
                            is_instrumentation: bool, is_noremove: bool) -> Instruction:
        """
        Create an Instruction object and its operands based on the assembly line
        and the spec that describes the instruction
        """
        # create the instruction with no operands
        inst = Instruction.from_spec(
            spec, is_instrumentation=is_instrumentation, is_noremove=is_noremove)

        # create operands
        op: AnyOperand
        for op_id, op_raw in enumerate(operands_raw):
            op_spec = spec.operands[op_id]
            if op_spec.type == OT.REG:
                op = RegisterOp(op_raw, op_spec.width, op_spec.src, op_spec.dest)
            elif op_spec.type == OT.MEM:
                address_match = re.search(r'\[(.*)\]', op_raw)
                asm_parser_assert(address_match is not None, self._curr_ln,
                                  "Invalid memory address")
                address = address_match.group(1)  # type: ignore
                op = MemoryOp(address, op_spec.width, op_spec.src, op_spec.dest)
            elif op_spec.type == OT.IMM:
                op = ImmediateOp(op_raw, op_spec.width)
            elif op_spec.type == OT.LABEL:
                assert spec.is_control_flow or spec.name == "macro"
                op = LabelOp(op_raw)
            elif op_spec.type == OT.COND:
                op = CondOp(op_raw)
            else:  # AGEN
                address_match = re.search(r'\[(.*)\]', op_raw)
                asm_parser_assert(address_match is not None, self._curr_ln,
                                  "Invalid memory address")
                address = address_match.group(1)  # type: ignore
                op = AgenOp(address, op_spec.width)
            inst.operands.append(op)
        # add implicit operands
        for op_spec in spec.implicit_operands:
            # implicit operands should always have fixed spec, hence it's safe to use
            # the from_fixed_spec constructor
            op = Operand.from_fixed_spec(op_spec)
            inst.implicit_operands.append(op)
        return inst


# ==================================================================================================
# Public: High-level ASM Parser
# ==================================================================================================
class AsmParser(ABC):
    """
    Class responsible for parsing (and optionally patching) assembly files
    and producing TestCaseCode objects from them
    """

    _target_desc: Final[TargetDesc]
    _isa_spec: Final[InstructionSet]
    _asm_patcher: _AsmPatcher
    _line_parser: AsmLineParser
    _lines: List[_ASMLine]

    def __init__(self, isa_spec: InstructionSet, target_desc: TargetDesc) -> None:
        self._isa_spec = isa_spec
        self._target_desc = target_desc
        self._asm_patcher = _AsmPatcher()

    # ----------------------------------------------------------------------------------------------
    # Public Interface
    def parse_file(self,
                   asm_file: str,
                   generator: CodeGenerator,
                   elf_parser: ELFParser,
                   is_template: bool = False) -> TestCaseProgram:
        """
        Read a test case from a file, patch it to make it parsable (if necessary),
        create a complete TestCaseCode object based on it, and populate it with ELF data.

        This function is used instead of ProgramGenerator.create_test_case() when Revizor works
        with a user-provided test case. Hence, this function's output is expected to be
        equivalent to the output of ProgramGenerator.create_test_case().

        :param asm_file: path to the input assembly file to parse
        :param generator: an instance of ProgramGenerator object to assist in creating the test case
        :param elf_parser: an instance of ELFParser object to assist in creating the test case
        :return: a fully constructed TestCaseCode object
        """
        # Transform the input file into a list of ASMLine objects
        with open(asm_file, 'r') as f:
            dirty_lines = [_ASMLine(l, i) for i, l in enumerate(f)]

        # Apply patches to the assembly file to make it parsable
        patched_asm_file = asm_file + ".patched.asm"
        self._patch_asm(asm_file, patched_asm_file)
        dirty_lines = self._update_lines_after_patch(patched_asm_file, dirty_lines)

        # Build a map of the code structure
        clean_lines = self._get_clean_lines(dirty_lines)
        code_map = _CodeMapBuilder().create_code_map(clean_lines)

        # Create an empty test case with actors set up according to the configuration
        test_case = TestCaseProgram(patched_asm_file)
        generator.generate_actors_with_sections(test_case, CONF.get_actors_conf())

        # Fill the test case with the object representations of the parsed assembly
        self._fill_test_case_structure(test_case, code_map)
        assert len(test_case) > 0, "Default section not found"
        self._connect_control_flow(test_case)

        # Handle empty and trivial assembly files
        if len(test_case) == 1 and len(test_case[0]) == 1:
            self._handle_empty_test_case(test_case)

        # Perform final correctness checks
        self._check_test_case_correctness(test_case)

        # Assemble the test case and populate with ELF data
        if not is_template:  # there is no point in assembling a template
            test_case.assign_obj(asm_file[:-4] + ".o")
            assemble(test_case)
            elf_parser.populate_elf_data(test_case.get_obj(), test_case)

        return test_case

    # ----------------------------------------------------------------------------------------------
    # Private: Assembly Patching
    def _patch_asm(self, asm_file: str, patched_asm_file: str) -> None:
        return self._asm_patcher.patch_asm(asm_file, patched_asm_file)

    def _update_lines_after_patch(self, patched_asm_file: str,
                                  org_lines: List[_ASMLine]) -> List[_ASMLine]:
        """
        Create a list of ASMLine objects from the patched assembly file, such that
        the line number correspond to the original assembly file if the line was not patched
        """

        patched_lines = []
        with open(patched_asm_file, 'r') as patched:
            org_line_num = 0
            for patched_line_num, p_line in enumerate(patched):
                o_line_obj = org_lines[org_line_num]
                o_line = o_line_obj.str.strip().lower()

                p_line = p_line.strip().lower()
                p_line_obj = _ASMLine(p_line, 0)
                p_line_obj.patched_line_num = patched_line_num

                if o_line in p_line:
                    p_line_obj.line_num = o_line_obj.line_num
                    org_line_num += 1

                patched_lines.append(p_line_obj)
        return patched_lines

    # ----------------------------------------------------------------------------------------------
    # Private: Line Parsing
    def _get_clean_lines(self, org_lines: List[_ASMLine]) -> List[_ASMLine]:
        """ Remove comments and empty lines from a list of ASMLine objects """
        self._validate_dirty_lines(org_lines)

        lines = []
        finished = False
        for line_obj in org_lines:
            line_str = line_obj.str

            # Skip comments and empty lines
            if not line_str or line_str[0] in ["", "#", "/"]:
                continue

            # Skip lines after test case exit
            if line_str[:16] == TC_EXIT_LINE:
                finished = True
                continue
            if finished:
                continue

            # Save all other lines
            lines.append(line_obj)

        return lines

    def _validate_dirty_lines(self, lines: List[_ASMLine]) -> None:
        """ Check that the list of lines is well-formed """
        finished = False
        for line_obj in lines:
            line_str = line_obj.clean_str
            if not line_str:
                continue
            if line_str[:16] == TC_EXIT_LINE:
                finished = True
                continue

            # Check that there are no instructions after .test_case_exit
            if finished and line_str[0] not in ["", ".", "#", "/"]:
                raise AsmParserError(line_obj.line_num,
                                     f"Found instructions after .test_case_exit: {line_obj.str}")

        if not finished:
            raise AsmParserError(0, ".test_case_exit not found")

    def _parse_line(self, line: str, line_num: int) -> Instruction:
        return self._line_parser.parse_line(line, line_num)

    # ----------------------------------------------------------------------------------------------
    # Private: Building Test Case Structure
    def _fill_test_case_structure(self, test_case: TestCaseProgram, code_map: _CodeMap) -> None:
        """
        Initialize the structure of the test case according to the code map.
        The function fills the test case with sections, functions, basic blocks,
        instructions, and connects them
        :param test_case: the test case to be filled
        :param code_map: the code map representing the structure of the parsed assembly
        :return: None
        """
        for section_name, function_map in code_map.items():
            section = test_case.find_section(name=section_name)

            for func_name, bb_map in function_map.items():
                func = Function(func_name, section)
                section.append(func)

                for bb_name, inst_lines in bb_map.items():
                    # print(">>", bb_name)
                    bb = BasicBlock(bb_name, func)
                    func.append(bb)

                    terminators_started = False
                    for line in inst_lines:
                        # print(f"    {line}")
                        inst = self._parse_line(line.clean_str, line.line_num)
                        if not inst.is_control_flow:
                            assert not terminators_started, \
                                f"Line {line.line_num}: Terminator not at the end of BB"
                            bb.insert_after(bb.get_last(), inst)
                            continue

                        terminators_started = True
                        bb.terminators.append(inst)

    def _connect_control_flow(self, test_case: TestCaseProgram) -> None:
        """
        Connect the basic blocks in the test case by following their terminators
        :param test_case: the test case to connect
        :return: None
        """
        # connect basic blocks
        bb_names = {bb.name.lower(): bb for func in test_case.iter_functions() for bb in func}
        bb_names[TC_EXIT_LABEL] = test_case.get_tc_exit_bb()
        previous_bb = None
        for func in test_case.iter_functions():
            for bb in func:
                # fallthrough
                if previous_bb:  # skip the first BB
                    # there is a fallthrough only if the last terminator is not a direct jump
                    if not previous_bb.terminators or \
                       not self._target_desc.is_unconditional_branch(previous_bb.terminators[-1]):
                        previous_bb.successors.append(bb)
                previous_bb = bb

                # taken branches
                for terminator in bb.terminators:
                    # skip calls as they target functions, not basic blocks
                    if self._target_desc.is_call(terminator):
                        continue

                    for op in terminator.operands:
                        if isinstance(op, LabelOp):
                            asm_parser_assert(op.value in bb_names, -1, "Unknown label " + op.value)
                            successor = bb_names[op.value]
                            bb.successors.append(successor)

            # last BB always falls through to the exit
            func[-1].successors.append(func.get_exit_bb())

    def _handle_empty_test_case(self, test_case: TestCaseProgram) -> None:
        main = Function(".function_0", test_case.find_section(name="main"))
        test_case[0].append(main)

        bb = BasicBlock(".bb_0", main)
        main.append(bb)

        instr = Instruction("nop", "BASE-NOP")
        bb.insert_after(bb.get_last(), instr)
        bb.successors.append(main.get_exit_bb())

    # ----------------------------------------------------------------------------------------------
    # Private: Correctness Checks
    def _check_test_case_correctness(self, test_case: TestCaseProgram) -> None:
        """ Check that the TestCaseCode object created from the assembly file is correct """
        self._check_landing_sites(test_case)
        self._check_fault_handler(test_case)
        self._check_set_data_permission(test_case)

    def _check_landing_sites(self, test_case: TestCaseProgram) -> None:
        """ check that all actor switch macros have landing sites """
        # pylint: disable=too-many-branches
        # NOTE: there are many checks to be performed on the set_* family of macros, so
        # having many branches is expected

        switch_labels = [".set_k2u_target", ".set_u2k_target", ".set_h2g_target", ".set_g2h_target"]
        switches = []
        for func in test_case.iter_functions():
            for bb in func:
                for inst in bb:
                    if inst.name == "macro" and inst.operands[0].value in switch_labels:
                        switches.append(inst)

        for switch in switches:
            target = switch.operands[1].value.split(".")[2]
            for func in test_case.iter_functions():
                stripped_name = func.name[1:]
                if stripped_name == target:
                    target_function = func
                    break
            else:
                raise AsmParserError(-1, f"Macro {switch} targets a non-existing function")

            first_bb = target_function.get_first_bb()
            assert first_bb is not None, f"Macro {switch} targets a function without basic blocks"
            first_node = first_bb.get_first()
            assert first_node is not None, f"Macro {switch} targets a basic block without a landing"
            if not first_node.instruction.operands or \
               "landing" not in first_node.instruction.operands[0].value:
                raise AsmParserError(-1, f"{switch} does not target a landing site macro")
            target_name = first_node.instruction.operands[0].value

            if switch.operands[0].value == ".set_k2u_target" and target_name != ".landing_k2u":
                raise AsmParserError(switch.line_num(), f"{switch} does not target landing_k2u")
            if switch.operands[0].value == ".set_u2k_target" and target_name != ".landing_u2k":
                raise AsmParserError(switch.line_num(), f"{switch} does not target landing_u2k")
            if switch.operands[0].value == ".set_h2g_target" and target_name != ".landing_h2g":
                raise AsmParserError(switch.line_num(), f"{switch} does not target landing_h2g")
            if switch.operands[0].value == ".set_g2h_target" and target_name != ".landing_g2h":
                raise AsmParserError(switch.line_num(), f"{switch} does not target landing_g2h")

    def _check_fault_handler(self, test_case: TestCaseProgram) -> None:
        """ check that there is at most one fault handler """
        n_fault_handlers = 0
        for func in test_case.iter_functions():
            for bb in func:
                for inst in bb:
                    if inst.name == "macro" and inst.operands[0].value == ".fault_handler":
                        n_fault_handlers += 1
                    if n_fault_handlers > 1:
                        raise AsmParserError(inst.line_num(), "Found more than one fault handler")

    def _check_set_data_permission(self, test_case: TestCaseProgram) -> None:
        """ check that PT modification happens only in kernel host mode """
        for sec in test_case:
            owner = sec.owner
            for func in sec:
                for bb in func:
                    for inst in bb:
                        if inst.name == "macro" \
                           and inst.operands[0].value == ".set_data_permissions":
                            asm_parser_assert(
                                owner.privilege_level == ActorPL.KERNEL
                                and owner.mode == ActorMode.HOST, inst.line_num(),
                                "PT modification is allowed only in kernel host mode")
