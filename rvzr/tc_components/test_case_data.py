"""
File: Classes representing test case data (aka input), as well as related and derived classes.

Copyright (C) Microsoft Corporation
SPDX-License-Identifier: MIT
"""
from __future__ import annotations
from typing import TYPE_CHECKING, Tuple, Optional, List
import numpy as np

from ..sandbox import SandboxLayout, DataArea

if TYPE_CHECKING:
    from .actor import ActorID

InputID = int

# ==================================================================================================
# Per-actor input data
# ==================================================================================================

# _ActorInput data type represents the input for a single actor
_ActorInput = np.dtype(
    [
        ('main', np.uint64, SandboxLayout.data_area_size(DataArea.MAIN) // 8),
        ('faulty', np.uint64, SandboxLayout.data_area_size(DataArea.FAULTY) // 8),
        ('gpr', np.uint64, SandboxLayout.data_area_size(DataArea.GPR) // 8),
        ('simd', np.uint64, SandboxLayout.data_area_size(DataArea.SIMD) // 8),
        ('padding', np.uint64, SandboxLayout.data_area_size(DataArea.OVERFLOW_PAD) // 8),
    ],
    align=False,
)

_ACTOR_DATA_SIZE = _ActorInput['main'].itemsize + _ActorInput['faulty'].itemsize + \
    _ActorInput['gpr'].itemsize + _ActorInput['simd'].itemsize

# ==================================================================================================
# Full input data
# ==================================================================================================
UINT_NDARRAY = np.ndarray[Tuple[int, ...], np.dtype[np.uint64]]


class InputData(UINT_NDARRAY):
    """
    Class representing a single data input for a test case program (TestCaseCode).
    This data is used by the executor and the model to initialize the sandbox memory and registers.
    The input is typically generated by the input generator or parsed from a binary file.

    Internally, this class is a fixed-size numpy.ndarray of 64-bit unsigned integers,
    with a few addition methods for convenience.

    The array is organized as a 1D array of _ActorInput structures (one for each actor in the test
    case program), sorted by actor ID. Each _ActorInput structure contains the input data for a
    single actor, and it's layout mirrors the layout of the initialiable data regions
    of the sandbox.py:SandboxLayout.
    Namely, the Input array is organized as follows:

    |-----|-------------------------------| main
    | A   | sizeof(DataArea.MAIN)         |
    | C   |-------------------------------| faulty
    | T   | sizeof(DataArea.FAULTY)       |
    | O   |-------------------------------| gpr
    | R   | sizeof(DataArea.GPR)          |
    |     |-------------------------------| simd
    | 0   | sizeof(DataArea.SIMD)         |
    |     |-------------------------------| padding
    |     | sizeof(DataArea.OVERFLOW_PAD) |
    |-----|-------------------------------|
    | ... (repeat for n_actors)

    The data in each region could be accesses via the array interface, e.g.,
    actor0_main = Input[0]['main']

    The array size is equal to the number of actors multiplied by
    the number of elements in _ActorInput, i.e.,
        Input.size = n_actors * _ActorInput.size
    """

    seed: int = 0
    """ seed: The seed value used to generate this input """

    # ==============================================================================================
    # Constructors

    def __new__(cls, n_actors: int = 1) -> InputData:
        obj = super().__new__(cls, (n_actors,), _ActorInput, None, 0, None, None)
        return obj

    def __array_finalize__(self, obj: Optional[UINT_NDARRAY]) -> None:  # type: ignore
        # if obj is None:
        #     return
        pass

    # ==============================================================================================
    # Class interface

    @classmethod
    def data_size_per_actor(cls) -> int:
        """
        Get the size (in bytes) of the data area for a single actor.
        :return: Size, in bytes
        """
        return _ACTOR_DATA_SIZE

    @classmethod
    def n_data_entries_per_actor(cls) -> int:
        """
        Get the number of entries in the input array for a single actor.

        Note: This function is NOT equivalent to `data_size_per_actor`.
        This is because array entries are 64-bit integers.
        :return: Number of entries
        """
        return _ACTOR_DATA_SIZE // 8

    # ==============================================================================================
    # Object interface

    def __hash__(self) -> int:  # type: ignore
        # hash of input is a hash of input data, registers and memory
        h = hash(self.tobytes())
        return h

    def __str__(self) -> str:
        return str(self.seed)

    def __repr__(self) -> str:
        return str(self.seed)

    def set_actor_data(self, actor_id: 'ActorID', data: UINT_NDARRAY) -> None:
        """
        Set the data for a single actor.
        :param actor_id: The actor ID
        :param data: The data to set
        :return: None
        :raises AssertionError: If the data array has an unexpected shape
        """
        assert data.shape == (self.itemsize // 8,), \
            "Data shape does not match the expected shape"

        # copy the data
        self[actor_id] = data.view(_ActorInput)

        # zero-fill the unused parts of the input
        self[actor_id]['padding'] = 0

    def save(self, path: str) -> None:
        """
        Save the input to a binary file.
        :param path: The path to the file
        """

        with open(path, 'wb') as f:
            f.write(self.tobytes())

    def load(self, path: str) -> None:
        """
        Load the input from a binary file.
        :param path: The path to the file
        """

        with open(path, 'rb') as f:
            contents = np.fromfile(f, dtype=np.uint64)
            n_actors = self.shape[0]
            for actor_id in range(n_actors):
                actor_start = actor_id * self.itemsize // 8
                actor_end = actor_start + self.itemsize // 8
                self.linear_view(actor_id)[:] = contents[actor_start:actor_end]

    def linear_view(self, actor_id: ActorID) -> UINT_NDARRAY:
        """
        Get a linear view of the input for a single actor;
        that is, a 1D array of 64-bit integers.
        :param actor_id: The actor ID
        :return: A linear view of the input for the actor
        """
        view: UINT_NDARRAY = self[actor_id].view((np.uint64, self[actor_id].itemsize // 8))
        return view


def save_input_sequence_as_rdbf(inputs: List[InputData], path: str) -> None:
    """
    Save the input sequences into an RDBF-formatted file.
    (see docs/devel/binary-formats.md for details on RDBF format).

    :param inputs: The input sequence
    :param path: The path to save the RDBF file to
    :return: None
    """
    n_actors = len(inputs[0]) if len(inputs) > 0 else 1
    with open(path, 'wb') as f:
        # header
        f.write((n_actors).to_bytes(8, byteorder='little'))  # number of actors
        f.write((len(inputs)).to_bytes(8, byteorder='little'))  # number of inputs

        # metadata
        data_size_per_actor_bytes = InputData.data_size_per_actor()
        for _ in range(n_actors):
            f.write((data_size_per_actor_bytes).to_bytes(8, byteorder='little'))  # size
            f.write((0).to_bytes(8, byteorder='little'))  # reserved

        # data
        for input_ in inputs:
            f.write(input_.tobytes())


# ==================================================================================================
# Input taint
# ==================================================================================================

BOOL_NDARRAY = np.ndarray[Tuple[int], np.dtype[np.bool_]]

_ActorInputTaint = np.dtype(
    [
        ('main', np.bool_, _ActorInput['main'].shape[0]),
        ('faulty', np.bool_, _ActorInput['faulty'].shape[0]),
        ('gpr', np.bool_, _ActorInput['gpr'].shape[0]),
        ('simd', np.bool_, _ActorInput['simd'].shape[0]),
        ('padding', np.bool_, _ActorInput['padding'].shape[0]),
    ],
    align=False,
)


class InputTaint(BOOL_NDARRAY):
    """
    Fixed-size boolean array that represents the taint status of a single test case input.
    The array layout is identical to the Input class, with the same number of elements.
    If an element is True, the corresponding element in the Input array is considered tainted.

    The array is used to indicate which input elements influence contract traces.
    """

    per_actor_taint_size: int = _ActorInputTaint.itemsize
    """ per_actor_taint_size: The size of the taint area for a single actor """

    def __new__(cls, n_actors: int = 1) -> InputTaint:
        obj = super().__new__(cls, (n_actors,), _ActorInputTaint, None, 0, None, None)
        obj.fill(False)
        return obj

    def __array_finalize__(self, obj: Optional[UINT_NDARRAY]) -> None:  # type: ignore
        # if obj is None:
        #     return
        pass

    def linear_view(self, actor_id: 'ActorID') -> BOOL_NDARRAY:
        """
        Get a linear view of the taint for a single actor;
        that is, a 1D array of booleans.
        :param actor_id: The actor ID
        :return: A linear view of the taint for the actor
        """
        view: BOOL_NDARRAY = self[actor_id].view((np.bool_, self[actor_id].itemsize))
        return view

    def taint_actor_offsets(self, actor_id: 'ActorID', offsets: List[int]) -> None:
        """
        Taint a list of locations in the input of a single actor as tainted. The locations are
        specified as offsets in the _ActorInput structure.
        :param actor_id: The actor ID
        :param offsets: A list of offsets
        :return: None
        """
        actor_view = self.linear_view(actor_id)
        for offset in offsets:
            actor_view[offset] = True

    @classmethod
    def taint_offset_from_sandbox_address(cls, sb_address: int) -> int:
        """
        This function exists to cover the mismatch between the sandbox layout (sandbox.py) and
        the InputTaint layout (this class).

        The function computes the offset in the InputTaint structure from a given sandbox address
        by subtracting the missing padding.

        :param sb_address: The sandbox address
        :return: The offset in the InputTaint structure
        """
        per_actor_sandbox_size = SandboxLayout.data_size_per_actor()
        actor_id = sb_address // per_actor_sandbox_size
        sandbox_offset = sb_address % per_actor_sandbox_size
        taint_offset = sandbox_offset - SandboxLayout.data_area_size(DataArea.MAIN)
        return taint_offset // 8 + (actor_id * cls.per_actor_taint_size)
