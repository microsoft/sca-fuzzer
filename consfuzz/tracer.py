"""
File: Module responsible for collecting contract traces

Copyright (C) Microsoft Corporation
SPDX-License-Identifier: MIT
"""
from __future__ import annotations
from typing import TYPE_CHECKING, List, Final

import os
import subprocess
from enum import Enum
from tqdm import tqdm

from rvzr.model_dynamorio.trace_decoder import TraceDecoder
from .logger import Logger

if TYPE_CHECKING:
    from .config import Config


class ExecOutcome(Enum):
    """
    Outcome of an execution of the tracer. The program can either exit without errors, or throw
    an (architectural) exception, or an unexpected failure can be happening in the instrumentation.
    """
    SUCCESS = 0
    PROGRAM_EXCEPTION = 1
    INSTR_EXCEPTION = 2
    COV_EXCEPTION = 3
    UNKNOWN = 4


class Tracer:
    """
    Class responsible for executing the target binary on the leakage model and retrieving the
    collected contract traces.
    """

    _drrun_cmd: Final[str]
    _log: Final[Logger]

    def __init__(self, config: Config) -> None:
        self._log = Logger("Tracer")

        self._config = config
        self._drrun_cmd = f"{config.model_root}/drrun " \
                          f"-c {config.model_root}/libdr_model.so " \
                          f"--tracer {config.contract_observation_clause} " \
                          f"--speculator {config.contract_execution_clause} " \
                          "--instrumented-func wrapper --trace-output {trace_file} -- {cmd}"
        self._coverage_cmd = "LLVM_PROFILE_FILE={cov_file} {cmd}"

    def collect_traces(self, cmd: List[str]) -> int:
        """
        Iterate over all previously-generated public-private input pairs and collect contract traces
        for each pair.

        :param cmd: Command to run the target binary, with placeholders for public (@@)
                        and private (@#) inputs
        :return: 0 if successful, 1 if error occurs
        """
        # Check if the traces are deterministic; abort if they are not
        if not self._check_determinism(self._config.stage2_wd, cmd):
            self._log.error("The target binary produces non-deterministic traces. Tracing aborted.")
            return 1

        # Get a list of input groups
        input_group_dirs = []
        for input_group in os.listdir(self._config.stage2_wd):
            input_group_dir = os.path.join(self._config.stage2_wd, input_group)
            if not os.path.isdir(input_group_dir):
                continue
            input_group_dirs.append(input_group_dir)

        # Iterate over all input groups and collect traces
        pairs = []
        for input_group_dir in input_group_dirs:
            # Get a list of public-private input pairs
            pub_input = os.path.join(input_group_dir, "public")
            for sec_input_ in os.listdir(input_group_dir):
                if "private" not in sec_input_:
                    continue
                if "log" in sec_input_ or "trace" in sec_input_ or "failed" in sec_input_:
                    continue
                sec_input = os.path.join(input_group_dir, sec_input_)
                pairs.append((pub_input, sec_input))

        # Initialize a progress bar to track the progress of the tracing process
        progress_bar = tqdm(total=len(pairs))
        # Process each pair
        for pub_input, sec_input in pairs:
            pair_name = sec_input
            # Expand the command with the public and private inputs
            expanded_cmd = self._expand_target_cmd(cmd, pub_input, sec_input)

            # Execute the target binary and collect traces
            outcome = self._execute(expanded_cmd, pair_name, self._config.coverage)
            if outcome == ExecOutcome.INSTR_EXCEPTION:
                # Check if the error was produced by the target program or by a bug in the
                # instrumentation
                # NOTE: we intentionally ignore errors in the target program, as many files
                # generated by AFL++ are invalid, which leads to errors during execution; this
                # is expected and does not affect the correctness of the fuzzing process
                # Mark this test as failed by creating a .failed file
                with open(f"{sec_input}.failed", "w") as failed_log:
                    failed_log.close()

            progress_bar.update()

        progress_bar.close()
        return 0

    def _expand_target_cmd(self, cmd: List[str], public_input: str, private_input: str) -> str:
        """
        Replace the placeholders in the command with the actual public and private inputs.
        """
        expanded_cmd = cmd
        expanded_cmd = [s if s != "@@" else public_input for s in expanded_cmd]
        expanded_cmd = [s if s != "@#" else private_input for s in expanded_cmd]
        expanded_str = " ".join(expanded_cmd)
        return expanded_str

    def _execute(self, expanded_str: str, pair_name: str, enable_cov: bool) -> ExecOutcome:
        """
        Execute the target binary on the leakage model with the given public and private inputs.

        If `enable_cov` is True, the command will also collect coverage information.

        :param expanded_str: Command to run the target binary, with public and private inputs
        :param pair_name: Base name for the output files (trace and log)
        :param enable_cov: Whether to collect coverage information
        :return: The outcome of the execution (either success or reason for failures)
        """
        trace_file = f"{pair_name}.trace"
        log_file = f"{pair_name}.log"

        complete_cmd = self._drrun_cmd.format(cmd=expanded_str, trace_file=trace_file)
        # print(complete_cmd, flush=True)
        try:
            with open(log_file, "a") as f:
                f.write("$> " + complete_cmd + "\n")
                subprocess.check_call(complete_cmd, shell=True, stdout=f, stderr=f)
        except subprocess.CalledProcessError:
            if TraceDecoder().is_trace_corrupted(trace_file):
                return ExecOutcome.INSTR_EXCEPTION
            return ExecOutcome.PROGRAM_EXCEPTION

        if not enable_cov:
            return ExecOutcome.SUCCESS

        # If coverage is enabled, run the command with coverage collection
        cov_file = f"{pair_name}.profraw"
        coverage_cmd = self._coverage_cmd.format(cov_file=cov_file, cmd=expanded_str)
        try:
            subprocess.check_call(
                coverage_cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError:
            self._log.error(f"Error executing coverage command: {coverage_cmd}")
            return ExecOutcome.COV_EXCEPTION
        return ExecOutcome.SUCCESS

    def _check_determinism(self, wd: str, cmd: List[str]) -> bool:
        """
        Check if the traces are deterministic by running the target binary multiple times
        with the same inputs and comparing the outputs.
        :param wd: Working directory containing the input pairs
        :param cmd: Command to run the target binary, with placeholders for public (@@)
                    and private (@#) inputs
        :return: True if the traces are deterministic, False otherwise
        :raise: AssertionError if no input pairs are found
        """
        # pick an arbitrary input pair from the working directory
        input_group = next((d for d in os.listdir(wd) if os.path.isdir(os.path.join(wd, d))), None)
        assert input_group is not None
        input_group_dir = os.path.join(wd, input_group)
        pub_input = os.path.join(input_group_dir, "public")
        sec_input = os.path.join(input_group_dir, "private_000")

        # expand the command with the public and private inputs
        expanded_cmd = self._expand_target_cmd(cmd, pub_input, sec_input)

        # execute the target binary twice and collect traces
        for i in [0, 1]:
            pair_name = os.path.join(input_group_dir, f"determinism_check_{i}")
            if self._execute(expanded_cmd, pair_name, False) != ExecOutcome.SUCCESS:
                raise RuntimeError(f"Error executing command: {expanded_cmd}")

        # compare the traces
        with open(os.path.join(input_group_dir, "determinism_check_0.trace"), "rb") as f0, \
             open(os.path.join(input_group_dir, "determinism_check_1.trace"), "rb") as f1:
            trace_0_content = f0.read()
            trace_1_content = f1.read()
        if trace_0_content != trace_1_content:
            return False

        return True
