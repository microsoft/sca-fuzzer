///
/// File: Abstract Model TracerABC
///
// Copyright (C) Microsoft Corporation
// SPDX-License-Identifier: MIT

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <new>
#include <string>
#include <utility>
#include <vector>

#include <dr_api.h> // NOLINT
#include <dr_defines.h>
#include <dr_events.h>
#include <dr_ir_instr.h>
#include <dr_ir_opnd.h>
#include <dr_ir_utils.h>
#include <dr_tools.h>

#include <drmgr.h>
#include <drreg.h>
#include <drvector.h>

#include "tracer_abc.hpp"
#include "util.hpp"

using std::bad_alloc;
using std::string;
using std::vector;

// =================================================================================================
// Local helper functions for allocating and freeing memory
// =================================================================================================
namespace
{

// We allow these specific registers because they are not used
// in the test cases generated by Revizor (see src/x86/x86_config.py:register_blocklist)
constexpr int REG_IDS[] = {DR_REG_R8, DR_REG_R9, DR_REG_R10, DR_REG_R11, DR_REG_R12}; // NOLINT
constexpr int N_RESERVED_REGS = 5;

/// @brief Flush all traces in binary format
/// @param trace The trace buffer
/// @param enable_bin_output If true, the debug trace will be printed in binary format
///                          Otherwise, it will be printed in human-readable format
/// @return void
void print_traces(vector<trace_entry_t> *trace, bool enable_bin_output = false)
{
    // Print all trace entries
    for (const auto &entry : *trace) {
        if (enable_bin_output) {
            fwrite(&entry, sizeof(trace_entry_t), 1, stdout);
        } else {
            fprintf(stdout, "%lx %lx %lx\n", entry.type, entry.addr, entry.size);
        }
    }

    // Print a marker to indicate the end of the trace (EOT)
    trace_entry_t eot = {ENTRY_EOT, 0, 0};
    if (enable_bin_output) {
        fwrite(&eot, sizeof(trace_entry_t), 1, stdout);
    } else {
        fprintf(stdout, "%lx %lx %lx\n", eot.type, eot.addr, eot.size);
    }
}

/// @brief Flush all debug traces entries into the standard output
/// @param dbg_trace The debug trace buffer
/// @param enable_bin_output If true, the debug trace will be printed in binary format
///                          Otherwise, it will be printed in human-readable format
/// @return void
void print_dbg_traces(vector<dbg_trace_entry_t> *dbg_trace, bool enable_bin_output = false)
{
    // Print the debug trace buffer
    for (const auto &entry : *dbg_trace) {
        if (enable_bin_output) {
            fwrite(&entry, sizeof(dbg_trace_entry_t), 1, stdout);
        } else {
            fprintf(stdout, "%lx %lx %lx %lx %lx %lx %lx\n", entry.xax, entry.xbx, entry.xcx,
                    entry.xdx, entry.xsi, entry.xdi, entry.pc);
        }
    }

    // Print the end of trace marker
    trace_entry_t eot = {ENTRY_EOT, 0, 0};
    if (enable_bin_output)
        fwrite(&eot, sizeof(trace_entry_t), 1, stdout);
    else
        fprintf(stdout, "%lx %lx %lx\n", eot.type, eot.addr, eot.size);
}

} // namespace

// =================================================================================================
// Constructors and Destructors
// =================================================================================================
TracerABC::TracerABC(bool enable_dbg_trace_, bool enable_bin_output_)
    : enable_dbg_trace(enable_dbg_trace_), enable_bin_output(enable_bin_output_)
{
    // Initialize trace buffers
    trace = std::vector<trace_entry_t>();
    dbg_trace = std::vector<dbg_trace_entry_t>();
}

TracerABC::~TracerABC() {}

// =================================================================================================
// Public Methods
// =================================================================================================
void TracerABC::tracing_start(void *, DR_PARAM_OUT void **)
{
    tracing_on = true;
    tracing_finalized = false;
}

void TracerABC::tracing_finalize(void *, DR_PARAM_OUT void *)
{
    if (tracing_finalized) {
        return;
    }

    // Print the trace buffers
    print_traces(&trace, enable_bin_output);
    if (enable_dbg_trace) {
        print_dbg_traces(&dbg_trace, enable_bin_output);
    }

    // Reset the trace buffers
    trace.clear();
    dbg_trace.clear();

    // Reset the tracing flag
    tracing_on = false;
    tracing_finalized = true;
}

void TracerABC::observe_instruction(uint64_t opcode, uint64_t pc, dr_mcontext_t *mc)
{
    // Nothing to do if tracing is off
    if (not tracing_on) {
        return;
    }

    // In debug mode, store the register values and PC on the debug trace buffer
    if (enable_dbg_trace) {
        const dbg_trace_entry_t entry = {
            .type = ENTRY_REG_DUMP,
            .xax = mc->xax,
            .xbx = mc->xbx,
            .xcx = mc->xcx,
            .xdx = mc->xdx,
            .xsi = mc->xsi,
            .xdi = mc->xdi,
            .pc = pc,
        };
        dbg_trace.push_back(entry);
    }

    // The rest of the functionality - if any - is implemented by subclasses
    return;
}

void TracerABC::observe_mem_access(bool is_write, void *address, uint64_t size) {}
