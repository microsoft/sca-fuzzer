{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Revizor","text":"<p>Welcome to Revizor.</p>"},{"location":"architecture/","title":"Revizor Architecture","text":"<p>Below is a high-level overview of Revizor's architecture and its key modules.</p> <p>[THE FOLLOWING IS A WORK IN PROGRESS]</p> <p></p> <p>Revizor has five chief components:</p> <ol> <li>Test Case Generator</li> <li>Input Generator</li> <li>Model</li> <li>Executor</li> <li>Analyser</li> </ol> <p>The Test Case Generator and Input Generator are responsible for generating random test cases to be run through the Model and Executor. The results are examined by the Analyser for contract violations.</p>"},{"location":"architecture/#test-case-program-generator","title":"Test Case (Program) Generator","text":"<p>The TCG is responsible for generating random assembly test cases. It takes an Instruction Set Specification as input in order for it to understand the instructions and syntax it can use for generation.</p>"},{"location":"architecture/#input-generator","title":"Input Generator","text":"<p>The IG is responsible for generating the inputs that are passed into a test case created by the TCG. Largely, this means register and memory values that the microarchitecture will be primed with before executing the test case. In this way, a single test case program can be run across several different inputs, allowing for multiple contract traces (and later, hardware traces) to be collected for analysis.</p>"},{"location":"architecture/#model","title":"Model","text":"<p>The Model's job is to accept test cases and inputs from the TCG &amp; IG and emulate the test case to collect contract traces. A single test case seeded with several inputs (<code>N</code> inputs) will create several contract traces (<code>N</code> contract traces) as the model's output. These are passed to the Analyser to determine input classes.</p>"},{"location":"architecture/#executor","title":"Executor","text":"<p>The Executor, on the other side from the Model, is responsible for running the same test cases (with the same inputs) on physical hardware to collect hardware traces. Hardware traces from the same input class are collected and studied by the Analyser to detect contract violations.</p>"},{"location":"architecture/#analyser","title":"Analyser","text":"<p>The Analyser receives contract traces from the Model and hardware traces from the Executor to accomplish two primary goals:</p> <ol> <li>Compare contract traces to set up input classes.</li> <li>Compare hardware traces to detect contract violations.</li> </ol>"},{"location":"architecture/#revizor-modules-and-interfaces","title":"Revizor Modules and Interfaces","text":"<p>Revizor's implementation and architecture is separated into multiple Python files:</p> <ul> <li><code>cli.py</code> - implements the command-line interface of revizor.</li> <li><code>config.py</code> - implements parsing and managing of revizor's YAML configuration   file.</li> <li><code>generator.py</code> - implements the Test Case Generator portion of   revizor's architecture.</li> <li><code>input_generator.py</code> - implements the Input Generator portion of   revizor's architecture.</li> <li><code>model.py</code> - implements the Unicorn-based Model portion of   revizor's architecture.</li> <li><code>executor.py</code> - implements the Executor portion of   revizor's architecture.</li> <li><code>analyser.py</code> - implements the Analyser portion of   revizor's architecture.</li> <li><code>postprocessor.py</code> - defines the <code>MinimizerViolation</code> class, used during   <code>minimize</code> mode to reduce a violation-inducing test case down to a smaller   size while still maintaining the violation-inducing behavior.</li> <li><code>fuzzer.py</code> - implements <code>fuzz</code> mode that utilizes all main components to   perform end-to-end hardware fuzzing.</li> <li><code>factory.py</code> - used to configure revizor accordingly to the user provided   YAML configuration. Implements a simplified version of the Factory pattern:   Defines a series of dictionaries that allows revizor to choose   between various contract, generation techniques, executors, analysers, etc.   In future, it be also used to implement  multiple-ISA support.</li> <li><code>interfaces.py</code> - defines abstract classes (i.e., interfaces) of all main   components of revizor (e.g., abstract  <code>Executor</code>, <code>Model</code>, <code>TestCase</code>,    <code>Input</code>, etc)</li> <li><code>isa\\_loader.py</code> - defines the <code>InstructionSet</code> class, used to load an   ISA's specifications from a JSON file provided via the   command-line interface.</li> <li><code>service.py</code> - defines logging, statistical, and other services to all other   modules within revizor.</li> </ul>"},{"location":"architecture/#architecture-specific-implementation","title":"Architecture-specific Implementation","text":"<p>The modules above are ISA-independent. The architecture-specific implementations are located in the subdirectories. For example, the implementation of the modules for the x86-64 architecture is located in <code>src/x86/</code>. It's structure largely mirrors the main modules of revizor (e.g., <code>x86_model.py</code> contains x86-specific parts of the Model module). The only unique parts are:</p> <ul> <li><code>*_target_desc.py</code> - defines constants describing the ISA (e.g., a list of   available registers) and some helper functions.</li> <li><code>get_spec.py</code> - a script for transforming the ISA description provided   by the CPU vendor (different for every vendor) into a unified JSON format</li> <li><code>executor/</code> - contains a low-level implementation of the executor. The   implementation will be different for each architecture. For black-box x86 CPUs,   it is a Linux kernel module.</li> </ul>"},{"location":"architecture/#abstract-test-case","title":"Abstract Test Case","text":"<p>This describes a number of Python classes within revizor that define parts of an assembly test case. Revizor's TCG uses them to generate syntactically-valid assembly. The classes are defined in <code>interfaces.py</code>.</p>"},{"location":"architecture/#operandspec","title":"<code>OperandSpec</code>","text":"<p>The <code>OperandSpec</code> class defines a set of valid operands for any given assembly instruction. Each <code>InstructionSpec</code> object (described below) contains a list of these operand specifications. It contains properties such as:</p> <ul> <li>The <code>type</code> of operand</li> <li>The <code>width</code> of the operand</li> <li>Whether or not the operand is a <code>src</code> or <code>dest</code> operand</li> </ul>"},{"location":"architecture/#instructionspec","title":"<code>InstructionSpec</code>","text":"<p>This class represents a single instruction specification. It contains a name (i.e. the actual instruction mnemonic, such as <code>ADD</code>) and a list of <code>OperandSpec</code>s, defining valid operands for the instruction. It also has a number of boolean flags that indicate unique attributes about the instruction, such as:</p> <ul> <li>If the instruction contains a memory write</li> <li>If the instruction is a control-flow instruction</li> </ul>"},{"location":"architecture/#operand","title":"<code>Operand</code>","text":"<p>The <code>Operand</code> class defines an actual operand to be used in an instruction placed into the TCG's generated test case (not to be confused with <code>OperandSpec</code>, which is a set of rules used to define possible operand choices for an instruction). This is an abstract base class that provides a number of sub-classes:</p> <ul> <li><code>RegisterOperand</code></li> <li><code>MemoryOperand</code></li> <li><code>ImmediateOperand</code></li> <li><code>LabelOperand</code></li> <li><code>AgenOperand</code></li> <li><code>FlagsOperand</code></li> </ul>"},{"location":"architecture/#instruction","title":"<code>Instruction</code>","text":"<p>Similar to the relationship between <code>OperandSpec</code> and <code>Operand</code>, the <code>Instruction</code> class defines an actual instruction, constrained by an <code>InstructionSpec</code>, that is used during test case generation. It contains a list of <code>Operand</code>s and is linked to its neighboring instructions via object references.</p>"},{"location":"architecture/#basicblock","title":"<code>BasicBlock</code>","text":"<p>Thisi class represents a single basic block within the generated test case (a basic block is a straight-line sequence of assembly instructions that has a single entry and exit point). It contains a list of all instructions contained within, references to its successor basic block(s), and a list of \"terminator\" instructions (instructions that exit the basic block, such as a branch).</p>"},{"location":"architecture/#function","title":"<code>Function</code>","text":"<p>This object represents a collection of basic blocks that form a function. It has an \"entry\" basic block and an \"exit\" basic block, along with a list of all basic blocks that comprise the function.</p>"},{"location":"architecture/#testcasedag","title":"<code>TestCaseDAG</code>","text":"<p>DAG is short for Directed Acyclic Graph. This object represents the entire test case's control flow. It contains a list of functions that, within, define all instructions to be written out to the test case's assembly file.</p>"},{"location":"cli/","title":"Command-Line Interface","text":"<p>Revizor is controlled via two interfaces: command line and configuration file. Command line arguments specify the mode of operation and set high-level parameters (e.g., file paths, number of fuzzing rounds). Configuration files specify details of the fuzzing campaign (e.g., the target contract, generation parameters, etc).</p> <p>This document describes the command-line interface. For information on configuration files, see the configuration documentation.</p>"},{"location":"cli/#modes","title":"Modes","text":"<p>Revizor can run in one of multiple \"modes\":</p> <ul> <li>Fuzzing mode is revizor's main form of execution. In this mode, revizor generates random test cases, tests them on the target CPU and the model, and checks for contract violations.</li> <li>Template fuzzing mode is a variant of fuzzing mode that uses a template to generate test cases.</li> <li>Reproduce mode is a variant of fuzzing mode that attempts to reproduce a violation found in a previous run.</li> <li>Minimize mode accepts a test case and attempts to simplify it by applying a series of passes.</li> </ul> <p>To select a mode on the command-line, begin your command with:</p> <pre><code>rvzr MODE # ... arguments go here\n\n# Where MODE can be:\n#   fuzz            for fuzzing mode\n#   tfuzz           for template fuzzing mode\n#   reproduce       for reproduce mode\n#   minimize        for test case minimization mode\n</code></pre>"},{"location":"cli/#fuzzing-mode","title":"Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>fuzz</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  -t TESTCASE, --testcase TESTCASE\n                        Use an existing test case [DEPRECATED - see reproduce]\n  --timeout TIMEOUT     Run fuzzing with a time limit [seconds]. No timeout when set to zero.\n  --nonstop             Don't stop after detecting an unexpected result\n  --save-violations SAVE_VIOLATIONS\n                        If set, store all detected violations in working directory.\n</code></pre>"},{"location":"cli/#template-fuzzing-mode","title":"Template Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>analyse</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  -t TEMPLATE, --template TEMPLATE\n                        The template to use for generating test cases\n  --timeout TIMEOUT     Run fuzzing with a time limit [seconds]. No timeout when set to zero.\n  --nonstop             Don't stop after detecting an unexpected result\n  --enable-store-violations ENABLE_STORE_VIOLATIONS\n                        If set, store all detected violations in working directory.\n</code></pre>"},{"location":"cli/#reproduce-mode","title":"Reproduce Mode","text":"<p>The following command-line arguments are supported in <code>reproduce</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -t TESTCASE, --testcase TESTCASE\n                        Path to the test case\n  -i [INPUTS ...], --inputs [INPUTS ...]\n                        Path to the directory with inputs\n  -n NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case. [IGNORED if --input-dir is set]\n</code></pre>"},{"location":"cli/#minimize-mode","title":"Minimize Mode","text":"<p>Minimize mode is described in detail in the minimization documentation.</p>"},{"location":"config/","title":"Configuration File","text":"<p>Below is a list of the available configuration options for Revizor, which are passed down to Revizor via a config file. For an example of how to write the config file, see src/tests/big-fuzz.yaml.</p>"},{"location":"config/#fuzzing-configuration","title":"Fuzzing Configuration","text":"<pre><code>Name: fuzzer\nDefault: 'basic'\nOptions: 'basic' | 'architectural' | 'archdiff'\n</code></pre> <p>This option selects the fuzzing mode. The available options are:</p> <ul> <li><code>basic</code> - normal model-based fuzzing. A violation in this mode indicates that the CPU exposes more information than predicted by the contract. This option should be used in most testing campaigns.</li> <li><code>architectural</code> - self-fuzzing for architectural mismatches between the model and the executor. This option should be used for testing the fuzzer itself, i.e., a violation in this mode indicates a bug in the fuzzer rather then a bug in the CPU. This is useful when running the fuzzer with a previously-untested instruction set, or when a new contract is implemented.</li> <li><code>archdiff</code> - fuzzing for architectural invariants. This is a special mode targeted for for semi-microarchitectural violations, similar to ZenBleed. This mode is experimental and should be used with caution.</li> </ul> <pre><code>Name: enable_priming\nDefault: True\n</code></pre> <p>This option enables or disables priming. This options should be set to True in most cases, as priming is crucial for eliminating false positives.</p> <p>Priming solves the following problem: Revizor collects hardware traces for inputs in a sequence, and the microarchitectural state is not reset between the inputs. This means that the microarchitectural state for the input at, for example, position 100 is different from the state for the input at position 200. Accordingly, the hardware traces for these inputs may differ because the measurements are taken in different microarchitectural contexts.</p> <p>To address this issue, we uses priming, which swaps the inputs in the sequence and re-runs the tests. For example, if the original sequence is (i1 . . . i99,i100,i101 . . . i199,i200), the priming sequence will be (i1 . . . i99,i200,i101 . . . i199,i100). If the violation persists in this sequence, it is a true positive. If the violation disappears, it is a false positive, and it will be discarded.</p> <pre><code>Name: enable_speculation_filter\nDefault: False\n</code></pre> <p>If enabled, Revizor will discard test cases that do not trigger speculation.</p> <p>This option is useful for improving the throughput of the fuzzer, but it can discard potential violations if the leakage is not caused by speculation.</p> <pre><code>Name: enable_observation_filter\nDefault: False\n</code></pre> <p>If enabled, Revizor will discard test cases that do not leave speculative traces. The filtering is performed by adding an <code>LFENCE</code> after each instruction in the test case, and comparing the resulting hardware traces with the original. If the traces are identical, the test case is discarded.</p> <p>This option is useful for improving the throughput of the fuzzer, but it can discard potential violations if the leakage is not caused by speculation.</p> <pre><code>Name: enable_fast_path_model\nDefault: True\n</code></pre> <p>If enabled, the same contract trace will be used for all inputs in the same taint-based input class.</p> <pre><code>Name: color\nDefault: False\n</code></pre> <p>If enabled, the output will be colored. This option is helps a lot with readability, but may produce corrupted output when redirected to a file.</p> <pre><code>Name: logging_modes\nDefault: ['info', 'stat']\nOptions: 'info' | 'stat' | 'dbg_timestamp' | 'dbg_violation' | 'dbg_dump_htraces' | 'dbg_dump_ctraces' | 'dbg_dump_traces_unlimited' | 'dbg_executor_raw' | 'dbg_model' | 'dbg_coverage' | 'dbg_generator' | 'dbg_priming'\n</code></pre> <p>This option controls the output:</p> <ul> <li><code>info</code> - general information about the progress of fuzzing;</li> <li><code>stat</code> - statistics the end of the fuzzing campaign;</li> <li><code>dbg_timestamp</code> - every 1000 test cases print the timestamp during the fuzzing process;</li> <li><code>dbg_violation</code> - upon detecting a violation, print detailed information about it;</li> <li><code>dbg_dump_htraces</code> - print the first 100 hardware traces for every test case;</li> <li><code>dbg_dump_ctraces</code> - print the first 100 contract traces for every test case;</li> <li><code>dbg_dump_traces_unlimited</code> - print ALL traces (use carefully, produces LOTS of text);</li> <li><code>dbg_executor_raw</code> - prints hardware traces for every stage of the fuzzing process;   this differs from <code>dbg_dump_htraces</code> in that it prints the traces collected by   speculation/observation filters as well as at every iteration of multi-sample collection;</li> <li><code>dbg_model</code> - print a detailed info about EVERY instruction executed on the model (use carefully, produces LOTS of text);</li> <li><code>dbg_coverage</code> - stores instruction coverage information;</li> <li><code>dbg_generator</code> - prints a list of instructions used to generate test cases;</li> <li><code>dbg_priming</code> - prints information about the priming process; only useful for debugging the priming mechanism itself.</li> </ul> <pre><code>Name: multiline_output\nDefault: False\n</code></pre> <p>If enabled, each output message will be printed on a separate line. Otherwise, the fuzzing progress will be continuously overwriting the same line (works only in the terminal).</p>"},{"location":"config/#program-generator-configuration","title":"Program Generator Configuration","text":"<pre><code>Name: instruction_set\nDefault: 'x86-64'\nOptions: 'x86-64'\n</code></pre> <p>The instruction set under test. Currently, only x86-64 is supported.</p> <pre><code>Name: instruction_categories\nDefault: ['BASE-BINARY', 'BASE-BITBYTE', 'BASE-COND_BR']\nOptions: 'BASE-BINARY' | 'BASE-BITBYTE' | 'BASE-CMOV' | 'BASE-COND_BR' | 'BASE-CONVERT' | 'BASE-DATAXFER' | 'BASE-FLAGOP' | 'BASE-LOGICAL' | 'BASE-MISC' | 'BASE-NOP' | 'BASE-POP' | 'BASE-PUSH' | 'BASE-SEMAPHORE' | 'BASE-SETCC' | 'BASE-STRINGOP' | 'BASE-WIDENOP' | 'BASE-INTERRUPT' | 'BASE-SYSTEM' | 'LONGMODE-CONVERT' | 'LONGMODE-DATAXFER' | 'LONGMODE-SEMAPHORE' | 'LONGMODE-SYSCALL' | 'LONGMODE-SYSRET' | 'SSE-SSE' | 'SSE-DATAXFER' | 'SSE-MISC' | 'SSE-LOGICAL_FP' | 'SSE2-SSE' | 'SSE2-DATAXFER' | 'SSE2-MISC' | 'SSE2-LOGICAL_FP' | 'SSE2-LOGICAL' | 'SSE3-SSE' | 'SSE3-DATAXFER' | 'SSE4-LOGICAL' | 'SSE4a-BITBYTE' | 'SSE4a-DATAXFER' | 'CLFLUSHOPT-CLFLUSHOPT' | 'CLFSH-MISC' | 'MPX-MPX' | 'SMX-SYSTEM' | 'VTX-VTX' | 'XSAVE-XSAVE'\n</code></pre> <p>Select a list of instruction categories to be used when generating programs. This list effectively filters out instructions from the ISA descriptor file (e.g., <code>base.json</code>) passed via the command line (<code>-s</code>).</p> <pre><code>Name: instruction_blocklist\nDefault: ['enterw', 'enter', 'leavew', 'leave', 'int', 'encls', 'vmxon', 'stgi', 'skinit', 'ldmxcsr', 'stmxcsr', 'lfence', 'mfence', 'sfence', 'clflush', 'clflushopt', 'divps', 'divss', 'divpd', 'divsd', 'mulss', 'mulps', 'mulpd', 'mulsd', 'rsqrtps', 'rsqrtss', 'sqrtps', 'sqrtss', 'sqrtpd', 'sqrtsd', 'addps', 'addss', 'addpd', 'addsd', 'subps', 'subss', 'subpd', 'subsd', 'addsubpd', 'addsubps', 'haddpd', 'haddps', 'hsubpd', 'hsubps', 'sti', 'cli', 'xlat', 'xlatb', 'cmpxchg8b', 'lock cmpxchg8b', 'cmpxchg16b', 'lock cmpxchg16b', 'cpuid', 'cmpps', 'cmpss', 'cmppd', 'cmpsd', 'movq2dq', 'movdq2q', 'rcpps', 'rcpss', 'maskmovdqu']\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions that will NOT be used for generating programs. This list filters out instructions from <code>instruction_categories</code>, but not from <code>instruction_allowlist</code>.</p> <p>The resulting instruction pool is:      (instructions from instruction_categories - instruction_blocklist) + instruction_allowlist</p> <p>The instructions that are blocked by default are known to cause issues in the model or executor, and hence should generally be avoided when fuzzing.</p> <pre><code>Name: instruction_blocklist_append\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions that will be appended to the default instruction blocklist. This option is identical to <code>instruction_blocklist</code>, but the list is added to the previous blocklist instead of replacing it. This is useful when you want to block some instructions in addition to the default blocklist.</p> <pre><code>Name: instruction_allowlist\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions to use for generating programs. This list has priority over <code>instruction_categories</code> and over <code>instruction_blocklist</code>, thus adding instructions on top of the categories.</p> <p>The resulting instruction pool is:      (instructions from instruction_categories - instruction_blocklist) + instruction_allowlist</p> <pre><code>Name: program_generator_seed\nDefault: 0\n</code></pre> <p>Seed of the program generator. If set to zero, a random seed will be used for each run.</p> <pre><code>Name: program_size\nDefault: 24\n</code></pre> <p>Number of instructions per program. The actual size might be larger because of the instrumentation.</p> <pre><code>Name: avg_mem_accesses\nDefault: 12\n</code></pre> <p>Average number of memory accesses in generated programs. The actual number will be random, but the average over all programs will be close to this value.</p> <pre><code>Name: min_bb_per_function\nDefault: 1\n</code></pre> <p>Minimal number of basic blocks per function in generated programs.</p> <pre><code>Name: max_bb_per_function\nDefault: 2\n</code></pre> <p>Maximal number of basic blocks per function in generated programs.</p> <pre><code>Name: min_successors_per_bb\nDefault: 1\n</code></pre> <p>Minimal number of successors for each basic block in generated programs.</p> <p>Note 1: this config option is a hint; it could be ignored if the instruction set does not have the necessary instructions to satisfy it, or if a certain number of successor is required for correctness</p> <p>Note 2: If min_successors_per_bb &gt; max_successors_per_bb, the value is overwritten with max_successors_per_bb</p> <pre><code>Name: max_successors_per_bb\nDefault: 1\n</code></pre> <p>Maximal number of successors for each basic block in generated programs.</p> <p>Note: this config option is a hint; it could be ignored if the instruction set does not have the necessary instructions to satisfy it, or if a certain number of successor is required for correctness</p> <pre><code>Name: register_allowlist\nDefault: []\nOptions: (any register names)\n</code></pre> <p>A list of registers that CAN be used for generating programs.</p> <p>This list has higher priority than <code>register_blocklist</code>. The resulting list is: (all registers - <code>register_blocklist</code>) + <code>register_allowlist</code>.</p> <pre><code>Name: register_blocklist\nDefault: (all but RAX, RBX, RCX, RDX, RDI, RSI, XMM0-XMM7)\nOptions: (any register names)\n</code></pre> <p>A list of registers that will NOT be used for generating programs.</p> <p>This list has lower priority than <code>register_allowlist</code>. The resulting list is: (all registers - <code>register_blocklist</code>) + <code>register_allowlist</code>.</p> <p>The default blocked registers are used by the executor internally, and thus should be avoided.</p> <pre><code>Name: generator_faults_allowlist\nDefault: []\nOptions: 'div-by-zero' | 'div-overflow' | 'opcode-undefined' | 'bounds-range-exceeded' | 'breakpoint' | 'debug-register' | 'non-canonical-access' | 'user-to-kernel-access'\n</code></pre> <p>By default, the generator will produce programs that never trigger exceptions. This option modifies this behavior by permitting the generator to produce 'unsafe' instruction sequences that could potentially trigger an exception. The model and executor will also be configured to handle these exceptions gracefully.</p> <p>The available options are:</p> <ul> <li><code>div-by-zero</code> - generate divisions with unmasked divisor, which can cause a division by zero exception.</li> <li><code>div-overflow</code> - generate divisions with unmasked dividend, which can cause an overflow exception.</li> <li><code>opcode-undefined</code> - generate undefined opcodes, which can cause an undefined opcode exception.</li> <li><code>bounds-range-exceeded</code> - apply MPX instructions for random bounds checks.   This is possible only if MPX is included in the tested instruction set.</li> <li><code>breakpoint</code> - generate breakpoints, which can cause INT3 exceptions.</li> <li><code>debug-register</code> - generate instructions that cause INT1 exceptions.</li> <li><code>non-canonical-access</code> - randomly select a memory access in a generated program and instrument it to access a non-canonical address.</li> <li><code>user-to-kernel-access</code> - randomly select a memory access in a user actor's code and instrument it to access a kernel address; works only if there is at least one user actor.</li> </ul>"},{"location":"config/#actor-configuration","title":"Actor Configuration","text":"<p>All actors are defined in the <code>actors</code> list, with the following syntax:</p> <pre><code>actors:\n  - &lt;actor1_name&gt;\n    - &lt;actor_option&gt;: &lt;value&gt;\n    - &lt;actor_option&gt;:\n       - &lt;sub_option1&gt;: &lt;value1&gt;\n       - &lt;sub_option2&gt;: &lt;value2&gt;\n    ...\n  - &lt;actor2_name&gt;\n      ...\n  ...\n</code></pre> <p>The following options are available for each actor:</p> <pre><code>Actor Option: mode\nDefault: 'host'\nOptions: 'host' | 'guest'\n</code></pre> <p>The execution mode of the actor. The available options are:</p> <ul> <li><code>host</code> - the actor runs in the normal, non-virtualized mode.</li> <li><code>guest</code> - the actor runs in a VM (one VM per actor).</li> </ul> <pre><code>Actor Option: privilege_level\nDefault: 'kernel'\nOptions: 'user' | 'kernel'\n</code></pre> <p>The privilege level of the actor. The available options are:</p> <ul> <li><code>user</code> - the actor runs in user mode (CPL=3).</li> <li><code>kernel</code> - the actor runs in kernel mode (CPL=0).</li> </ul> <pre><code>Actor Option: data_properties\nDefault: (see below)\nOptions: 'present' | 'writable' | 'user' | 'accessed'\n         | 'dirty' | 'executable' | 'reserved_bit' | 'randomized'\n</code></pre> <p>The properties of the data memory used by the actor. These properties are applied only to the second page (FAULTY_AREA) of the actor's data region.</p> <p>The available options are:</p> <ul> <li><code>present</code> [default: True] - the value of the Present bit in the page table entry.</li> <li><code>writable</code> [default: True] - the value of the Writable bit in the page table entry.</li> <li><code>user</code> [default: False] - the value of the User/Supervisor bit in the page table entry.</li> <li><code>accessed</code> [default: True] - the value of the Accessed bit in the page table entry.</li> <li><code>dirty</code> [default: True] - the value of the Dirty bit in the page table entry.</li> <li><code>executable</code> [default: False] - the value of the Executable bit in the page table entry.</li> <li><code>reserved_bit</code> [default: False] - the value of the Reserved bit in the page table entry.</li> <li><code>randomized</code> [default: False] - if true, the values of the above properties will be randomized for each test case.</li> </ul> <p>Note that the above properties are set in the host page tables for actors with <code>mode: host</code>, and in the guest page tables for actors with <code>mode: guest</code>.</p> <pre><code>Actor Option: data_ept_properties\nDefault: (see below)\nOptions: 'present' | 'writable' | 'executable' | 'accessed' | 'dirty' | 'user'\n        | 'reserved_bit' | 'randomized'\n</code></pre> <p>The properties of the EPT entry used by the actor (on Intel) or the NPT entry (on AMD). The properties are applied only to the second page (FAULTY_AREA) of the actor's data region.</p> <p>This property has no effect on actors with <code>mode: host</code>.</p> <p>The available options are:</p> <ul> <li><code>present</code> [default: True] - the value of the Present bit in the EPT/NPT entry.</li> <li><code>writable</code> [default: True] - the value of the Writable bit in the EPT/NPT entry.</li> <li><code>executable</code> [default: False] - the value of the Executable bit in the EPT/NPT entry.</li> <li><code>accessed</code> [default: True] - the value of the Accessed bit in the EPT/NPT entry.</li> <li><code>dirty</code> [default: True] - the value of the Dirty bit in the EPT/NPT entry.</li> <li><code>user</code> [default: False] - the value of the User/Supervisor bit in the EPT/NPT entry.</li> <li><code>reserved_bit</code> [default: False] - the value of the Reserved bit in the EPT/NPT entry.</li> <li><code>randomized</code> [default: False] - if true, the values of the above properties will be randomized for each test case.</li> </ul> <pre><code>Actor Option: observer\nDefault: False\n</code></pre> <p>If enabled, the actor will be an observer actor, hence modelling an attacker. This option is only used if the contract is <code>noninterference</code>, and it is ignored otherwise.</p> <pre><code>Actor Option: instruction_blocklist\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>Actor-specific instruction blocklist. This list has priority over the global <code>instruction_blocklist</code>.</p> <pre><code>Actor Option: fault_blocklist\nDefault: []\nOptions: (any fault names)\n</code></pre> <p>Actor-specific fault blocklist. This list has priority over the global <code>generator_faults_allowlist</code>.</p>"},{"location":"config/#input-generator-configuration","title":"Input Generator Configuration","text":"<pre><code>Name: input_generator\nDefault: 'random'\nOptions: 'random'\n</code></pre> <p>The input generator type. Currently, only random input generation is supported.</p> <pre><code>Name: input_gen_seed\nDefault: 10\n</code></pre> <p>Seed of the input generator. If set to zero, a random seed will be used for each run.</p> <pre><code>Name: input_gen_entropy_bits\nDefault: 16\n</code></pre> <p>Entropy of the random values created by the input generator. The maximum value is 31.</p> <pre><code>Name: inputs_per_class\nDefault: 2\n</code></pre> <p>Number of inputs generated for each input class by the Contract-Driven Input Generator. For the explanation of the input classes and the generation algorithm, see (this paper)[https://arxiv.org/pdf/2301.07642], Section 4.D. Contract-driven Input Generator.</p>"},{"location":"config/#contract-configuration","title":"Contract Configuration","text":"<pre><code>Name: contract_execution_clause\nDefault: ['seq']\nOptions: 'seq' | 'no_speculation' | 'seq-assist' | 'cond' | 'conditional_br_misprediction' | 'bpas' | 'nullinj-fault' | 'nullinj-assist' | 'delayed-exception-handling' | 'div-zero' | 'div-overflow' | 'meltdown' | 'fault-skip' | 'noncanonical' | 'vspec-ops-div' | 'vspec-ops-memory-faults' | 'vspec-ops-memory-assists' | 'vspec-ops-gp' | 'vspec-all-div' | 'vspec-all-memory-faults' | 'vspec-all-memory-assists' | 'noninterference'\n</code></pre> <p>The execution clause of the contract.</p> <p>For single-actor experiments, the following options are available:</p> <ul> <li><code>seq</code> - sequential execution.</li> <li><code>no_speculation</code> - sequential execution. Synonym for <code>seq</code>.</li> <li><code>seq-assist</code> - sequential execution with possible microcode assists.</li> <li><code>cond</code> - permitted misprediction of conditional branches.</li> <li><code>conditional_br_misprediction</code> - permitted misprediction of conditional branches. Synonym for <code>cond</code>.</li> <li><code>bpas</code> - permitted speculative store bypass</li> <li><code>nullinj-fault</code> - page faults are permitted to speculatively return zero.</li> <li><code>nullinj-assist</code> - microcode assists are permitted to speculatively return zero.</li> <li><code>delayed-exception-handling</code> - upon an exception or a fault, data-independent instructions that follow the exception are allowed to execute speculatively.</li> <li><code>meltdown</code> - permission-based page faults are permitted to speculatively return the value in the memory.</li> <li><code>fault-skip</code> - upon a fault, the faulting instruction is speculatively skipped.</li> <li><code>noncanonical</code> - permitted speculative non-canonical memory accesses.</li> <li><code>vspec*</code> - experimental contracts for value speculation. See (this paper)[https://www.usenix.org/system/files/usenixsecurity23-hofmann.pdf] for details.</li> <li><code>div-zero</code> - experimental contract; do not use.</li> <li><code>div-overflow</code> - experimental contract; do not use.</li> </ul> <p>In multi-actor context, only one option is available: * <code>noninterference</code> - the observer actor is permitted to leak its own data and the addresses of memory accesses of the other actors. No other data is allowed to be leak.</p> <pre><code>Name: contract_observation_clause\nDefault: 'ct'\nOptions: 'none' | 'l1d' | 'memory' | 'pc' | 'ct' | 'loads+stores+pc' | 'ct-nonspecstore' | 'ctr' | 'arch' | 'tct' | 'tcto'\n</code></pre> <p>The observation clause of the contract. In most cases, the default value should be used.</p> <p>The available options are:</p> <ul> <li><code>none</code> - the model observes nothing. Useful for testing the fuzzer.</li> <li><code>l1d</code> - the model observes the addresses of data accesses, adjusted to imitate the L1D cache trace.   Has very few real applications, and should be generally avoided.</li> <li><code>memory</code> - the model observes the addresses of data accesses.</li> <li><code>ct</code> (constant time tracer) - the model observes the addresses of data accesses and the control flow.</li> <li><code>loads+stores+pc</code> - the model observes the addresses of data accesses and the control flow. Synonym for <code>ct</code>.</li> <li><code>ct-nonspecstore</code> - the model observes the addresses of data accesses and the control flow, but does not observe the addresses of stores during speculation.</li> <li><code>ctr</code> - the model observes the addresses of data accesses and the control flow, as well as the values of the general-purpose registers.</li> <li><code>arch</code> - the model observes the addresses of data accesses and the control flow, as well as the values loaded from memory.   This clause imitates the security guarantees provided by secure speculation mechanisms like STT.</li> <li><code>tct</code> (truncated constant time tracer) - the model observes address of the memory access and of the program counter at cache line granularity.</li> <li><code>tcto</code> (truncated constant time tracer with overflows) - the model address of the memory access and of the program counter at cache line granularity + observe cache line overflows.</li> </ul> <pre><code>Name: model_min_nesting\nDefault: 1\n</code></pre> <p>Minimum number of nested mispredictions in the model. This value is used to generate the contract traces on the fast path of the fuzzer.</p> <pre><code>Name: model_max_nesting\nDefault: 30\n</code></pre> <p>Maximum number of nested mispredictions in the model. This value is used to generate the contract traces on the slow path of the fuzzer, i.e., when a potential violation is detected and the fuzzer tries to check if it is a true positive.</p> <pre><code>Name: model_max_spec_window\nDefault: 250\n</code></pre> <p>Size of the speculation window in the model.</p>"},{"location":"config/#executor-configuration","title":"Executor Configuration","text":"<pre><code>Name: executor\nDefault: (auto-detected)\nOptions: 'x86-64-intel' | 'x86-64-amd'\n</code></pre> <p>The executor type. The default value is auto-detected based on the <code>cpuinfo</code>. Should be changed only if the auto-detection fails.</p> <pre><code>Name: executor_mode\nDefault: 'P+P'\nOptions: 'P+P' | 'F+R' | 'E+R' | 'PP+P' | 'TSC'\n</code></pre> <p>Hardware trace collection mode. The available options are:</p> <ul> <li><code>P+P</code> - prime and probe.</li> <li><code>F+R</code> - flush and reload.</li> <li><code>E+R</code> - evict and reload.</li> <li><code>PP+P</code> - partial prime and probe (i.e., leave a subset of cache lines unprimed).</li> <li><code>TSC</code> - use RDTSCP instruction to measure the time of the execution.</li> </ul> <pre><code>Name: executor_warmups\nDefault: 5\n</code></pre> <p>Number of warmup rounds executed before starting to collect hardware traces.</p> <pre><code>Name: executor_sample_sizes\nDefault: [10, 50, 100, 500]\n</code></pre> <p>A list of sample sizes to be used during the measurements. The executor will first collect the hardware traces with the first sample size in the list, and if a violation is detected, it will try to reproduce it with all the following sample sizes.</p> <pre><code>Name: executor_filtering_repetitions\nDefault: 10\n</code></pre> <p>The sample size to be used by the speculation and observation filters.</p> <pre><code>Name: executor_taskset\nDefault: 0\n</code></pre> <p>The ID of the CPU core on which the executor is running test cases.</p> <pre><code>Name: enable_pre_run_flush\nDefault: True\n</code></pre> <p>If enabled, the executor will do its best to flush the microarchitectural state before running test cases.</p> <pre><code>Name: x86_executor_enable_ssbp_patch\nDefault: True\n</code></pre> <p>Enable a microcode patch against Speculative Store Bypass, if available.</p> <pre><code>Name: x86_executor_enable_prefetcher\nDefault: False\n</code></pre> <p>Enable all prefetchers, if the software controls are available.</p> <pre><code>Name: x86_disable_div64\nDefault: True\n</code></pre> <p>Do not generate 64-bit division instructions. Useful for avoiding certain types of speculation that are specific to 64-bit division.</p> <pre><code>Name: x86_enable_hpa_gpa_collisions\nDefault: False\n</code></pre> <p>When a test case contains at least one guest actor, allocate its memory in the guest physical address space to match the corresponding host physical addresses of the main actor. Useful for testing Foreshadow-like leaks.</p> <pre><code>Name: x86_generator_align_locks\nDefault: True\n</code></pre> <p>When generating memory accesses with locks, apply instrumentation to align the locks to 8 bytes. Useful for avoiding faults on unaligned accesses.</p>"},{"location":"config/#analyser-configuration","title":"Analyser Configuration","text":"<pre><code>Name: analyser\nDefault: 'chi2'\nOptions: 'chi2' | 'mwu' | 'sets' | 'bitmaps'\n</code></pre> <p>The type of the analyser that is used to compare the hardware traces and contract traces.</p> <p>The available options are:</p> <ul> <li><code>sets</code> - combine the hardware traces for each input into a set. A violation is reported if two inputs in the same contract-equivalence class have different sets of hardware traces.</li> <li><code>bitmaps</code> - combine the hardware traces for each input into a bitmap. A violation is reported if two inputs in the same contract-equivalence class have different bitmaps of hardware traces.</li> <li><code>chi2</code> - use the chi-squared homogeneity test to compare the hardware traces of inputs in the same contract-equivalence class. This test effectively checks if the hardware traces from two different inputs come from the same distribution. A violation is reported if the test fails.</li> <li><code>mwu</code> - [experimental; both false positives and negatives are possible]   use the Mann-Whitney U test to compare the hardware traces of inputs in the same contract-equivalence class. This test effectively checks if the hardware traces from two different inputs come from the same distribution. A violation is reported if the test fails.</li> </ul> <pre><code>Name: analyser_subsets_is_violation\nDefault: False\n</code></pre> <p>This option is relevant only for the <code>sets</code> and <code>bitmaps</code> analysers.</p> <p>If enabled, the analyser will not label hardware traces as mismatching if they form a subset relation.</p> <pre><code>Name: analyser_outliers_threshold\nDefault: 0.1\n</code></pre> <p>This option is relevant only for the <code>sets</code> and <code>bitmaps</code> analysers.</p> <p>The analyser will ignore the hardware traces that appear in less than this percentage of the repetitions.</p> <pre><code>Name: analyser_stat_threshold\nDefault: 0.5\n</code></pre> <p>This option is relevant only for the <code>chi2</code> and <code>mwu</code> analysers.</p> <p>The threshold for the statistical tests. If a pair of hardware traces has the (normalized) statistics below the threshold, then the traces are considered equivalent.</p> <p>For the chi2 test, the threshold is applied to the <code>statistics / (len(htrace1) + len(htrace2))</code>.</p> <p>For the mwu test, the threshold is applied to the p-value.</p>"},{"location":"config/#miscellaneous-configuration","title":"Miscellaneous Configuration","text":"<pre><code>Name: coverage_type\nDefault: 'none'\nOptions: 'none' | 'model_instructions'\n</code></pre> <p>The type of coverage tracking. The available options are:</p> <ul> <li><code>none</code> - disable coverage tracking.</li> <li><code>model_instructions</code> - track how many times the model executed each instruction.</li> </ul> <pre><code>Name: minimizer_retries\nDefault: 1\n</code></pre> <p>Number of minimization retries. When the minimizer performs a check to reduce a test case, each check is attempted this number of times and it succeeds if at least one check is successful.</p>"},{"location":"development/","title":"Development","text":"<p>This page contains various bits of information helpful when developing and expanding Revizor.</p>"},{"location":"development/#tests","title":"Tests","text":"<p>To run automated tests you will need to install a few more dependencies:</p> <ul> <li>Bash Automated Testing System</li> <li>mypy</li> <li>flake8</li> </ul> <p>With the dependencies installed, you can run the tests with:</p> <pre><code>./tests/runtests.sh\n</code></pre> <p>Note that some of the acceptance tests are microarchitecture-dependent. These tests are labeled \"Detection\" (e.g., \"Detection [spectre-type] Spectre V1; load variant\"), and they may fail if the CPU under test does not have a given vulnerability. Generally, if a few of these tests fail, it is not a problem, but if all of them (or a significant portion) fail, it indicates an issue with the fuzzer.</p>"},{"location":"development/#code-style","title":"Code Style","text":"<p>Please follow these coding standards when writing code for inclusion in Revizor.</p> <p>Python:</p> <ul> <li>Unless otherwise specified, follow PEP 8. But remember that PEP 8 is only a guide, so respect the style of the surrounding code as a primary goal.</li> <li>An exception to PEP 8 is our rules on line lengths. Don\u2019t limit lines of code to 79 characters if it means the code looks significantly uglier or is harder to read. We allow up to 100 characters.</li> <li>All files should be formatted using the <code>flake8</code> auto-formatter. Use all default settings except for the line width (<code>--max-line-length 100</code>)</li> <li>The Python and C files use 4 spaces for indentation, and YAML uses 2 spaces.</li> <li>The project repository includes an .editorconfig file. We recommend using a text editor with EditorConfig support to avoid indentation and whitespace issues.</li> <li>Use underscores, not camelCase, for variable, function and method names (i.e. poll.get_unique_voters(), not poll.getUniqueVoters()).</li> <li>Use InitialCaps for class names (or for factory functions that return classes).</li> <li>In docstrings, follow PEP 257.</li> </ul> <p>C:</p> <ul> <li>All files should be formatted using the <code>clang-format</code>. The settings are included into the <code>.clang-format</code> files in the directories with C files. Just run the formatter with: <code>clang-format -i *.c</code></li> </ul> <p>Misc:</p> <ul> <li>Remove import statements that are no longer used when you change code. flake8 will identify these imports for you. If an unused import needs to remain for backwards-compatibility, mark the end of with # NOQA to silence the flake8 warning.</li> <li>Systematically remove all trailing whitespaces from your code as those add unnecessary bytes, add visual clutter to the patches and can also occasionally cause unnecessary merge conflicts. Some IDE\u2019s can be configured to automatically remove them and most VCS tools can be set to highlight them in diff outputs.</li> </ul>"},{"location":"development/#git-messages","title":"Git Messages","text":"<p>We practice the following conventions for commit messages:</p> <pre><code>&lt;scope&gt;: [&lt;type&gt;] &lt;subject&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;scope&gt;</code>: The scope of the change.</li> <li><code>&lt;type&gt;</code>: The type of the change.</li> <li><code>&lt;subject&gt;</code>: A short description of the change.</li> </ul>"},{"location":"development/#scopes","title":"Scopes","text":"<p>The following scopes are typical:</p> Scope Description <code>all</code> Changes that affect the entire project (e.g., major refactoring) <code>root</code> Root directory changes (e.g., readme, git, author list) <code>fuzz</code> Changes to the core fuzzer algorithm. <code>cli</code> Changes to the command-line interface. <code>exec</code> Changes to the executor. <code>model</code> Changes to the model. <code>analyser</code> Changes to the analyser. <code>mini</code> Changes to the postprocessor (i.e., minimizer). <code>gen</code> Changes to the program generator <code>input_gen</code> Changes to the input generator <code>tests</code> Changes to the tests <code>isa</code> Changes to the ISA loader or to <code>get_spec</code> files <p>If a commit covers several scopes, use the most relevant one.</p> <p>If a commit targets a specific architecture (e.g., x86), add the architecture to the scope (e.g., <code>fuzz/x86</code>).</p>"},{"location":"development/#types","title":"Types","text":"<p>Use one of the following types:</p> Type Description <code>feat</code> A new feature. <code>fix</code> A bug fix. <code>docs</code> Documentation changes. <code>chore</code> Changes to the build process or auxiliary tools. <code>ft</code> Fault tolerance changes (e.g., adding error handling or recovery mechanisms). <code>refact</code> Refactoring of the codebase. This includes code style change. <code>perf</code> Performance improvements. <code>revert</code> Reverts a previous commit. <p>If possible, try to use only these types. If you need to use a different type, please discuss it with a maintainer.</p>"},{"location":"development/#git-branches","title":"Git Branches","text":"<p>We practice the git workflow, with a few modifications.</p> <p></p> <p>We use the following branches for graduation:</p> <ul> <li><code>main</code>: The latest release. This branch should always be stable, and it is the last branch to receive changes.</li> <li><code>main-fixes</code>: Commits that go in the next maintenance release. This branch is created from the last release branch.</li> <li><code>pre-release</code>: Stable commits that go in the next release.</li> <li><code>dev</code>: The development branch. This branch is the first to receive changes.</li> </ul> <p>Commits should be merged upwards:</p> <ul> <li><code>dev</code> -&gt; <code>pre-release</code> -&gt; <code>main</code></li> <li>In case of hot fixes, <code>main-fixes</code> -&gt; <code>main</code> AND <code>main-fixes</code> -&gt; <code>pre-release</code></li> </ul> <p>For working on unstable code (e.g., progress on features or bug fixes), use either forks or feature branches. Use forks if you are the only one working on the feature, and use a pull request to merge the changes back into the main repository. Use a feature branch if multiple people are working on the feature, in which case name the branch <code>feature-&lt;name&gt;</code> or <code>bugfix-&lt;name&gt;</code>, and make sure to branch from the <code>dev</code> branch.</p> <p>The only exception is the <code>gh-pages</code> branch, which is used for the project's website. This branch is used by automated tools and should never be used for development.</p>"},{"location":"fuzzing-guide/","title":"Guide on running a testing campaign and analyzing a violation","text":"<p>In this guide, we will walk through the process of testing a CPU for unexpected speculative leaks with Revizor. We will also show how to analyze a contract violation discovered by this campaign.</p> <p>This example is based on a real testing campaign that led to a discovery of Zero Division Injection, described in Hide&amp;Seek with Spectres.</p>"},{"location":"fuzzing-guide/#preparation","title":"Preparation","text":"<p>We perform a fuzzing campaign in which we test arithmetic operations on an x86-64 CPUs. As the source of side channel information (i.e., the source of hardware traces), we chose L1D cache. In other words, this campaign will test the information that arithmetic operations can expose through an L1D cache.</p> <p>For the sake of this example, let's assume that we do not know of any speculative vulnerabilities that could be triggered by these instructions. Accordingly, our expected contract is going to be <code>ct-seq</code>, a contract that describes cache leakage for non-speculating instructions.</p> <p>We encode this setup in the following configuration file: <pre><code>instruction_set: x86-64 # target instruction set\n\n# define a pool of tested instructions\ninstruction_categories:\n  - BASE-BINARY  # BINARY is a keyword for arithmetic operations\n\n# by default, Revizor will not generate 64-bit divisions\n# we disable this behavior\nx86_disable_div64: false\n\n# since we are relying on a cache side channel to collect hardware traces,\n# we expect to observe the addresses of loads and stores in the traces,\n# as well as the changes in the PC\ncontract_observation_clause: loads+stores+pc\n\n# we expect to see not speculation in this fuzzing campaign\ncontract_execution_clause:\n  - no_speculation\n\n# use Prime+Probe to collect hardware traces\nexecutor_mode: P+P\n\n# enable some optimization features to make fuzzing faster\nenable_speculation_filter: true\nenable_observation_filter: true\n\n# by default Revizor adds conditional branches to all test cases\n# since we are not interested in branches in this experiment,\n# disable them\nmin_bb_per_function: 1\nmax_bb_per_function: 1\n</code></pre></p> <p>We save the configuration into a file (<code>config.yaml</code>) and start a fuzzing campaign.</p>"},{"location":"fuzzing-guide/#fuzzing-campaign","title":"Fuzzing Campaign","text":"<p>We start Revizor with the following command:</p> <p><pre><code>rvzr fuzz -s base.json -c config.yaml -n 100000 -i 100 -w ./results\n</code></pre> (use <code>./revizor.py</code> instead of <code>rvzr</code> if you want to run Revizor directly from the source directory)</p> <p>Here * <code>-s base.json</code> - tells Revizor where to find a description of the tested instructions * <code>-c config.yaml</code> - points Revizor to the configuration file described above * <code>-n 100000</code> - number of randomly-generated programs to be tested. Note that 100k programs will be tested only if none of them surfaces a contract violation; otherwise, Revizor will stop as soon as it detects a violation * <code>-i 100</code> - number of inputs per test case * <code>-w ./results</code> - directory where the detected violations will be stored.</p> <p>After about an hour of fuzzing, Revizor finds a violation, saves the corresponding program into <code>./results/violation&lt;timestamp&gt;.asm</code>, and terminates.</p> <p>The violation on its own is already a sign that something unexpected is going on: Since we were testing against a contract that does not permit speculation (<code>no_speculation</code> in <code>config.yaml</code>), this violation indicates that Revizor found a program that speculatively leaks information. This is a new finding because there has been previously no reports of speculative leaks caused by arithmetic instructions.</p>"},{"location":"fuzzing-guide/#analyzing-the-violation","title":"Analyzing The Violation","text":"<p>The next step is to find out what caused this violation. The program that surfaced a violation looks like this:</p> <p><pre><code>.intel_syntax noprefix\nMFENCE # instrumentation\n.test_case_enter:\n.function_main:\n.bb_main.entry:\nJMP .bb_main.0\n.bb_main.0:\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB word ptr [R14 + RAX], DX\nSUB RAX, -63\nNEG BX\nINC DL\nAND RAX, 0b1111111111111 # instrumentation\nLOCK ADC dword ptr [R14 + RAX], -12\nAND RBX, 0b1111111111111 # instrumentation\nSUB CL, byte ptr [R14 + RBX]\nAND RDI, 0b1111111111111 # instrumentation\nCMP word ptr [R14 + RDI], -24\nCMP RAX, 382711631\nAND RBX, 0b1111111111111 # instrumentation\nLOCK DEC byte ptr [R14 + RBX]\nIMUL CL\nSBB AL, -106\nCMP RAX, 383545172\nAND RBX, 0b1111111111111 # instrumentation\nSBB DL, byte ptr [R14 + RBX]\nAND RBX, 0b1111111111111 # instrumentation\nADD word ptr [R14 + RBX], -102\nAND RBX, 0b1111111111111 # instrumentation\nLOCK INC dword ptr [R14 + RBX]\nAND RSI, 0b1111111111111 # instrumentation\nADD EDX, dword ptr [R14 + RSI]\nSUB AL, 66\nOR RBX, 1 # instrumentation\nAND RDX, RBX # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RBX\nIMUL ESI, EBX\nAND RDX, 0b1111111111111 # instrumentation\nMUL dword ptr [R14 + RDX]\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB byte ptr [R14 + RAX], CL\nADC DIL, 32\nSBB BL, DL\nOR RSI, 1 # instrumentation\nAND RDX, RSI # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RSI\n.bb_main.exit:\n.test_case_exit:\nMFENCE # instrumentation\n</code></pre> (Note: if you're following along this guide, your detected violation is going to contain a completely different assembly. But don't worry about it, the analysis process is going to be the same.)</p> <p>This is a randomly-generated sequence of assembly instructions, so if we try to find out the source of the unexpected leakage in it, we will have to put a very considerable effort. Fortunately, we don't have to do it, as there are several techniques that can significantly simplify the analysis.</p>"},{"location":"fuzzing-guide/#1-remove-irrelevant-instructions-from-the-program","title":"1. Remove irrelevant instructions from the program","text":"<pre><code>rvzr minimize -s base.json -c config.yaml -i /results/violation&lt;timestamp&gt;.asm -o min.asm -n 100\n</code></pre> <p>It simplifies the program and stores the result into <code>min.asm</code>. The result is:</p> <pre><code>.intel_syntax noprefix\nMFENCE # instrumentation\n.test_case_enter:\n.function_main:\n.bb_main.entry:\n.bb_main.0:\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB word ptr [R14 + RAX], DX\nINC DL\nAND RBX, 0b1111111111111 # instrumentation\nLOCK DEC byte ptr [R14 + RBX]\nAND RBX, 0b1111111111111 # instrumentation\nSBB DL, byte ptr [R14 + RBX]\nOR RBX, 1 # instrumentation\nAND RDX, RBX # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RBX\nAND RDX, 0b1111111111111 # instrumentation\nMUL dword ptr [R14 + RDX]\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB byte ptr [R14 + RAX], CL\n.bb_main.exit:\n.test_case_exit:\nMFENCE # instrumentation\n</code></pre> <p>We can further simplify the test case manually, by removing the unused labels (e.g., <code>bb_main.0</code>). Note that <code>.test_case_enter:</code> and <code>.test_case_exit:</code> have to remain because Revizor's automation scripts use it to define the start and the end of the test case.</p> <p>As a result, we get a minimal version of the program:</p> <pre><code>.intel_syntax noprefix\nMFENCE # instrumentation\n.test_case_enter:\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB word ptr [R14 + RAX], DX\nINC DL\nAND RBX, 0b1111111111111 # instrumentation\nLOCK DEC byte ptr [R14 + RBX]\nAND RBX, 0b1111111111111 # instrumentation\nSBB DL, byte ptr [R14 + RBX]\nOR RBX, 1 # instrumentation\nAND RDX, RBX # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RBX\nAND RDX, 0b1111111111111 # instrumentation\nMUL dword ptr [R14 + RDX]\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB byte ptr [R14 + RAX], CL\n.test_case_exit:\nMFENCE # instrumentation\n</code></pre> <p>To make sure that we didn't make a mistake while modifying the program, we can verify the result by reproducing the violation:</p> <pre><code>rvzr fuzz -s base.json -c config.yaml -t min.asm -i 100\n</code></pre>"},{"location":"fuzzing-guide/#2-add-speculation-fences-to-narrow-down-the-part-of-the-program-that-causes-leakage","title":"2. Add speculation fences to narrow down the part of the program that causes leakage","text":"<pre><code>rvzr minimize -s base.json -c config.yaml -i min.asm -o min.asm -n 100 --add-fences\n</code></pre> <p>This command iteratively attempts to add an <code>LFENCE</code> before every instruction in the program while checking if the violation persists. The result is:</p> <pre><code>.intel_syntax noprefix\nMFENCE # instrumentation\n.test_case_enter:\nLFENCE\nAND RAX, 0b1111111111111 # instrumentation\nLFENCE\nLOCK SBB word ptr [R14 + RAX], DX\nAND RBX, 0b1111111111111 # instrumentation\nLOCK DEC byte ptr [R14 + RBX]\nAND RBX, 0b1111111111111 # instrumentation\nSBB DL, byte ptr [R14 + RBX]\nOR RBX, 1 # instrumentation\nAND RDX, RBX # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RBX\nAND RDX, 0b1111111111111 # instrumentation\nMUL dword ptr [R14 + RDX]\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB byte ptr [R14 + RAX], CL\n.test_case_exit:\nMFENCE # instrumentation\n</code></pre> <p>Only two fences were inserted, after <code>.test_case_enter:</code> and after <code>AND RAX, 0b1111111111111</code>. It means that all the remaining instructions are somehow involved in the speculative leak (although we cannot yet tell how exactly).</p>"},{"location":"fuzzing-guide/#3-use-the-statistics-reported-by-revizor-to-find-the-specific-instruction-that-triggers-speculation","title":"3. Use the statistics reported by Revizor to find the specific instruction that triggers speculation","text":"<p>At this point, we start making manual changes to the program. We go through the program, try removing instructions one at a time, execute the modified program on Revizor, and check the statistic from the speculation filter.</p> <p>For example, let's say we start from the bottom. We first try to remove the last line (<code>LOCK SBB byte ptr [R14 + RAX], CL</code>), and execute the program on Revizor: <pre><code>rvzr fuzz -s base.json -c config.yaml -t min.asm -i 100\n\nINFO: [fuzzer] Starting at 17:16:52\n0     ( 0%)| Stats:\n================================ Statistics ===================================\nTest Cases: 1\nInputs per test case: 200.0\nFlaky violations: 0\nRequired priming: 0\nViolations: 0\nEffectiveness:\n  Effectiveness: 1.0\n  Total Cls: 20.0\n  Effective Cls: 20.0\nFilters:\n  Speculation Filter: 1\n  Observation Filter: 1\n</code></pre></p> <p>Even though Revizor did not report a violation, the line <code>Speculation Filter: 1</code> tells us that Revizor detected some speculation. Accordingly, we deduce that the instruction we removed (<code>LOCK SBB</code>) is not the source of speculation.</p> <p>We continue the process with one instruction at a time, and we see the same result with the next three instructions (<code>AND</code>, <code>MUL</code>, and <code>AND</code>). However, when we try removing <code>DIV</code> from the program, we Revizor produces the following output:</p> <pre><code>================================ Statistics ===================================\nTest Cases: 1\nInputs per test case: 200.0\nFlaky violations: 0\nRequired priming: 0\nViolations: 0\nEffectiveness:\n  Effectiveness: 0.0\n  Total Cls: 0.0\n  Effective Cls: 0.0\nFilters:\n  Speculation Filter: 0\n  Observation Filter: 0\n</code></pre> <p>The line <code>Speculation Filter: 0</code> tells us that Revizor did not detect any speculation while executing the version of the program without <code>DIV</code>. It means that this division was the source of speculative leakage.</p>"},{"location":"fuzzing-guide/#4-to-be-continued","title":"4. TO BE CONTINUED...","text":""},{"location":"how-revizor-works/","title":"How Revizor works","text":""},{"location":"how-revizor-works/#revizor-in-a-nutshell","title":"Revizor in a nutshell","text":"<p>Revizor is a tool for detecting unexpected microarchitectural leakage in CPUs. Microarchitectural leakage means the information that an attacker could learn by launching a microarchitectural side-channel attack (e.g., Spectre or Meltdown). The expected microarchitectural leakage is the leakage that we already know about (i.e., known microarchitectural vulnerabilities). We describe the expected leakage in a form of a Speculation Contract (see below). Accordingly, the unexpected leakage is any leakage not described pby a contract - we call it a contract violation. Revizor's task is to find such violations.</p>"},{"location":"how-revizor-works/#speculation-contracts","title":"Speculation Contracts","text":"<p>Below is a brief intro to Contracts. You can find a more detailed description in the original paper and in the Background section of the Revizor paper.</p>"},{"location":"how-revizor-works/#microarchitectural-leakage-and-hardware-traces","title":"Microarchitectural Leakage and Hardware Traces","text":"<p>Consider two programs, an attacker and a victim. The attacker launches a microarchitectural side-channel attack (e.g., a cache side channel) to spy on the victim and learn some of its data. A hardware trace is a sequence of all the observations made through this side-channel after each instruction during the victim's execution. In other words, hardware trace is the result for a side-channel attack.</p> <p>We abstractly represent the hardware trace as the output of a function</p> <p>\ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 = \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc36\ud835\udc61\ud835\udc65)</p> <p>that takes three input parameters: (1) the victim program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54; (2) the input \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e processed by the victim\u2019s program (i.e., the architectural state including registers and main memory); (3) the microarchitectural context \ud835\udc36\ud835\udc61\ud835\udc65 in which it executes. The information exposed by a hardware trace depends on the assumed side-channel and threat model.</p> <p>Example: If the threat model includes attacks on a data cache, \ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 is composed of the cache set indexes used by \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54\u2019s loads and stores. If it includes attacks on an instruction cache, \ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 contains the addresses of executed instructions.</p> <p>A program leaks information via side-channels when its hardware traces depend on the inputs (\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e): We assume the attacker knows \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54 and can manipulate \ud835\udc36\ud835\udc61\ud835\udc65, hence any difference between the hardware traces implies difference in \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e, which effectively exposes information to the attacker.</p>"},{"location":"how-revizor-works/#whats-a-speculation-contract","title":"What's a Speculation Contract?","text":"<p>A speculation contract specifies the information that can be exposed by a CPU during a program execution under a given threat model. For each instruction in the CPU ISA (or a subset thereof), a contract describes the information exposed by the instruction\u2019s (observation clause) and the externally-observable speculation that the instruction may trigger (execution clause). When a contract covers a subset of ISA, the leakage of unspecified instructions is undefined.</p> <p>Example: consider the contract summarized in the next table:</p> Observation Clause Execution Clause Load Expose Address - Store Expose Address - Cond. Jump - Mispredict Target Other - - <p>We call this contract MEM-COND. Through the observation clauses of loads and stores, the contract prescribes that addresses of all memory access may be exposed (hence MEM). The execution clause of conditional branches describes their misprediction, thus the contract prescribes that branch targets may be mispredicted (hence COND). This way, the contract models a data cache side channel on a CPU with branch prediction.</p> <p>A contract trace \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 contains the sequence of all the observations the contract allows to be exposed after each instruction during a program execution, including the instructions executed speculatively. Conversely, the information that is not exposed via \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 is supposed to be kept secret.</p> <p>We abstractly represent a contract as a function \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61 that maps the program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54 and its input \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e to a contract trace \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52:</p> <p>\ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 = \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e)</p> <p>Example: Consider the following program:</p> <p><pre><code>z = array1[x] # base of array1 is 0x100\nif y &lt; 10:\n    z = array2[y] # base of array2 is 0x200\n</code></pre> It is executed with an input <code>data={x=10,y=20}</code>. The MEM-COND contract trace is <code>ctrace=[0x110,0x220]</code>, representing that the load at line 1 exposes the accessed address during normal execution, and the load at line 3 exposes its address during speculative execution triggered by the branch at line 2.</p> <p>A CPU complies with a contract when its hardware traces (collected on the actual CPU) leak at most as much information as the contract traces. Formally, we require that whenever any two executions of any program have the same contract trace (implying the difference between inputs is not exposed), the respective hardware traces should also match.</p> <p>A CPU complies with a \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61 if, for all programs \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54, all input pairs (\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032), and all initial microarchitectural states \ud835\udc36\ud835\udc61\ud835\udc65:</p> <p>\ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e) = \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032) -&gt; \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc36\ud835\udc61\ud835\udc65) = \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032,\ud835\udc36\ud835\udc61\ud835\udc65)</p> <p>Conversely, a CPU violates a contract if there exists a program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54, a microarchitectural state Ctx, and two inputs \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032 that agree on their contract traces but disagree on the hardware traces. We call the tuple (\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc36\ud835\udc61\ud835\udc65,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032) a contract counterexample. The counterexample witnesses that an adversary can learn more information from hardware traces than what the contract specifies. A counterexample indicates a potential microarchitectural vulnerability that was not accounted for by the contract.</p>"},{"location":"how-revizor-works/#model-based-relational-testing","title":"Model-based Relational Testing","text":"<p>To find contract violations, we use the following approach, which we call Model-based Relational Testing (MRT).</p> <p>The next figure show the main components of MRT:</p> <p></p> <p>Test case and input generation. We sample the search space of programs, inputs and microarchitectural states to find counterexamples. The generated instruction sequences (test cases) are comprised of the ISA subset described by the contract. The test cases and respective inputs to them are generated to achieve high diversity and to increase speculation or leakage potential.</p> <p>Collecting contract traces. We implement an executable Model of the contract to allow automatic collection of contract traces for standard binaries. For this, we modify a functional CPU emulator to implement speculative control flow based on a contract\u2019s execution clause, and to record traces based on its observation clause.</p> <p>Collecting hardware traces. We collect hardware traces by executing the test case on the CPU under test and measuring the observable microarchitectural state changes during the execution according to the threat model. The executor employs several methods to achieve consistent and repeatable measurements.</p> <p>Relational Analysis. Based on the collected contract and hardware traces, we identify contract violations. Namely, we search for pairs of inputs that match the following:</p> <pre><code>ContractTrace1 == ContractTrace2\n               and\nHardwareTrace1 != HardwareTrace2\n</code></pre> <p>This requires relational reasoning: * We partition inputs into groups, which we call input classes. All inputs within a class have the same contract trace. Thus, input classes correspond to the equivalence classes of equality on contract traces. Classes with a single (ineffective) input are discarded. * For each class, we check if all inputs within a class have the same hardware trace.</p> <p>If the check fails on any of the classes, we found a counterexample that witnesses contract violation.</p>"},{"location":"how-revizor-works/#revizor","title":"Revizor","text":"<p>Revizor implements the MRT approach for black-box CPUs. The implementation details are described in Revizor Architecture.</p>"},{"location":"minimization/","title":"Minimization of Violation Artifacts","text":"<p><code>minimize</code> mode of Revizor performs post-processing of the violation artifacts produced as a result of testing a CPU in the <code>fuzz</code> mode. This mode takes a violating program and its sequence of inputs, and it performs a series of transformation passes to simplify the program and the inputs while preserving the violation. The goal is to produce a minimal artifact that would be easier to understand and analyze by a human.</p>"},{"location":"minimization/#usage","title":"Usage","text":"<p>To run the minimization mode, you need a program that violates the contract (e.g., <code>program.asm</code>), a configuration file that was used to detect the violation (e.g., <code>config.yaml</code>), a specification of the instruction set (e.g., <code>base.json</code>). The config file must set the input generation seed (<code>input_gen_seed</code>) to the value that matches the seed used in the <code>fuzz</code> mode to generate the violating inputs.</p> <p>The syntax of the command is as follows:</p> <pre><code>rvzr minimize -s &lt;spec_file&gt; -c &lt;config_file&gt; -t &lt;program_file&gt; -o &lt;output_file&gt; -i &lt;num_inputs&gt; --input-outdir &lt;input_outdir&gt; --num-attempts &lt;num_attempts&gt; &lt;pass_list&gt;\n</code></pre> <p>A typical example of the command is:</p> <pre><code>rvzr minimize -s base.json -c config.yaml -i 25 -t program.asm -o min.asm --input-outdir ./inputs --num-attempts 10 --enable-instruction-pass 1\n</code></pre> <p>This example command will take the program <code>program.asm</code>, generate an input sequence of length 25 based on the seed in <code>config.yaml</code>, and then apply a series of transformation passes (see the list of supported passes below) to simplify the program and the inputs. The passes will be applied 10 times. The resulting simplified program will be written to <code>min.asm</code>, and the simplified input sequence will be written to the directory <code>&lt;dir&gt;</code>.</p>"},{"location":"minimization/#supported-passes","title":"Supported Passes","text":"<p><code>minimize</code> mode supports three types of passes: program passes modify the program, input passes modify the input sequence, and analysis passes provide additional information about the violation, usually by adding comments to the program.</p>"},{"location":"minimization/#program-passes","title":"Program Passes","text":"<pre><code>--enable-instruction-pass\n</code></pre> <p>Enables the instruction minimization pass that iteratively removes instructions from the program while preserving the violation.</p> <pre><code>--enable-simplification-pass\n</code></pre> <p>Enables the instruction simplification pass that replaces complex instructions with simpler ones while preserving the violation.</p> <pre><code>--enable-nop-pass\n</code></pre> <p>Enables the NOP replacement pass that iteratively replaces instructions with NOPs of the same size while preserving the violation.</p> <pre><code>--enable-constant-pass\n</code></pre> <p>Enables the constant simplification pass that replaces immediate arguments of instructions with 0s while preserving the violation.</p> <pre><code>--enable-mask-pass\n</code></pre> <p>Enables the mask simplification pass that reduces the size of the instrumentation masks while preserving the violation.</p> <pre><code>--enable-label-pass\n</code></pre> <p>Enables the label removal pass that removes unused labels from the assembly file.</p> <pre><code>--enable-fence-pass\n</code></pre> <p>Enables the fence insertion pass that adds LFENCEs after instructions while preserving the violation.</p>"},{"location":"minimization/#input-passes","title":"Input Passes","text":"<pre><code>--enable-input-seq-pass\n</code></pre> <p>Enables the input sequence minimization pass that removes inputs from the original generated sequence while preserving the violation.</p> <pre><code>--enable-input-diff-pass\n</code></pre> <p>Enables the violating input difference minimization pass that operates on the pair of (contract-equivalent) inputs that triggered the violation and attempts to minimize the difference between the two inputs. It does so by iterating over all bytes in the inputs, and (1) attempting to replace each byte with zero, and if it fails, (2) copying the byte from the first input to the second input.</p>"},{"location":"minimization/#analysis-passes","title":"Analysis Passes","text":"<pre><code>--enable-source-analysis\n</code></pre> <p>Enables the speculation source identification pass that analyzes the program to identify suspected sources of speculation, and adds the corresponding comments to the assembly file. Note that the analysis is not guaranteed to be correct, and it may produce false results.</p> <pre><code>--enable-comment-pass\n</code></pre> <p>Enables the violation comment pass that adds comments to the assembly file with details about the violation. Namely, it adds comments to every memory access in the following format:</p> <p><code># mem access: [input1_id] [load_addr]-[store_addr] CL [cache_set_id]:[cache_line_offset] | [input2_id] [load_addr]-[store_addr] CL [cache_set_id]:[cache_line_offset]</code></p> <p>The comment indicates the addresses (<code>load_addr</code> and <code>store_addr</code>) of the given memory operation when executed with the two inputs that triggered the violation (<code>input1_id</code> and <code>input2_id</code>). For convenience, it also provides the L1D cache set ID and line offset that correspond to the addresses of the memory operation.</p> <p>For example, this comment</p> <p><code># mem access: [1] 0x800-0x800 CL 32:0 | [11] 0x710-0x710 CL 28:10</code></p> <p>indicates that the memory operation preceded by this comment was executed with two inputs, <code>1</code> and <code>11</code>, and the memory operation accessed the addresses <code>0x800</code> and <code>0x710</code> in the two inputs, respectively. The address <code>0x800</code> corresponded to cache set <code>32</code> and line offset <code>0</code>, while the address <code>0x710</code> corresponded to cache set <code>28</code> and line offset <code>10</code>.</p>"},{"location":"minimization/#interpreting-the-output","title":"Interpreting the Output","text":"<p>When a pass executes, it prints out the progress into the console.</p>"},{"location":"minimization/#output-of-program-passes","title":"Output of Program Passes","text":"<p>Most of the passes print out one character per instruction, with <code>.</code> indicating that the pass succeeded, and <code>-</code> indicating that the pass failed on the given instruction. For example, if <code>--enable-instruction-pass</code> is enabled, the output may look like this:</p> <p><pre><code>[Pass 2] Instruction Removal Pass\n\n.............-.....--.-------..----\n</code></pre> This means that the pass successfully removed the last 13 instructions, failed to remove the 14th instruction, succeeded on the 15th instruction, and so on. Note that the pass iterates from bottom to top, hence the output is printed in reverse order.</p>"},{"location":"minimization/#output-of-input-passes","title":"Output of Input Passes","text":"<p>The <code>input-diff</code> pass has a slightly different output format. It prints out a compact representation of the input difference, with each character representing a byte in the input sequence: * <code>.</code> indicates that zeroing the byte succeeded * <code>+</code> indicates that copying the byte succeeded * <code>=</code> indicates that the byte was already the same in both inputs * <code>^</code> indicates that the pass failed to minimize the byte, and it remained different in the two inputs</p> <p>For example, the output of the <code>input-diff</code> pass may look like this:</p> <pre><code>Address    +0x0     +0x40    +0x80    +0xc0    +0x100   +0x140   +0x180   +0x1c0\n0x00000000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00002000 ====^=..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2020']\n</code></pre> <p>This output indicates that the pass successfully minimized the input difference for all bytes except for the byte at address <code>0x2020</code>, which remained different in the two inputs, and the bytes at addresses <code>0x2000-0x2018</code> and <code>0x2028</code> were already the same in both inputs.</p>"},{"location":"minimization/#usage-example","title":"Usage Example","text":"<p>The following example demonstrates a typical workflow of using the <code>minimize</code> mode to simplify a violating program and its input sequence.</p> <p>Let's assume that a violation artifact was produces as a result of a fuzzing campaign like this:</p> <pre><code>rvzr fuzz -s base.json -c config.yaml -n 1000 -i 25 -w .\n</code></pre> <p>The first step is to minimize the violating program by enabling all program passes:</p> <pre><code>rvzr minimize -s base.json -c ./violation-000000-000000/minimize.yaml \\\n     -t ./violation/violation-000000-000000/program.asm \\\n     -o min.asm -i 25 --num-attempts 3 \\\n     --enable-instruction-pass 1 \\\n     --enable-simplification-pass 1 \\\n     --enable-nop-pass 1 \\\n     --enable-constant-pass 1 \\\n     --enable-mask-pass 1 \\\n     --enable-label-pass 1\n</code></pre> <p>Then verify the violation is preserved by reproducing it with the minimized program and the original input sequence:</p> <pre><code>rvzr fuzz -s base.json -c minimize.yaml -t min.asm -i 25\n</code></pre> <p>If the violation is detected, move to the next step. Otherwise, re-run the first command with a lower number of <code>--num-attempts</code> or try to disable some of the passes.</p> <p>The next step is to minimize the inputs by enabling all input passes, and to add analysis comments:</p> <pre><code>rvzr minimize -s base.json -c ./violation/violation-240712-132351/minimize.yaml \\\n    -t min.asm \\\n    -o commented.asm -i 25  \\\n    --input-outdir ./inputs \\\n    --enable-input-diff-pass 1 \\\n    --enable-input-seq-pass 1 \\\n    --enable-source-analysis 1 \\\n    --enable-comment-pass 1\n</code></pre> <p>The final step is to try to reproduce the violation with the minimized program and inputs to verify that the violation is preserved:</p> <pre><code>rvzr reproduce -s base.json -c ./violation/violation-240712-132351/reproduce.yaml \\\n    -t commented.asm -i ./inputs/min_input*.bin\n</code></pre> <p>If the violation is detected, the minimized program and inputs can be used for further analysis.</p>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#installation","title":"Installation","text":"<p>Warning: Revizor runs randomly-generated code in kernel space. This means that a misconfiguration (or a bug) can crash the system and potentially lead to data loss. Make sure you're not running Revizor on a production machine, and that you have a backup of your data.</p>"},{"location":"quick-start/#1-requirements","title":"1. Requirements","text":"<ul> <li> <p>Architecture: Revizor supports Intel and AMD x86-64 CPUs. We have experimental support for ARM CPUs (see <code>arm-port</code> branch) but it is at very early stages, so use it on your own peril.</p> </li> <li> <p>No virtualization: You will need a bare-metal OS installation. Testing from inside a VM is not supported.</p> </li> <li> <p>OS: The target machine has to be running Linux v4.15 or later.</p> </li> </ul>"},{"location":"quick-start/#2-python-package","title":"2. Python Package","text":"<p>The preferred installation method is using <code>pip</code> within a virtual environment. The python version must be 3.9 or later.</p> <pre><code>sudo apt install python3.9 python3.9-venv\n/usr/bin/python3.9 -m pip install virtualenv\n/usr/bin/python3.9 -m virtualenv ~/venv-revizor\nsource ~/venv-revizor/bin/activate\npip install revizor-fuzzer\n</code></pre>"},{"location":"quick-start/#3-executor","title":"3. Executor","text":"<p>In addition to the Python package, you will need to build and install the executor, which is a kernel module.</p> <pre><code># building a kernel module require kernel headers\nsudo apt-get install linux-headers-$(uname -r) linux-headers-generic\n\n# get the source code\ngit clone https://github.com/microsoft/sca-fuzzer.git\n\n# build executor\ncd sca-fuzzer/src/x86/executor\nmake uninstall  # the command will give an error message, but it's ok!\nmake clean\nmake\nmake install\n</code></pre>"},{"location":"quick-start/#4-download-isa-spec","title":"4. Download ISA spec","text":"<pre><code>rvzr download_spec -a x86-64 --extensions ALL_SUPPORTED --outfile base.json\n\n# Alternatively, use the following command to include system instructions;\n# however, mind that testing these instructions may crash the system if misconfigured!\n# rvzr download_spec -a x86-64 --extensions ALL_AND_UNSAFE --outfile base.json\n</code></pre>"},{"location":"quick-start/#5-test-the-installation","title":"5. Test the Installation","text":"<p>To make sure that the installation was successful, run the following command:</p> <pre><code>./tests/quick-test.sh\n\n# The expected output is:\nDetection: OK\nFiltering: OK\n</code></pre> <p>If you see any other output, check if the previous steps were executed correctly. If you still have issues, please open an issue.</p>"},{"location":"quick-start/#6-optional-system-configuration","title":"6. (Optional) System Configuration","text":"<p>External processes can interfere with Revizor's measurements. To minimize this interference, we recommend the following system configuration:</p> <ul> <li>Disable Hyperthreading (BIOS option);</li> <li>Disable Turbo Boost (BIOS option);</li> <li>Boot the kernel on a single core (add <code>-maxcpus=1</code> to Linux boot parameters).</li> </ul> <p>If you skip these steps, Revizor may produce false positives, especially if you use a low value for <code>executor_sample_sizes</code> for measurements. However, a large sample size (&gt; 300-400) usually mitigates this issue.</p>"},{"location":"quick-start/#quick-start","title":"Quick Start","text":"<p>The following is an example of a simple fuzzing session with Revizor that will detect Spectre V1-like violations.</p> <p>Create a configuration file <code>config.yaml</code> with the following content: <pre><code># config.yaml\ninstruction_categories:\n  - BASE-BINARY  # arithmetic instructions\n  - BASE-COND_BR  # conditional branches\nmax_bb_per_function: 5  # up to 5 branches per test case\nmin_bb_per_function: 1\nmax_successors_per_bb: 2  # enable basic blocks with conditional branches\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n  - no_speculation  # aka SEQ\n</code></pre></p> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 1000 -c config.yaml -w .\n</code></pre></p> <p>You will likely see a violation within a few minutes, as most modern CPUs implement branch prediction, which is a prerequisite for Spectre-like attacks, and so the contract <code>CT-SEQ</code> is likely to be violated.</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 18422470923634754929 (hash)\nHardware traces:\n  Input group 1: [7]\n  Input group 2: [57]\n  ^..........................................^.............^^..^^. [500    | 0     ]\n  ^....^...................................................^^..^^. [0      | 500   ]\n</code></pre> <p>You can find the violating test case as well as the violation report in the directory named <code>./violation-*/</code>. It will contain an assembly file <code>program.asm</code> that surfaced a violation, a sequence of inputs <code>input_*.bin</code> to this program, and some details about the violation in <code>report.txt</code>.</p>"},{"location":"quick-start/#command-line-interface","title":"Command Line Interface","text":"<p>The fuzzer is controlled via a single command line interface <code>rvzr</code> (or <code>revizor.py</code> if you're running directly from the source tree).</p> <p>It accepts the following arguments:</p> <ul> <li><code>-s, --instruction-set PATH</code> - path to the ISA description file</li> <li><code>-c, --config PATH</code> - path to the fuzzing configuration file</li> <li><code>-n , --num-test-cases N</code> - number of test cases to be tested</li> <li><code>-i , --num-inputs N</code> - number of input classes per test case. The number of actual inputs = input classes * inputs_per_class, which is a configuration option</li> <li><code>-t , --testcase PATH</code> - use an existing test case instead of generating random test cases</li> <li><code>--timeout TIMEOUT</code> - run fuzzing with a time limit [seconds]</li> <li><code>-w</code> - working directory where the detected violations will be stored</li> </ul> <p>For example, this command <pre><code>rvzr fuzz -s base.json -n 100 -i 10  -c config.yaml -w ./violations\n</code></pre> will run the fuzzer for 100 iterations (i.e., 100 test cases), with 10 inputs per test case. The fuzzer will use the ISA spec stored in the <code>base.json</code> file, and will read the configuration from <code>config.yaml</code>. If the fuzzer finds a violation, it will be stored in the <code>./violations</code> directory.</p> <p>See docs for more details.</p>"},{"location":"quick-start/#how-to-fuzz-with-revizor","title":"How To Fuzz With Revizor","text":"<p>The fuzzing process is controlled by a configuration file in the YAML format, passed via <code>--config</code> option. At the very minimum, this file should contain the following fields:</p> <ul> <li><code>contract_observation_clause</code> and <code>contract_execution_clause</code> describe the contract that the CPU-under-test is tested against. See this page for a list of available contracts. If you don't know what a contract is, Sec. 3 of this paper will give you a high-level introduction to contracts, and this paper will provide a deep dive into contracts.</li> <li><code>instruction_categories</code> is a list of instruction types that will be tested. Effectively, Revizor uses this list to filter out instructions from <code>base.json</code> (the file you downloaded via <code>rvzr download_spec</code>).</li> </ul> <p>For a full list of configuration options, see docs.</p>"},{"location":"quick-start/#baseline-experiment","title":"Baseline Experiment","text":"<p>After a fresh installation, it is normally a good idea to do a quick test run to check that everything works ok.</p> <p>For example, we can create a configuration file <code>config.yaml</code> with only simple arithmetic instructions. As this instruction set does not include any instructions that would trigger speculation on Intel or AMD CPUs (at least that we know of), the expected contract would be <code>CT-SEQ</code>:</p> <pre><code># config.yaml\ninstruction_categories:\n  - BASE-BINARY  # arithmetic instructions\nmax_bb_per_function: 1  # no branches!\nmin_bb_per_function: 1\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n  - no_speculation  # aka SEQ\n</code></pre> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 100 -c config.yaml  -w .\n</code></pre></p> <p>This command should terminate with no violations.</p>"},{"location":"quick-start/#full-scale-fuzzing-campaign","title":"Full-Scale Fuzzing Campaign","text":"<p>To start a full-scale test, write your own configuration file (see description here and an example config here), and launch the fuzzer.</p> <p>Below is a example launch command, which will start a 24-hour fuzzing session, with 100 input classes per test case, and which uses big-fuzz.yaml configuration: <pre><code>rvzr fuzz -s base.json -c demo/big-fuzz.yaml -i 100 -n 100000000 --timeout 86400 -w `pwd` --nonstop\n</code></pre></p> <p>If there is a violation, you can try to reproduce it with the following command:</p> <pre><code>rvzr reproduce -s base.json -c violation-&lt;timestamp&gt;/reproduce.yaml -t violation-&lt;timestamp&gt;/program.asm -i violation-&lt;timestamp&gt;/input_*.bin\n</code></pre> <p>If the violation is reproducible, it is useful to minimize it, so that it is easier to understand the root cause (note that minimization uses a different config file):</p> <pre><code>rvzr minimize -s base.json -c violation-&lt;timestamp&gt;/minimize.yaml -g violation-&lt;timestamp&gt;/program.asm -o violation-&lt;timestamp&gt;/minimized.asm -i 100 --num-attempts 10 --enable-simplification-pass\n</code></pre> <p>The result of minimization will be stored in <code>violation-&lt;timestamp&gt;/minimized.asm</code>. If the result is still too complicated, try other minimization passes.</p> <p>The further analysis is manual; you can find an example in this guide.</p>"},{"location":"quick-start/#need-help-with-revizor","title":"Need Help with Revizor?","text":"<p>If you find a bug in Revizor, don't hesitate to open an issue.</p> <p>If something is confusing or you need help in using Revizor, we have a discussion page.</p>"},{"location":"quick-start/#documentation","title":"Documentation","text":"<p>For more details, see the website.</p>"},{"location":"registers/","title":"Register Allocation","text":"<p>The test cases are executed in a sandboxed environment, some of the registers are reserved for internal use, and some are available for use in the test cases. Below is a list of registers and their purpose.</p>"},{"location":"registers/#r15","title":"<code>R15</code>","text":"<p>Contains the base address of the UTILITY area in the sandbox.</p> <p>If the test case does not enter a VM, the register value remains constant during the execution of the test cases. Otherwise, the register value is updated to point to the UTILITY area of the currently active VM when the <code>switch_h2g</code> macro is called, and it is restored to the original value when the <code>switch_g2h</code> macro is called.</p> <p>The register is used by internal functions, such as the implementation of Prime+Probe.</p>"},{"location":"registers/#r14","title":"<code>R14</code>","text":"<p>Contains the base address of the current actor's sandbox (namely, it points to the base of the actor's MAIN area).</p> <p>At the beginning of the test case execution, the register is set to the base address of the MAIN area of the first actor (actor <code>main</code>). The register value is updated to point to the MAIN area of the currently active actor when a macro from the <code>landing_*</code> group of macros is called. It is also updated by the <code>fault_handler</code> macro.</p> <p>The register is used in test cases as a part of the sandboxing mechanism. For example, all generated memory accesses are relative to the value stored in <code>R14</code>, and have the form of <code>[R14 + offset]</code>.</p>"},{"location":"registers/#r13-htrace_register-constant-in-the-kernel-module","title":"<code>R13</code> (<code>HTRACE_REGISTER</code> constant in the kernel module)","text":"<p>Contains either intermediate or final result of the hardware trace measurements.</p> <p>Before entering the test case, the register is set to 0. When a <code>measurement_start</code> macro is executed, the register is (optionally) set to the starting value, such a initial reading of time stamp counter when the <code>TSC</code> mode is used. When a <code>measurement_end</code> macro is executed, the register is updated with the final value of the measurement and contains the resulting hardware trace.</p>"},{"location":"registers/#r12-status_register-constant-in-the-kernel-module","title":"<code>R12</code> (<code>STATUS_REGISTER</code> constant in the kernel module)","text":"<p>Contains a compressed status of the test case execution:</p> <p>Bits[0:7] contain a measurement status. At the beginning of the test case execution, the bits are set to 0. When <code>measurement_start</code> macro is executed, the bits are set to 1. When <code>measurement_end</code> macro is executed, the bits are set to 2. If the measurement status is not 2 at the end of the test case execution, the kernel module will report an error.</p> <p>Bits[8:31] are unused.</p> <p>Bits[32:63] contain a counter of SMI (System Management Interrupt) events. The counter is set automatically before entering the test case (<code>READ_SMI_START</code>), and updated when the test case finishes (<code>READ_SMI_END</code>). If the difference between the readings is not 0, the kernel module will report an error.</p>"},{"location":"registers/#r11","title":"<code>R11</code>","text":"<p>The register is used as a temporary buffer by some of the macros.</p> <p>Before entering the test case, the register is set to 0. When certain macros are executed (e.g., <code>set_k2u_target</code>), the register will contain temporary values. The register should not be used in the test case, as the temporary value may be consumed by latter macros.</p>"},{"location":"registers/#r10-r9-r8","title":"<code>R10, R9, R8</code>","text":"<p>Stores the values of performance counters. <code>R10</code> stores the value of performance counter #1, <code>R9</code> stores the value of performance counter #2, and <code>R8</code> stores the value of performance counter #3.</p> <p>Before entering the test case, the registers are set to 0. When a <code>measurement_start</code> macro is executed, the registers are (optionally) set to the starting values. When a <code>measurement_end</code> macro is executed, the registers are updated with the final values of the measurements.</p>"},{"location":"registers/#other-general-purpose-registers","title":"Other General Purpose Registers","text":"<p>The remaining registers (<code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>rflags</code>) are available for use in the test cases and can be modified freely. A special case are <code>rsp</code> and <code>rbp</code>, which can be used in the test cases, but their values must always remain within the sandbox (see Sandbox).</p>"},{"location":"registers/#vector-registers","title":"Vector Registers","text":"<p>Vector registers (<code>xmm0</code>-<code>xmm15</code>) are also available for use in the test cases. However, only <code>xmm0-xmm7</code> are initialized with input-based values, and the remaining registers are always zero-initialized.</p> <p>Large-size vector registers (<code>ymm</code> and <code>zmm</code>) are not supported.</p>"},{"location":"sandbox/","title":"Memory Layout","text":"<p>UNDER CONSTRUCTION</p>"},{"location":"trophies/","title":"Trophies","text":""},{"location":"trophies/#newly-discovered-vulnerabilities","title":"Newly discovered vulnerabilities","text":""},{"location":"trophies/#string-comparison-overrun-sco","title":"String Comparison Overrun (SCO)","text":"<p>The page is under construction</p>"},{"location":"trophies/#zero-dividend-injection-zdi","title":"Zero Dividend Injection (ZDI)","text":"<p>The page is under construction</p>"},{"location":"trophies/#spectre-v1-var-and-v4-var","title":"Spectre V1-Var and V4-Var","text":"<p>The page is under construction</p>"},{"location":"trophies/#store-based-spectre-v1","title":"Store-based Spectre V1","text":"<p>The page is under construction</p>"},{"location":"trophies/#speculative-store-with-forwarding","title":"Speculative Store with Forwarding","text":"<p>The page is under construction</p>"},{"location":"trophies/#known-vulnerabilities-automatically-reproduced-by-revizor","title":"Known vulnerabilities automatically reproduced by Revizor","text":""},{"location":"trophies/#spectre-v1-bounds-check-bypass-bcb","title":"Spectre V1 (Bounds Check Bypass, BCB)","text":"<p>The page is under construction</p>"},{"location":"trophies/#spectre-v4-speculative-store-bypass-ssbp","title":"Spectre V4 (Speculative Store Bypass, SSBP)","text":"<p>The page is under construction</p>"},{"location":"trophies/#meltdown-smap-variant","title":"Meltdown (SMAP variant)","text":"<p>The page is under construction</p>"},{"location":"trophies/#foreshadow-l1tf","title":"Foreshadow (L1TF)","text":"<p>The page is under construction</p>"},{"location":"trophies/#microarchitectural-data-sampling-mds","title":"Microarchitectural Data Sampling (MDS)","text":"<p>The page is under construction</p>"},{"location":"trophies/#load-value-injection-lvi-including-lvi-null","title":"Load Value Injection (LVI), including LVI-Null","text":"<p>The page is under construction</p>"}]}