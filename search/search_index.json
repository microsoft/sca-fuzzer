{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Revizor","text":"<p>Welcome to Revizor.</p>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#installation","title":"Installation","text":"<p>Warning: Revizor runs randomly-generated code in kernel space. This means that a misconfiguration (or a bug) can crash the system and potentially lead to data loss. Make sure you're not running Revizor on a production machine, and that you have a backup of your data.</p>"},{"location":"quick-start/#1-requirements","title":"1. Requirements","text":"<ul> <li> <p>Architecture: Revizor supports Intel and AMD x86-64 CPUs. We have experimental support for ARM CPUs (see <code>arm-port</code> branch) but it is at very early stages, so use it on your own peril.</p> </li> <li> <p>No virtualization: You will need a bare-metal OS installation. Testing from inside a VM is not supported.</p> </li> <li> <p>OS: The target machine has to be running Linux v4.15 or later.</p> </li> </ul>"},{"location":"quick-start/#2-python-package","title":"2. Python Package","text":"<p>The preferred installation method is using <code>pip</code> within a virtual environment. The python version must be 3.9 or later.</p> <pre><code>sudo apt install python3.9 python3.9-venv\n/usr/bin/python3.9 -m pip install virtualenv\n/usr/bin/python3.9 -m virtualenv ~/venv-revizor\nsource ~/venv-revizor/bin/activate\npip install revizor-fuzzer\n</code></pre>"},{"location":"quick-start/#3-executor","title":"3. Executor","text":"<p>In addition to the Python package, you will need to build and install the executor, which is a kernel module.</p> <pre><code># building a kernel module require kernel headers\nsudo apt-get install linux-headers-$(uname -r) linux-headers-generic\n\n# get the source code\ngit clone https://github.com/microsoft/sca-fuzzer.git\n\n# build executor\ncd sca-fuzzer/src/x86/executor\nmake uninstall  # the command will give an error message, but it's ok!\nmake clean\nmake\nmake install\n</code></pre>"},{"location":"quick-start/#4-optional-dynamorio-backend","title":"4. (Optional) DynamoRIO Backend","text":"<p>If you want to use the DynamoRIO-based model, it has to be installed separately:</p> <pre><code># install dependencies\nsudo apt-get install cmake g++ g++-multilib doxygen git zlib1g-dev libunwind-dev libsnappy-dev liblz4-dev\n\n# install DynamoRIO and the model\nmake -C src/model_dynamorio\n\n# check installation\n~/.local/dynamorio/drrun -c ~/.local/dynamorio/libdr_model.so --list-obs-clauses -- ls\n# expected output:\n#   ct\n#   ...\n#   /dev/null\n</code></pre>"},{"location":"quick-start/#5-download-isa-spec","title":"5. Download ISA spec","text":"<pre><code>rvzr download_spec -a x86-64 --extensions ALL_SUPPORTED --outfile base.json\n\n# Alternatively, use the following command to include system instructions;\n# however, mind that testing these instructions may crash the system if misconfigured!\n# rvzr download_spec -a x86-64 --extensions ALL_AND_UNSAFE --outfile base.json\n</code></pre>"},{"location":"quick-start/#6-test-the-installation","title":"6. Test the Installation","text":"<p>To make sure that the installation was successful, run the following command:</p> <pre><code>./tests/quick-test.sh\n\n# The expected output is:\nDetection: OK\nFiltering: OK\n</code></pre> <p>If you see any other output, check if the previous steps were executed correctly. If you still have issues, please open an issue.</p>"},{"location":"quick-start/#7-optional-system-configuration","title":"7. (Optional) System Configuration","text":"<p>External processes can interfere with Revizor's measurements. To minimize this interference, we recommend the following system configuration:</p> <ul> <li>Disable Hyperthreading (BIOS option);</li> <li>Disable Turbo Boost (BIOS option);</li> <li>Boot the kernel on a single core (add <code>-maxcpus=1</code> to Linux boot parameters).</li> </ul> <p>If you skip these steps, Revizor may produce false positives, especially if you use a low value for <code>executor_sample_sizes</code> for measurements. However, a large sample size (&gt; 300-400) usually mitigates this issue.</p>"},{"location":"quick-start/#quick-start","title":"Quick Start","text":"<p>The following is an example of a simple fuzzing session with Revizor that will detect Spectre V1-like violations.</p> <p>Create a configuration file <code>config.yaml</code> with the following content: <pre><code># config.yaml\ninstruction_categories:\n  - BASE-BINARY  # arithmetic instructions\n  - BASE-COND_BR  # conditional branches\nmax_bb_per_function: 5  # up to 5 branches per test case\nmin_bb_per_function: 1\nmax_successors_per_bb: 2  # enable basic blocks with conditional branches\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n  - no_speculation  # aka SEQ\n</code></pre></p> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 1000 -c config.yaml -w .\n</code></pre></p> <p>You will likely see a violation within a few minutes, as most modern CPUs implement branch prediction, which is a prerequisite for Spectre-like attacks, and so the contract <code>CT-SEQ</code> is likely to be violated.</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 18422470923634754929 (hash)\nHardware traces:\n  Input group 1: [7]\n  Input group 2: [57]\n  ^..........................................^.............^^..^^. [500    | 0     ]\n  ^....^...................................................^^..^^. [0      | 500   ]\n</code></pre> <p>You can find the violating test case as well as the violation report in the directory named <code>./violation-*/</code>. It will contain an assembly file <code>program.asm</code> that surfaced a violation, a sequence of inputs <code>input_*.bin</code> to this program, and some details about the violation in <code>report.txt</code>.</p>"},{"location":"quick-start/#command-line-interface","title":"Command Line Interface","text":"<p>The fuzzer is controlled via a single command line interface <code>rvzr</code> (or <code>revizor.py</code> if you're running directly from the source tree).</p> <p>It accepts the following arguments:</p> <ul> <li><code>-s, --instruction-set PATH</code> - path to the ISA description file</li> <li><code>-c, --config PATH</code> - path to the fuzzing configuration file</li> <li><code>-n , --num-test-cases N</code> - number of test cases to be tested</li> <li><code>-i , --num-inputs N</code> - number of input classes per test case. The number of actual inputs = input classes * inputs_per_class, which is a configuration option</li> <li><code>-t , --testcase PATH</code> - use an existing test case instead of generating random test cases</li> <li><code>--timeout TIMEOUT</code> - run fuzzing with a time limit [seconds]</li> <li><code>-w</code> - working directory where the detected violations will be stored</li> </ul> <p>For example, this command <pre><code>rvzr fuzz -s base.json -n 100 -i 10  -c config.yaml -w ./violations\n</code></pre> will run the fuzzer for 100 iterations (i.e., 100 test cases), with 10 inputs per test case. The fuzzer will use the ISA spec stored in the <code>base.json</code> file, and will read the configuration from <code>config.yaml</code>. If the fuzzer finds a violation, it will be stored in the <code>./violations</code> directory.</p> <p>See docs for more details.</p>"},{"location":"quick-start/#how-to-fuzz-with-revizor","title":"How To Fuzz With Revizor","text":"<p>The fuzzing process is controlled by a configuration file in the YAML format, passed via <code>--config</code> option. At the very minimum, this file should contain the following fields:</p> <ul> <li><code>contract_observation_clause</code> and <code>contract_execution_clause</code> describe the contract that the CPU-under-test is tested against. See this page for a list of available contracts. If you don't know what a contract is, Sec. 3 of this paper will give you a high-level introduction to contracts, and this paper will provide a deep dive into contracts.</li> <li><code>instruction_categories</code> is a list of instruction types that will be tested. Effectively, Revizor uses this list to filter out instructions from <code>base.json</code> (the file you downloaded via <code>rvzr download_spec</code>).</li> </ul> <p>For a full list of configuration options, see docs.</p>"},{"location":"quick-start/#baseline-experiment","title":"Baseline Experiment","text":"<p>After a fresh installation, it is normally a good idea to do a quick test run to check that everything works ok.</p> <p>For example, we can create a configuration file <code>config.yaml</code> with only simple arithmetic instructions. As this instruction set does not include any instructions that would trigger speculation on Intel or AMD CPUs (at least that we know of), the expected contract would be <code>CT-SEQ</code>:</p> <pre><code># config.yaml\ninstruction_categories:\n  - BASE-BINARY  # arithmetic instructions\nmax_bb_per_function: 1  # no branches!\nmin_bb_per_function: 1\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n  - no_speculation  # aka SEQ\n</code></pre> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 100 -c config.yaml  -w .\n</code></pre></p> <p>This command should terminate with no violations.</p>"},{"location":"quick-start/#full-scale-fuzzing-campaign","title":"Full-Scale Fuzzing Campaign","text":"<p>To start a full-scale test, write your own configuration file (see description here and an example config here), and launch the fuzzer.</p> <p>Below is a example launch command, which will start a 24-hour fuzzing session, with 100 input classes per test case, and which uses big-fuzz.yaml configuration: <pre><code>rvzr fuzz -s base.json -c demo/big-fuzz.yaml -i 100 -n 100000000 --timeout 86400 -w `pwd` --nonstop\n</code></pre></p> <p>If there is a violation, you can try to reproduce it with the following command:</p> <pre><code>rvzr reproduce -s base.json -c violation-&lt;timestamp&gt;/reproduce.yaml -t violation-&lt;timestamp&gt;/program.asm -i violation-&lt;timestamp&gt;/input_*.bin\n</code></pre> <p>If the violation is reproducible, it is useful to minimize it, so that it is easier to understand the root cause (note that minimization uses a different config file):</p> <pre><code>rvzr minimize -s base.json -c violation-&lt;timestamp&gt;/minimize.yaml -g violation-&lt;timestamp&gt;/program.asm -o violation-&lt;timestamp&gt;/minimized.asm -i 100 --num-attempts 10 --enable-simplification-pass\n</code></pre> <p>The result of minimization will be stored in <code>violation-&lt;timestamp&gt;/minimized.asm</code>. If the result is still too complicated, try other minimization passes.</p> <p>The further analysis is manual; you can find an example in this guide.</p>"},{"location":"quick-start/#need-help-with-revizor","title":"Need Help with Revizor?","text":"<p>If you find a bug in Revizor, don't hesitate to open an issue.</p> <p>If something is confusing or you need help in using Revizor, we have a discussion page.</p>"},{"location":"quick-start/#documentation","title":"Documentation","text":"<p>For more details, see the website.</p>"},{"location":"trophies/","title":"Trophies","text":""},{"location":"trophies/#newly-discovered-vulnerabilities","title":"Newly discovered vulnerabilities","text":""},{"location":"trophies/#string-comparison-overrun-sco","title":"String Comparison Overrun (SCO)","text":"<p>The page is under construction</p>"},{"location":"trophies/#zero-dividend-injection-zdi","title":"Zero Dividend Injection (ZDI)","text":"<p>The page is under construction</p>"},{"location":"trophies/#spectre-v1-var-and-v4-var","title":"Spectre V1-Var and V4-Var","text":"<p>The page is under construction</p>"},{"location":"trophies/#store-based-spectre-v1","title":"Store-based Spectre V1","text":"<p>The page is under construction</p>"},{"location":"trophies/#speculative-store-with-forwarding","title":"Speculative Store with Forwarding","text":"<p>The page is under construction</p>"},{"location":"trophies/#known-vulnerabilities-automatically-reproduced-by-revizor","title":"Known vulnerabilities automatically reproduced by Revizor","text":""},{"location":"trophies/#spectre-v1-bounds-check-bypass-bcb","title":"Spectre V1 (Bounds Check Bypass, BCB)","text":"<p>The page is under construction</p>"},{"location":"trophies/#spectre-v4-speculative-store-bypass-ssbp","title":"Spectre V4 (Speculative Store Bypass, SSBP)","text":"<p>The page is under construction</p>"},{"location":"trophies/#meltdown-smap-variant","title":"Meltdown (SMAP variant)","text":"<p>The page is under construction</p>"},{"location":"trophies/#foreshadow-l1tf","title":"Foreshadow (L1TF)","text":"<p>The page is under construction</p>"},{"location":"trophies/#microarchitectural-data-sampling-mds","title":"Microarchitectural Data Sampling (MDS)","text":"<p>The page is under construction</p>"},{"location":"trophies/#load-value-injection-lvi-including-lvi-null","title":"Load Value Injection (LVI), including LVI-Null","text":"<p>The page is under construction</p>"},{"location":"devel/architecture/","title":"Revizor Architecture","text":"<p>Below is a high-level overview of Revizor's architecture and its key modules.</p> <p>[THE FOLLOWING IS A WORK IN PROGRESS]</p> <p></p> <p>Revizor has five chief components:</p> <ol> <li>Test Case Generator</li> <li>Input Generator</li> <li>Model</li> <li>Executor</li> <li>Analyser</li> </ol> <p>The Test Case Generator and Input Generator are responsible for generating random test cases to be run through the Model and Executor. The results are examined by the Analyser for contract violations.</p>"},{"location":"devel/architecture/#test-case-program-generator","title":"Test Case (Program) Generator","text":"<p>The TCG is responsible for generating random assembly test cases. It takes an Instruction Set Specification as input in order for it to understand the instructions and syntax it can use for generation.</p>"},{"location":"devel/architecture/#input-generator","title":"Input Generator","text":"<p>The IG is responsible for generating the inputs that are passed into a test case created by the TCG. Largely, this means register and memory values that the microarchitecture will be primed with before executing the test case. In this way, a single test case program can be run across several different inputs, allowing for multiple contract traces (and later, hardware traces) to be collected for analysis.</p>"},{"location":"devel/architecture/#model","title":"Model","text":"<p>The Model's job is to accept test cases and inputs from the TCG &amp; IG and emulate the test case to collect contract traces. A single test case seeded with several inputs (<code>N</code> inputs) will create several contract traces (<code>N</code> contract traces) as the model's output. These are passed to the Analyser to determine input classes.</p>"},{"location":"devel/architecture/#executor","title":"Executor","text":"<p>The Executor, on the other side from the Model, is responsible for running the same test cases (with the same inputs) on physical hardware to collect hardware traces. Hardware traces from the same input class are collected and studied by the Analyser to detect contract violations.</p>"},{"location":"devel/architecture/#analyser","title":"Analyser","text":"<p>The Analyser receives contract traces from the Model and hardware traces from the Executor to accomplish two primary goals:</p> <ol> <li>Compare contract traces to set up input classes.</li> <li>Compare hardware traces to detect contract violations.</li> </ol>"},{"location":"devel/architecture/#revizor-modules-and-interfaces","title":"Revizor Modules and Interfaces","text":"<p>Revizor's implementation and architecture is separated into multiple Python files:</p> <ul> <li><code>cli.py</code> - implements the command-line interface of revizor.</li> <li><code>config.py</code> - implements parsing and managing of revizor's YAML configuration   file.</li> <li><code>generator.py</code> - implements the Test Case Generator portion of   revizor's architecture.</li> <li><code>input_generator.py</code> - implements the Input Generator portion of   revizor's architecture.</li> <li><code>model.py</code> - implements the Unicorn-based Model portion of   revizor's architecture.</li> <li><code>executor.py</code> - implements the Executor portion of   revizor's architecture.</li> <li><code>analyser.py</code> - implements the Analyser portion of   revizor's architecture.</li> <li><code>postprocessor.py</code> - defines the <code>MinimizerViolation</code> class, used during   <code>minimize</code> mode to reduce a violation-inducing test case down to a smaller   size while still maintaining the violation-inducing behavior.</li> <li><code>fuzzer.py</code> - implements <code>fuzz</code> mode that utilizes all main components to   perform end-to-end hardware fuzzing.</li> <li><code>factory.py</code> - used to configure revizor accordingly to the user provided   YAML configuration. Implements a simplified version of the Factory pattern:   Defines a series of dictionaries that allows revizor to choose   between various contract, generation techniques, executors, analysers, etc.   In future, it be also used to implement  multiple-ISA support.</li> <li><code>interfaces.py</code> - defines abstract classes (i.e., interfaces) of all main   components of revizor (e.g., abstract  <code>Executor</code>, <code>Model</code>, <code>TestCase</code>,    <code>Input</code>, etc)</li> <li><code>isa\\_loader.py</code> - defines the <code>InstructionSet</code> class, used to load an   ISA's specifications from a JSON file provided via the   command-line interface.</li> <li><code>service.py</code> - defines logging, statistical, and other services to all other   modules within revizor.</li> </ul>"},{"location":"devel/architecture/#architecture-specific-implementation","title":"Architecture-specific Implementation","text":"<p>The modules above are ISA-independent. The architecture-specific implementations are located in the subdirectories. For example, the implementation of the modules for the x86-64 architecture is located in <code>src/x86/</code>. It's structure largely mirrors the main modules of revizor (e.g., <code>x86_model.py</code> contains x86-specific parts of the Model module). The only unique parts are:</p> <ul> <li><code>*_target_desc.py</code> - defines constants describing the ISA (e.g., a list of   available registers) and some helper functions.</li> <li><code>get_spec.py</code> - a script for transforming the ISA description provided   by the CPU vendor (different for every vendor) into a unified JSON format</li> <li><code>executor/</code> - contains a low-level implementation of the executor. The   implementation will be different for each architecture. For black-box x86 CPUs,   it is a Linux kernel module.</li> </ul>"},{"location":"devel/architecture/#abstract-test-case","title":"Abstract Test Case","text":"<p>This describes a number of Python classes within revizor that define parts of an assembly test case. Revizor's TCG uses them to generate syntactically-valid assembly.</p>"},{"location":"devel/architecture/#operandspec","title":"<code>OperandSpec</code>","text":"<p>The <code>OperandSpec</code> class defines a set of valid operands for any given assembly instruction. Each <code>InstructionSpec</code> object (described below) contains a list of these operand specifications. It contains properties such as:</p> <ul> <li>The <code>type</code> of operand</li> <li>The <code>width</code> of the operand</li> <li>Whether or not the operand is a <code>src</code> or <code>dest</code> operand</li> </ul>"},{"location":"devel/architecture/#instructionspec","title":"<code>InstructionSpec</code>","text":"<p>This class represents a single instruction specification. It contains a name (i.e. the actual instruction mnemonic, such as <code>ADD</code>) and a list of <code>OperandSpec</code>s, defining valid operands for the instruction. It also has a number of boolean flags that indicate unique attributes about the instruction, such as:</p> <ul> <li>If the instruction contains a memory write</li> <li>If the instruction is a control-flow instruction</li> </ul>"},{"location":"devel/architecture/#operand","title":"<code>Operand</code>","text":"<p>The <code>Operand</code> class defines an actual operand to be used in an instruction placed into the TCG's generated test case (not to be confused with <code>OperandSpec</code>, which is a set of rules used to define possible operand choices for an instruction). This is an abstract base class that provides a number of sub-classes:</p> <ul> <li><code>RegisterOperand</code></li> <li><code>MemoryOperand</code></li> <li><code>ImmediateOperand</code></li> <li><code>LabelOperand</code></li> <li><code>AgenOperand</code></li> <li><code>FlagsOperand</code></li> </ul>"},{"location":"devel/architecture/#instruction","title":"<code>Instruction</code>","text":"<p>Similar to the relationship between <code>OperandSpec</code> and <code>Operand</code>, the <code>Instruction</code> class defines an actual instruction, constrained by an <code>InstructionSpec</code>, that is used during test case generation. It contains a list of <code>Operand</code>s and is linked to its neighboring instructions via object references.</p>"},{"location":"devel/architecture/#basicblock","title":"<code>BasicBlock</code>","text":"<p>Thisi class represents a single basic block within the generated test case (a basic block is a straight-line sequence of assembly instructions that has a single entry and exit point). It contains a list of all instructions contained within, references to its successor basic block(s), and a list of \"terminator\" instructions (instructions that exit the basic block, such as a branch).</p>"},{"location":"devel/architecture/#function","title":"<code>Function</code>","text":"<p>This object represents a collection of basic blocks that form a function. It has an \"entry\" basic block and an \"exit\" basic block, along with a list of all basic blocks that comprise the function.</p>"},{"location":"devel/architecture/#testcasedag","title":"<code>TestCaseDAG</code>","text":"<p>DAG is short for Directed Acyclic Graph. This object represents the entire test case's control flow. It contains a list of functions that, within, define all instructions to be written out to the test case's assembly file.</p>"},{"location":"devel/binary-formats/","title":"Binary Formats in Revizor","text":"<p>This document describes the structure of the custom binary formats used by Revizor to transfer test cases and their data between different components. For example, these formats are used to pass generated test cases from the executor (python) class to the executor kernel module.</p> <p>Such custom formats are necessary because the components are implemented in different programming languages and different technologies, so passing objects directly is not possible. Using one of the standard formats (e.g., ELF) is also not an option because test cases in Revizor have special structure (e.g., multiple actors in different execution modes, some instructions are macros, etc.) and this structure is not supported by the standard formats.</p> <p>The formats are designed to as simple as possible to minimize the overhead of serialization and deserialization.</p>"},{"location":"devel/binary-formats/#revizor-code-binary-format-rcbf","title":"Revizor Code Binary Format (RCBF)","text":"<p>RCBF is a structured representation of the complete test case binary, together with its metadata. The structure is as follows:</p> <pre><code>|---------------------------------------|\n| n_actors (8 bytes)                    | HEADER       |\n| n_symbols (8 bytes)                   |\n| ------------------------------------- |\n| actor metadata:                       | ACTOR TABLE  |\n| - id (8 bytes)                        |\n| - mode (8 bytes)                      |\n| - pl (8 bytes)                        |\n| - data_permissions (8 bytes)          |\n| - data_ept_permissions (8 bytes)      |\n| - code_permissions (8 bytes)          |\n| x n_actors                            |\n| ------------------------------------- |\n| symbol entry:                         | SYMBOL TABLE |\n| - owner (8 bytes)                     |\n| - offset (8 bytes)                    |\n| - id (8 bytes)                        |\n| - args (8 bytes)                      |\n| x n_symbols                           |\n| ------------------------------------- |\n| section metadata entry:               | METADATA     |\n| - owner (8 bytes)                     |\n| - size (8 bytes)                      |\n| - reserved (8 bytes)                  |\n| x n_actors                            |\n| ------------------------------------- |\n| code section:                         | DATA         |\n| - code (char *)                       |\n| x n_actors                            |\n| ------------------------------------- |\n</code></pre> <p>The file begins with a header containing the number of actors (it is also the number of sections) and the number of symbols in the test case. The term \"symbol\" in this context refers to any location in the test case that can be referenced. Two common types of symbols are functions (specifically, function entry points) and macros.</p> <p>Next, the file contains the actor table, which is an array of actor metadata entries, one for each actor in the test case. The actor metadata entry contains the actor's ID, execution mode, protection level, data permissions, EPT data permissions, and code permissions.</p> <p>After the actor table, the file contains the symbol table, which is an array of symbol entries, one for each symbol in the test case. The symbol entry contains the ID the section to which the symbol belongs, the offset of the symbol within the section, the symbol's ID, and the number of arguments the symbol takes (if it is a macro).</p> <p>The file continues with the table of metadata for each section in the test case. Each metadata entry contains the ID of the actor that owns the section and the size of the section.</p> <p>Finally, the file contains a sequence of code sections, one for each actor in the test case. These sections contain the actual assembled binary for each of the sections in the test case.</p>"},{"location":"devel/binary-formats/#revizor-data-binary-format-rdbf","title":"Revizor Data Binary Format (RDBF)","text":"<p>RDBF is a structured representation of the data used to initialize sandbox memory and registers before executing the test case.</p> <p>Note that this format combines multiple inputs into a single file. This is done because typically, a single test case program is executed multiple times with different inputs, and so it is more efficient to send a batch of inputs at once.</p> <pre><code>|---------------------------------------|\n| n_actors (8 bytes)                    | HEADER\n| n_inputs (8 bytes)                    |\n| ------------------------------------- |\n| section metadata entry:               | METADATA |\n| - section_size (8 bytes)              |\n| - reserved (8 bytes)                  |\n| x (n_actors * n_inputs)               |\n| ------------------------------------- |\n| input:                                | DATA     |\n| - data section:                       |\n| -- main_area (4096 bytes)             |\n| -- faulty_area (4096 bytes)           |\n| -- reg_init_region (4096 bytes)       |\n| - x n_actors                          |\n| x n_inputs                            |\n| ------------------------------------- |\n</code></pre> <p>The file begins with a section containing the number of actors (equal to the number of sections) and the number of inputs in the batch.</p> <p>Next, the file contains the table of metadata for each data section, which only contains the size of the section.</p> <p>Finally, the file contains a sequence of data sections, one for each actor in the test case and each input in the batch. The data sections are arranged to mirror the data layout in the sandbox memory (see the sandbox memory layout document for more information).</p>"},{"location":"devel/code-generation/","title":"Test Case Code Generation","text":"<p>UNDER CONSTRUCTION</p>"},{"location":"devel/development/","title":"Development","text":"<p>This page contains various bits of information helpful when developing and expanding Revizor.</p>"},{"location":"devel/development/#tests","title":"Tests","text":"<p>To run automated tests you will need to install a few more dependencies:</p> <ul> <li>Bash Automated Testing System</li> <li>mypy</li> <li>flake8</li> </ul> <p>With the dependencies installed, you can run the tests with:</p> <pre><code>./tests/runtests.sh\n</code></pre> <p>Note that some of the acceptance tests are microarchitecture-dependent. These tests are labeled \"Detection\" (e.g., \"Detection [spectre-type] Spectre V1; load variant\"), and they may fail if the CPU under test does not have a given vulnerability. Generally, if a few of these tests fail, it is not a problem, but if all of them (or a significant portion) fail, it indicates an issue with the fuzzer.</p>"},{"location":"devel/development/#code-style","title":"Code Style","text":"<p>Please follow these coding standards when writing code for inclusion in Revizor.</p> <p>Python:</p> <ul> <li>Unless otherwise specified, follow PEP 8. But remember that PEP 8 is only a guide, so respect the style of the surrounding code as a primary goal.</li> <li>An exception to PEP 8 is our rules on line lengths. Don\u2019t limit lines of code to 79 characters if it means the code looks significantly uglier or is harder to read. We allow up to 100 characters.</li> <li>All files should be formatted using the <code>flake8</code> auto-formatter. Use all default settings except for the line width (<code>--max-line-length 100</code>)</li> <li>The Python and C files use 4 spaces for indentation, and YAML uses 2 spaces.</li> <li>The project repository includes an .editorconfig file. We recommend using a text editor with EditorConfig support to avoid indentation and whitespace issues.</li> <li>Use underscores, not camelCase, for variable, function and method names (i.e. poll.get_unique_voters(), not poll.getUniqueVoters()).</li> <li>Use InitialCaps for class names (or for factory functions that return classes).</li> <li>In docstrings, follow PEP 257.</li> </ul> <p>C:</p> <ul> <li>All files should be formatted using the <code>clang-format</code>. The settings are included into the <code>.clang-format</code> files in the directories with C files. Just run the formatter with: <code>clang-format -i *.c</code></li> </ul> <p>Misc:</p> <ul> <li>Remove import statements that are no longer used when you change code. flake8 will identify these imports for you. If an unused import needs to remain for backwards-compatibility, mark the end of with # NOQA to silence the flake8 warning.</li> <li>Systematically remove all trailing whitespaces from your code as those add unnecessary bytes, add visual clutter to the patches and can also occasionally cause unnecessary merge conflicts. Some IDE\u2019s can be configured to automatically remove them and most VCS tools can be set to highlight them in diff outputs.</li> </ul>"},{"location":"devel/development/#git-messages","title":"Git Messages","text":"<p>We practice the following conventions for commit messages:</p> <pre><code>&lt;scope&gt;: [&lt;type&gt;] &lt;subject&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;scope&gt;</code>: The scope of the change.</li> <li><code>&lt;type&gt;</code>: The type of the change.</li> <li><code>&lt;subject&gt;</code>: A short description of the change.</li> </ul>"},{"location":"devel/development/#scopes","title":"Scopes","text":"<p>The following scopes are typical:</p> Scope Description <code>all</code> Changes that affect the entire project (e.g., major refactoring) <code>root</code> Root directory changes (e.g., readme, git, author list) <code>fuzz</code> Changes to the core fuzzer algorithm. <code>cli</code> Changes to the command-line interface. <code>exec</code> Changes to the executor. <code>model</code> Changes to the model. <code>analyser</code> Changes to the analyser. <code>mini</code> Changes to the postprocessor (i.e., minimizer). <code>gen</code> Changes to the program generator <code>input_gen</code> Changes to the input generator <code>tests</code> Changes to the tests <code>isa</code> Changes to the ISA loader or to <code>get_spec</code> files <p>If a commit covers several scopes, use the most relevant one.</p> <p>If a commit targets a specific architecture (e.g., x86), add the architecture to the scope (e.g., <code>fuzz/x86</code>).</p>"},{"location":"devel/development/#types","title":"Types","text":"<p>Use one of the following types:</p> Type Description <code>feat</code> A new feature. <code>fix</code> A bug fix. <code>docs</code> Documentation changes. <code>chore</code> Changes to the build process or auxiliary tools. <code>ft</code> Fault tolerance changes (e.g., adding error handling or recovery mechanisms). <code>refact</code> Refactoring of the codebase. This includes code style change. <code>perf</code> Performance improvements. <code>revert</code> Reverts a previous commit. <p>If possible, try to use only these types. If you need to use a different type, please discuss it with a maintainer.</p>"},{"location":"devel/development/#git-branches","title":"Git Branches","text":"<p>We practice the git workflow, with a few modifications.</p> <p></p> <p>We use the following branches for graduation:</p> <ul> <li><code>main</code>: The latest release. This branch should always be stable, and it is the last branch to receive changes.</li> <li><code>main-fixes</code>: Commits that go in the next maintenance release. This branch is created from the last release branch.</li> <li><code>pre-release</code>: Stable commits that go in the next release.</li> <li><code>dev</code>: The development branch. This branch is the first to receive changes.</li> </ul> <p>Commits should be merged upwards:</p> <ul> <li><code>dev</code> -&gt; <code>pre-release</code> -&gt; <code>main</code></li> <li>In case of hot fixes, <code>main-fixes</code> -&gt; <code>main</code> AND <code>main-fixes</code> -&gt; <code>pre-release</code></li> </ul> <p>For working on unstable code (e.g., progress on features or bug fixes), use either forks or feature branches. Use forks if you are the only one working on the feature, and use a pull request to merge the changes back into the main repository. Use a feature branch if multiple people are working on the feature, in which case name the branch <code>feature-&lt;name&gt;</code> or <code>bugfix-&lt;name&gt;</code>, and make sure to branch from the <code>dev</code> branch.</p> <p>The only exception is the <code>gh-pages</code> branch, which is used for the project's website. This branch is used by automated tools and should never be used for development.</p>"},{"location":"devel/dr-model/","title":"DynamoRIO-based Model Backend","text":"<p>This document describes the DynamoRIO-based model. As any other model, this backend is responsible for collecting contract traces for generated test cases.</p>"},{"location":"devel/dr-model/#design-overview","title":"Design Overview","text":"<p>This backend is composed of several parts: The Python adapter (<code>src/model_dynamorio/model.py</code>) is responsible for receiving a test case from Revizor, transforming it into a format that can be executed by the backend, triggering the backend to execute the test case, and returning the collected contract traces to Revizor. The Test Case Loader (<code>src/model_dynamorio/adapter.c</code>) is a C program that loads a test case program and a single input into its memory, and simply executes its. The DynamoRIO components (<code>src/model_dynamorio/backend</code>) are executed together with the test case loader, and they instrument the loader binary to collect contract traces. These components can be roughly divided into the instrumentation-time components that are responsible for modifying the binary, and execution-time components that implement the model logic (i.e., the contract).</p> <p></p>"},{"location":"devel/dr-model/#python-adapter","title":"Python Adapter","text":"<p>Revizor communicates with the backend through a Python adapter (<code>src/model_dynamorio/model.py:DynamoRIOModel</code>).</p> <p>At the beginning of the fuzzing process, Revizor configures the backend by calling <code>configure_clauses</code> method. This configuration will be later passed down to the backend when the test case is executed.</p> <p>During the fuzzing process, Revizor sends test cases to the backend by calling <code>load_test_case</code> method, and then triggers the backend to execute the test case by calling <code>trace_test_case</code> method. Internally, <code>trace_test_case</code> will call the backend to execute the test case and collect the contract traces. The adapter will then parse the traces and return them back to the caller.</p> <p>The <code>trace_test_case</code> method implements the following algorithm: - Convert test case program and inputs into RCBF and RDBF files, respectively - For each input, call the test case loader with the RCBF and RDBF files. Attach the DynamoRIO backend to the call so that the binary instrumentation is performed: <pre><code>~/.local/dynamorio/drrun -c ~/.local/dynamorio/libdr_model.so --tracer &lt;observation-clause&gt; -- ~/.local/dynamorio/adapter &lt;rcbf&gt; &lt;rdbf&gt;\n</code></pre> - Receive contract traces from the backend and convert them into <code>CTrace</code> objects - Return the list of collected <code>CTrace</code> objects to the caller (usually, <code>fuzzer.py</code>)</p>"},{"location":"devel/dr-model/#test-case-loader","title":"Test Case Loader","text":"<p>Since the test cases produced by Revizor are raw binaries, they cannot be directly executed (e.g., they don't have <code>libc</code> linked). The test case loader (<code>src/model_dynamorio/adapter.c</code>) is a simple C program that fixes this issue by providing a wrapper around the test case binary.</p> <p>The loader implements the following algorithm: - Receive the test case binary and an input from the Python adapter via CLI arguments - Load the test case binary and the input into dedicated memory regions - Print the addresses of the test case and input memory regions (for trace normalization) - Initialize registers based on the input - Jump to the test case binary entry point - Return</p>"},{"location":"devel/dr-model/#dynamorio-tool","title":"DynamoRIO Tool","text":"<p>The DynamoRIO tool (<code>src/model_dynamorio/backend</code>) is responsible for instrumenting the test case loader binary and collecting contract traces.</p>"},{"location":"devel/dr-model/#instrumentation-components","title":"Instrumentation Components","text":"<p>The instrumentation components modify the binary of the test case loader by adding a call to the function <code>dispatch_callback</code> before every instruction in the binary (or more specifically, every instruction in the <code>test_case_entry</code> function of the loader).</p> <p>The tool interacts with DynamoRIO through the <code>model.cpp</code> module. This module registers an event for entering the <code>test_case_entry</code>, which triggers the start of instrumentation. The module also registers an event for every instruction in the <code>test_case_entry</code>, and the event in turn calls the <code>Dispatch::instrument_instruction()</code>.</p> <p>The <code>Dispatch</code> class implements the actual instrumentation logic. When the <code>instrument_instruction()</code> method is called, it inserts a clean call to the <code>dispatch_callback</code> function before the instruction. The call receives the PC and opcode of the instruction as arguments. DynamoRIO also automatically saves the complete register state before the call, thus making it available to <code>dispatch_callback</code>.</p>"},{"location":"devel/dr-model/#execution-time-components","title":"Execution-Time Components","text":"<p>The execution-time components are responsible for implementing the contract logic, and are triggered by the <code>dispatch_callback</code> function. At the current state of the backend, the dispatch callback invokes only two classes, Tracer and Speculator, that implement the observation and execution clauses, respectively.</p> <p>Subclasses of <code>TracerABC</code> record contract-relevant information via <code>observe_instruction</code> and <code>observe_mem_access</code> methods. E.g., <code>TracerCT</code> implements <code>CT</code> observation clause by recording the PC of instructions upon <code>observe_instruction</code> and the address of memory accesses upon <code>observe_mem_access</code>.</p> <p>Subclasses of <code>SpeculatorABC</code> implement the contract speculation logic. E.g., <code>SpeculatorCond</code> implements <code>speculate_instruction</code>. When this method is called with a branch instruction, the class takes a checkpoint of the process state, flips the branch condition (i.e., modified <code>FLAGS</code> register), and continues the execution. During the simulated speculation, each call to <code>speculate_instruction</code> counts the number of executed instructions, and when the number reaches the limit (e.g., 256), the class restores the checkpoint and continues the execution from the original state. (Actually, the algorithm is more complex, but this is the general idea.)</p> <p>When the instrumentation ends (according to <code>model.cpp</code>), the tracer's <code>tracing_finalized</code> method is called, and the tracer prints the collected traces to <code>stdout</code> in a compressed binary format. The Python adapter picks up this output, decodes, and returns it to Revizor.</p>"},{"location":"devel/how-revizor-works/","title":"How Revizor works","text":""},{"location":"devel/how-revizor-works/#revizor-in-a-nutshell","title":"Revizor in a nutshell","text":"<p>Revizor is a tool for detecting unexpected microarchitectural leakage in CPUs. Microarchitectural leakage means the information that an attacker could learn by launching a microarchitectural side-channel attack (e.g., Spectre or Meltdown). The expected microarchitectural leakage is the leakage that we already know about (i.e., known microarchitectural vulnerabilities). We describe the expected leakage in a form of a Speculation Contract (see below). Accordingly, the unexpected leakage is any leakage not described pby a contract - we call it a contract violation. Revizor's task is to find such violations.</p>"},{"location":"devel/how-revizor-works/#speculation-contracts","title":"Speculation Contracts","text":"<p>Below is a brief intro to Contracts. You can find a more detailed description in the original paper and in the Background section of the Revizor paper.</p>"},{"location":"devel/how-revizor-works/#microarchitectural-leakage-and-hardware-traces","title":"Microarchitectural Leakage and Hardware Traces","text":"<p>Consider two programs, an attacker and a victim. The attacker launches a microarchitectural side-channel attack (e.g., a cache side channel) to spy on the victim and learn some of its data. A hardware trace is a sequence of all the observations made through this side-channel after each instruction during the victim's execution. In other words, hardware trace is the result for a side-channel attack.</p> <p>We abstractly represent the hardware trace as the output of a function</p> <p>\ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 = \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc36\ud835\udc61\ud835\udc65)</p> <p>that takes three input parameters: (1) the victim program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54; (2) the input \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e processed by the victim\u2019s program (i.e., the architectural state including registers and main memory); (3) the microarchitectural context \ud835\udc36\ud835\udc61\ud835\udc65 in which it executes. The information exposed by a hardware trace depends on the assumed side-channel and threat model.</p> <p>Example: If the threat model includes attacks on a data cache, \ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 is composed of the cache set indexes used by \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54\u2019s loads and stores. If it includes attacks on an instruction cache, \ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 contains the addresses of executed instructions.</p> <p>A program leaks information via side-channels when its hardware traces depend on the inputs (\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e): We assume the attacker knows \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54 and can manipulate \ud835\udc36\ud835\udc61\ud835\udc65, hence any difference between the hardware traces implies difference in \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e, which effectively exposes information to the attacker.</p>"},{"location":"devel/how-revizor-works/#whats-a-speculation-contract","title":"What's a Speculation Contract?","text":"<p>A speculation contract specifies the information that can be exposed by a CPU during a program execution under a given threat model. For each instruction in the CPU ISA (or a subset thereof), a contract describes the information exposed by the instruction\u2019s (observation clause) and the externally-observable speculation that the instruction may trigger (execution clause). When a contract covers a subset of ISA, the leakage of unspecified instructions is undefined.</p> <p>Example: consider the contract summarized in the next table:</p> Observation Clause Execution Clause Load Expose Address - Store Expose Address - Cond. Jump - Mispredict Target Other - - <p>We call this contract MEM-COND. Through the observation clauses of loads and stores, the contract prescribes that addresses of all memory access may be exposed (hence MEM). The execution clause of conditional branches describes their misprediction, thus the contract prescribes that branch targets may be mispredicted (hence COND). This way, the contract models a data cache side channel on a CPU with branch prediction.</p> <p>A contract trace \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 contains the sequence of all the observations the contract allows to be exposed after each instruction during a program execution, including the instructions executed speculatively. Conversely, the information that is not exposed via \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 is supposed to be kept secret.</p> <p>We abstractly represent a contract as a function \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61 that maps the program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54 and its input \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e to a contract trace \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52:</p> <p>\ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 = \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e)</p> <p>Example: Consider the following program:</p> <p><pre><code>z = array1[x] # base of array1 is 0x100\nif y &lt; 10:\n    z = array2[y] # base of array2 is 0x200\n</code></pre> It is executed with an input <code>data={x=10,y=20}</code>. The MEM-COND contract trace is <code>ctrace=[0x110,0x220]</code>, representing that the load at line 1 exposes the accessed address during normal execution, and the load at line 3 exposes its address during speculative execution triggered by the branch at line 2.</p> <p>A CPU complies with a contract when its hardware traces (collected on the actual CPU) leak at most as much information as the contract traces. Formally, we require that whenever any two executions of any program have the same contract trace (implying the difference between inputs is not exposed), the respective hardware traces should also match.</p> <p>A CPU complies with a \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61 if, for all programs \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54, all input pairs (\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032), and all initial microarchitectural states \ud835\udc36\ud835\udc61\ud835\udc65:</p> <p>\ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e) = \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032) -&gt; \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc36\ud835\udc61\ud835\udc65) = \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032,\ud835\udc36\ud835\udc61\ud835\udc65)</p> <p>Conversely, a CPU violates a contract if there exists a program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54, a microarchitectural state Ctx, and two inputs \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032 that agree on their contract traces but disagree on the hardware traces. We call the tuple (\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc36\ud835\udc61\ud835\udc65,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032) a contract counterexample. The counterexample witnesses that an adversary can learn more information from hardware traces than what the contract specifies. A counterexample indicates a potential microarchitectural vulnerability that was not accounted for by the contract.</p>"},{"location":"devel/how-revizor-works/#model-based-relational-testing","title":"Model-based Relational Testing","text":"<p>To find contract violations, we use the following approach, which we call Model-based Relational Testing (MRT).</p> <p>The next figure show the main components of MRT:</p> <p></p> <p>Test case and input generation. We sample the search space of programs, inputs and microarchitectural states to find counterexamples. The generated instruction sequences (test cases) are comprised of the ISA subset described by the contract. The test cases and respective inputs to them are generated to achieve high diversity and to increase speculation or leakage potential.</p> <p>Collecting contract traces. We implement an executable Model of the contract to allow automatic collection of contract traces for standard binaries. For this, we modify a functional CPU emulator to implement speculative control flow based on a contract\u2019s execution clause, and to record traces based on its observation clause.</p> <p>Collecting hardware traces. We collect hardware traces by executing the test case on the CPU under test and measuring the observable microarchitectural state changes during the execution according to the threat model. The executor employs several methods to achieve consistent and repeatable measurements.</p> <p>Relational Analysis. Based on the collected contract and hardware traces, we identify contract violations. Namely, we search for pairs of inputs that match the following:</p> <pre><code>ContractTrace1 == ContractTrace2\n               and\nHardwareTrace1 != HardwareTrace2\n</code></pre> <p>This requires relational reasoning: * We partition inputs into groups, which we call input classes. All inputs within a class have the same contract trace. Thus, input classes correspond to the equivalence classes of equality on contract traces. Classes with a single (ineffective) input are discarded. * For each class, we check if all inputs within a class have the same hardware trace.</p> <p>If the check fails on any of the classes, we found a counterexample that witnesses contract violation.</p>"},{"location":"devel/how-revizor-works/#revizor","title":"Revizor","text":"<p>Revizor implements the MRT approach for black-box CPUs. The implementation details are described in Revizor Architecture.</p>"},{"location":"devel/macros/","title":"Macros","text":"<p>UNDER CONSTRUCTION</p>"},{"location":"devel/registers/","title":"Register Allocation","text":"<p>The test cases are executed in a sandboxed environment, where some of the registers are reserved for internal use, and some are available for use in the test cases. Below is a list of registers and their purpose.</p>"},{"location":"devel/registers/#r15","title":"<code>R15</code>","text":"<p>Contains the base address of the UTILITY area in the sandbox.</p> <p>If the test case does not enter a VM, the register value remains constant during the execution of the test cases. Otherwise, the register value is updated to point to the UTILITY area of the currently active VM when the <code>switch_h2g</code> macro is called, and it is restored to the original value when the <code>switch_g2h</code> macro is called.</p> <p>The register is used by internal functions, such as the implementation of Prime+Probe.</p>"},{"location":"devel/registers/#r14","title":"<code>R14</code>","text":"<p>Contains the base address of the current actor's sandbox (namely, it points to the base of the actor's MAIN area).</p> <p>At the beginning of the test case execution, the register is set to the base address of the MAIN area of the first actor (actor <code>main</code>). The register value is updated to point to the MAIN area of the currently active actor when a macro from the <code>landing_*</code> group of macros is called. It is also updated by the <code>fault_handler</code> macro.</p> <p>The register is used in test cases as a part of the sandboxing mechanism. For example, all generated memory accesses are relative to the value stored in <code>R14</code>, and have the form of <code>[R14 + offset]</code>.</p>"},{"location":"devel/registers/#r13-htrace_register-constant-in-the-kernel-module","title":"<code>R13</code> (<code>HTRACE_REGISTER</code> constant in the kernel module)","text":"<p>Contains either intermediate or final result of the hardware trace measurements.</p> <p>Before entering the test case, the register is set to 0. When a <code>measurement_start</code> macro is executed, the register is (optionally) set to the starting value, such a initial reading of time stamp counter when the <code>TSC</code> mode is used. When a <code>measurement_end</code> macro is executed, the register is updated with the final value of the measurement and contains the resulting hardware trace.</p>"},{"location":"devel/registers/#r12-status_register-constant-in-the-kernel-module","title":"<code>R12</code> (<code>STATUS_REGISTER</code> constant in the kernel module)","text":"<p>Contains a compressed status of the test case execution:</p> <p>Bits[0:7] contain a measurement status. At the beginning of the test case execution, the bits are set to 0. When <code>measurement_start</code> macro is executed, the bits are set to 1. When <code>measurement_end</code> macro is executed, the bits are set to 2. If the measurement status is not 2 at the end of the test case execution, the kernel module will report an error.</p> <p>Bits[8:31] are unused.</p> <p>Bits[32:63] contain a counter of SMI (System Management Interrupt) events. The counter is set automatically before entering the test case (<code>READ_SMI_START</code>), and updated when the test case finishes (<code>READ_SMI_END</code>). If the difference between the readings is not 0, the kernel module will report an error.</p>"},{"location":"devel/registers/#r11","title":"<code>R11</code>","text":"<p>The register is used as a temporary buffer by some of the macros.</p> <p>Before entering the test case, the register is set to 0. When certain macros are executed (e.g., <code>set_k2u_target</code>), the register will contain temporary values. The register should not be used in the test case, as the temporary value may be consumed by latter macros.</p>"},{"location":"devel/registers/#r10-r9-r8","title":"<code>R10, R9, R8</code>","text":"<p>Stores the values of performance counters. <code>R10</code> stores the value of performance counter #1, <code>R9</code> stores the value of performance counter #2, and <code>R8</code> stores the value of performance counter #3.</p> <p>Before entering the test case, the registers are set to 0. When a <code>measurement_start</code> macro is executed, the registers are (optionally) set to the starting values. When a <code>measurement_end</code> macro is executed, the registers are updated with the final values of the measurements.</p>"},{"location":"devel/registers/#other-general-purpose-registers","title":"Other General Purpose Registers","text":"<p>The remaining registers (<code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>rflags</code>) are available for use in the test cases and can be modified freely. A special case are <code>rsp</code> and <code>rbp</code>, which can be used in the test cases, but their values must always remain within the sandbox (see Sandbox).</p>"},{"location":"devel/registers/#vector-registers","title":"Vector Registers","text":"<p>Vector registers (<code>xmm0</code>-<code>xmm15</code>) are also available for use in the test cases. However, only <code>xmm0-xmm7</code> are initialized with input-based values, and the remaining registers are always zero-initialized.</p> <p>Large-size vector registers (<code>ymm</code> and <code>zmm</code>) are not supported.</p>"},{"location":"devel/sandbox/","title":"Test Case Sandbox","text":"<p>This document describes the isolated environment for executing test cases, which is referred to as the sandbox. The sandbox contains the test case code and data, and the test case code is confined to access memory only within the sandbox.</p> <p>The sandbox is implemented by all modules that execute test cases, including the executor (kernel module) and all model backends (Unicorn, DynamoRIO). To ensure that the executions are consistent across all modules, the sandbox is structured in the same way in all the modules.</p> <p>This document describes the memory layout of the sandbox, the initialization of the sandbox memory, and the fault isolation mechanism.</p>"},{"location":"devel/sandbox/#memory-layout","title":"Memory Layout","text":"<p>The sandbox memory is divided into two main areas: the data sandbox and the code sandbox. Each actor in the test case has its own sub-area for its data and code, and the layout of these areas is the same for all actors.</p>"},{"location":"devel/sandbox/#data-layout","title":"Data Layout","text":"<pre><code>|----------|--------------------|\n| ACTOR 0  | MACRO STACK        | 64 B\n|          |--------------------|\n|          | UNDERFLOW PAD      | 4032 B\n|          |--------------------|\n|          | MAIN AREA          | 4096 B\n|          |--------------------|\n|          | FAULTY AREA        | 4096 B\n|          |--------------------|\n|          | GPR AREA           | 64 B\n|          |--------------------|\n|          | SIMD AREA          | 256 B\n|          |--------------------|\n|          | OVERFLOW PAD       | 3776 B\n|----------|--------------------|\n| ... (repeat for all actors in the test case)\n</code></pre> <p>The data area is divided into the following regions: * Main and Faulty Areas: These are the two regions of memory that are accessible by the test case code.   This is enforced by the test case generator, which instruments all memory accesses to ensure that they fall within these regions (see code-generation for more details).   Both areas are initialized with the input data from the RBDF.   The main area always has default permissions (RW), while the faulty area has permissions can be configured to cause a fault when accessed.   This configuration originates from the config file. * GPR and SIMD Areas: These regions store the values that will be used by the modules to initialize the general-purpose registers (GPR) and SIMD registers before executing the test case and when switching between actors.   Both areas are initialized with the input data from the RBDF. * Over- and Underflow Pads: These two zero-initialized regions surround the actors' data areas, and their purpose is to determinize the hardware traces on the executor.   Namely, they are needed for the cases when the CPU speculatively bypasses the sandboxing instrumentation inserted by the test case generator, and the bypass leads to an out-of-bounds memory access.   As the pads are zero-initialized, the bypassed memory accesses will produce deterministic results. * Macro stack: This region is used to implement complex macros (e.g., VMENTER) that need to save and restore data on the stack with a guarantee that this data won't be corrupted by the following (randomly-generated) instructions (see macros for more details.)</p>"},{"location":"devel/sandbox/#code-layout","title":"Code Layout","text":"<pre><code>|----------|--------------------|\n| ACTOR 0  | MAIN CODE AREA     | 8192 B\n|          |--------------------|\n|          | MACRO CODE AREA    | 4096 B\n|----------|--------------------|\n| ... (repeat for all actors in the test case)\n</code></pre> <p>The code area is divided into two regions: * Main Code Area: This region contains the binary of the actor's code.   The code comes from the RCDF file.   The first instruction in the code area of actor 0 is the entry point of the test case, and the last instruction of actor 0 is the exit point of the test case. * Macro Code Area: This region contains code of the expanded macros for each actor.   (see macros for more details on the macro expansion process.)</p>"},{"location":"devel/sandbox/#references","title":"References","text":"<ul> <li>Executor: src/x86/executor/include/sandbox_manager.h</li> <li>Unicorn backend: src/sandbox.py</li> </ul>"},{"location":"devel/sandbox/#sandbox-initialization","title":"Sandbox Initialization","text":"<p>The sandbox is initialized based on the test case code (normally in RCBD format) and the input data (normally in RDBF format). The following diagram shows the mapping between the RCBF/RDBF files and the sandbox memory layout:</p> <pre><code>                                        |--------------------|\n                   zero initialized -&gt;  | MACRO STACK        |\n                                        |--------------------|\n                   zero initialized -&gt;  | UNDERFLOW PAD      |\n                                        |--------------------|\n      RDBF.data[actor_id].main_area -&gt;  | MAIN AREA          |\n                                        |--------------------|\n    RDBF.data[actor_id].faulty_area -&gt;  | FAULTY AREA        |\n                                        |--------------------|\nRDBF.data[actor_id].reg_init_region -&gt;  | GPR AREA           |\n                                        |--------------------|\nRDBF.data[actor_id].reg_init_region -&gt;  | SIMD AREA          |\n                                        |--------------------|\n                   zero initialized -&gt;  | OVERFLOW PAD       |\n                                        |--------------------|\n\n\n     RCBF.tc_section[actor_id].code -&gt;  | MAIN CODE AREA     |\n                                        |--------------------|\n     expanded macro code (executor) -&gt;  | MACRO CODE AREA    |\n</code></pre>"},{"location":"devel/sandbox/#fault-isolation","title":"Fault Isolation","text":"<p>UNDER CONSTRUCTION</p>"},{"location":"user/cli/","title":"Command-Line Interface","text":"<p>Revizor is controlled via two interfaces: command line and configuration file. Command line arguments specify the mode of operation and set high-level parameters (e.g., file paths, number of fuzzing rounds). Configuration files specify details of the fuzzing campaign (e.g., the target contract, generation parameters, etc).</p> <p>This document describes the command-line interface. For information on configuration files, see the configuration documentation.</p>"},{"location":"user/cli/#modes","title":"Modes","text":"<p>The command line options depend on the selected mode of operation (see modes page for their descriptions). To select a mode on the command-line, begin your command with:</p> <pre><code>rvzr MODE # ... arguments go here\n\n# Where MODE can be:\n#   fuzz            fuzzing mode\n#   tfuzz           template fuzzing mode\n#   reproduce       reproduce mode\n#   minimize        test case minimization mode\n#   analyse         stand-alone trace analysis mode\n#   generate        stand-alone generation mode\n#   download_spec   call the script that downloads the instruction set specification\n</code></pre>"},{"location":"user/cli/#fuzzing-mode","title":"Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>fuzz</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  -t TESTCASE, --testcase TESTCASE\n                        Use an existing test case [DEPRECATED - see reproduce]\n  --timeout TIMEOUT     Run fuzzing with a time limit [seconds]. No timeout when set to zero.\n  --nonstop             Don't stop after detecting an unexpected result\n  --save-violations SAVE_VIOLATIONS\n                        If set, store all detected violations in working directory.\n</code></pre>"},{"location":"user/cli/#template-fuzzing-mode","title":"Template Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>analyse</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  -t TEMPLATE, --template TEMPLATE\n                        The template to use for generating test cases\n  --timeout TIMEOUT     Run fuzzing with a time limit [seconds]. No timeout when set to zero.\n  --nonstop             Don't stop after detecting an unexpected result\n  --save-violations SAVE_VIOLATIONS\n                        If set, store all detected violations in working directory.\n</code></pre>"},{"location":"user/cli/#reproduce-mode","title":"Reproduce Mode","text":"<p>The following command-line arguments are supported in <code>reproduce</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -t TESTCASE, --testcase TESTCASE\n                        Path to the test case\n  -i [INPUTS ...], --inputs [INPUTS ...]\n                        Path to the directory with inputs\n  -n NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case. [IGNORED if --input-dir is set]\n</code></pre>"},{"location":"user/cli/#minimize-mode","title":"Minimize Mode","text":"<p>The following command-line arguments are supported in <code>minimize</code> mode. See also the minimization documentation for a list of available minimization passes.</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  --testcase TESTCASE, -t TESTCASE\n                        Path to the test case program that needs to be minimized.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs to the program that will be used during minimization.\n  --testcase-outfile TESTCASE_OUTFILE, -o TESTCASE_OUTFILE\n                        Output path for the minimized test case program.\n  --input-outdir INPUT_OUTDIR\n                        Output directory for storing minimized inputs.\n  --num-attempts NUM_ATTEMPTS\n                        Number of attempts to minimize the test case.\n  --enable-&lt;pass&gt;       Enable a specific pass during minimization.\n</code></pre>"},{"location":"user/cli/#stand-alone-trace-analysis-mode","title":"Stand-alone Trace Analysis Mode","text":"<p>The following command-line arguments are supported in <code>analyse</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  --ctraces CTRACES\n  --htraces HTRACES\n</code></pre>"},{"location":"user/cli/#stand-alone-generation-mode","title":"Stand-alone Generation Mode","text":"<p>The following command-line arguments are supported in <code>generate</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -r SEED, --seed SEED  Add seed to generate test case.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  --permit-overwrite    Permit overwriting existing files.\n</code></pre>"},{"location":"user/cli/#download-instruction-set-specification","title":"Download Instruction Set Specification","text":"<p>The following command-line arguments are supported in <code>download_spec</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -a ARCHITECTURE, --architecture ARCHITECTURE   The ISA to download the specification for (e.g., x86-64)\n  --outfile OUTFILE, -o OUTFILE   The destination file to save the downloaded specification.\n  --extensions [EXTENSIONS ...]   List of ISA extensions to include in the specification (e.g., SSE, VTX)\n</code></pre>"},{"location":"user/config/","title":"Configuration File","text":"<p>Below is a list of the available configuration options for Revizor, which are passed down to Revizor via a config file. For an example of how to write the config file, see src/tests/big-fuzz.yaml.</p>"},{"location":"user/config/#fuzzing-configuration","title":"Fuzzing Configuration","text":"<pre><code>Name: fuzzer\nDefault: 'basic'\nOptions: 'basic' | 'architectural' | 'archdiff'\n</code></pre> <p>This option selects the fuzzing mode. The available options are:</p> <ul> <li><code>basic</code> - normal model-based fuzzing. A violation in this mode indicates that the CPU exposes more information than predicted by the contract. This option should be used in most testing campaigns.</li> <li><code>architectural</code> - self-fuzzing for architectural mismatches between the model and the executor. This option should be used for testing the fuzzer itself, i.e., a violation in this mode indicates a bug in the fuzzer rather then a bug in the CPU. This is useful when running the fuzzer with a previously-untested instruction set, or when a new contract is implemented.</li> <li><code>archdiff</code> - fuzzing for architectural invariants. This is a special mode targeted for for semi-microarchitectural violations, similar to ZenBleed. This mode is experimental and should be used with caution.</li> </ul> <pre><code>Name: enable_priming\nDefault: True\n</code></pre> <p>This option enables or disables priming. This options should be set to True in most cases, as priming is crucial for eliminating false positives.</p> <p>Priming solves the following problem: Revizor collects hardware traces for inputs in a sequence, and the microarchitectural state is not reset between the inputs. This means that the microarchitectural state for the input at, for example, position 100 is different from the state for the input at position 200. Accordingly, the hardware traces for these inputs may differ because the measurements are taken in different microarchitectural contexts.</p> <p>To address this issue, we uses priming, which swaps the inputs in the sequence and re-runs the tests. For example, if the original sequence is (i1 . . . i99,i100,i101 . . . i199,i200), the priming sequence will be (i1 . . . i99,i200,i101 . . . i199,i100). If the violation persists in this sequence, it is a true positive. If the violation disappears, it is a false positive, and it will be discarded.</p> <pre><code>Name: enable_speculation_filter\nDefault: False\n</code></pre> <p>If enabled, Revizor will discard test cases that do not trigger speculation.</p> <p>This option is useful for improving the throughput of the fuzzer, but it can discard potential violations if the leakage is not caused by speculation.</p> <pre><code>Name: enable_observation_filter\nDefault: False\n</code></pre> <p>If enabled, Revizor will discard test cases that do not leave speculative traces. The filtering is performed by adding an <code>LFENCE</code> after each instruction in the test case, and comparing the resulting hardware traces with the original. If the traces are identical, the test case is discarded.</p> <p>This option is useful for improving the throughput of the fuzzer, but it can discard potential violations if the leakage is not caused by speculation.</p> <pre><code>Name: enable_fast_path_model\nDefault: True\n</code></pre> <p>If enabled, the same contract trace will be used for all inputs in the same taint-based input class.</p> <pre><code>Name: color\nDefault: False\n</code></pre> <p>If enabled, the output will be colored. This option is helps a lot with readability, but may produce corrupted output when redirected to a file.</p> <pre><code>Name: logging_modes\nDefault: ['info', 'stat']\nOptions: 'info' | 'stat' | 'dbg_timestamp' | 'dbg_violation' | 'dbg_dump_htraces' | 'dbg_dump_ctraces' | 'dbg_dump_traces_unlimited' | 'dbg_executor_raw' | 'dbg_model' | 'dbg_coverage' | 'dbg_generator' | 'dbg_priming'\n</code></pre> <p>This option controls the output:</p> <ul> <li><code>info</code> - general information about the progress of fuzzing;</li> <li><code>stat</code> - statistics the end of the fuzzing campaign;</li> <li><code>dbg_timestamp</code> - every 1000 test cases print the timestamp during the fuzzing process;</li> <li><code>dbg_violation</code> - upon detecting a violation, print detailed information about it;</li> <li><code>dbg_dump_htraces</code> - print the first 100 hardware traces for every test case;</li> <li><code>dbg_dump_ctraces</code> - print the first 100 contract traces for every test case;</li> <li><code>dbg_dump_traces_unlimited</code> - print ALL traces (use carefully, produces LOTS of text);</li> <li><code>dbg_executor_raw</code> - prints hardware traces for every stage of the fuzzing process;   this differs from <code>dbg_dump_htraces</code> in that it prints the traces collected by   speculation/observation filters as well as at every iteration of multi-sample collection;</li> <li><code>dbg_model</code> - print a detailed info about EVERY instruction executed on the model (use carefully, produces LOTS of text);</li> <li><code>dbg_coverage</code> - stores instruction coverage information;</li> <li><code>dbg_generator</code> - prints a list of instructions used to generate test cases;</li> <li><code>dbg_priming</code> - prints information about the priming process; only useful for debugging the priming mechanism itself.</li> </ul> <pre><code>Name: multiline_output\nDefault: False\n</code></pre> <p>If enabled, each output message will be printed on a separate line. Otherwise, the fuzzing progress will be continuously overwriting the same line (works only in the terminal).</p>"},{"location":"user/config/#program-generator-configuration","title":"Program Generator Configuration","text":"<pre><code>Name: instruction_set\nDefault: 'x86-64'\nOptions: 'x86-64'\n</code></pre> <p>The instruction set under test. Currently, only x86-64 is supported.</p> <pre><code>Name: instruction_categories\nDefault: ['BASE-BINARY', 'BASE-BITBYTE', 'BASE-COND_BR']\nOptions: (depends on model backend; see &lt;isa&gt;_config.py for details)\n</code></pre> <p>Select a list of instruction categories to be used when generating programs. This list effectively filters out instructions from the ISA descriptor file (e.g., <code>base.json</code>) passed via the command line (<code>-s</code>).</p> <pre><code>Name: instruction_blocklist\nDefault: ['enterw', 'enter', 'leavew', 'leave', 'int', 'encls', 'vmxon', 'stgi', 'skinit', 'ldmxcsr', 'stmxcsr', 'lfence', 'mfence', 'sfence', 'clflush', 'clflushopt', 'divps', 'divss', 'divpd', 'divsd', 'mulss', 'mulps', 'mulpd', 'mulsd', 'rsqrtps', 'rsqrtss', 'sqrtps', 'sqrtss', 'sqrtpd', 'sqrtsd', 'addps', 'addss', 'addpd', 'addsd', 'subps', 'subss', 'subpd', 'subsd', 'addsubpd', 'addsubps', 'haddpd', 'haddps', 'hsubpd', 'hsubps', 'sti', 'cli', 'xlat', 'xlatb', 'cmpxchg8b', 'lock cmpxchg8b', 'cmpxchg16b', 'lock cmpxchg16b', 'cpuid', 'cmpps', 'cmpss', 'cmppd', 'cmpsd', 'movq2dq', 'movdq2q', 'rcpps', 'rcpss', 'pcmpestriq', 'pcmpestrmq', 'vpcmpestriq', 'vpcmpestrmq', 'maskmovdqu', 'maskmovq', 'vmaskmovdqu', 'vmaskmovq']\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions that will NOT be used for generating programs. This list filters out instructions from <code>instruction_categories</code>, but not from <code>instruction_allowlist</code>.</p> <p>The resulting instruction pool is:      (instructions from instruction_categories - instruction_blocklist) + instruction_allowlist</p> <p>The instructions that are blocked by default are known to cause issues in the model or executor, and hence should generally be avoided when fuzzing.</p> <pre><code>Name: instruction_blocklist_append\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions that will be appended to the default instruction blocklist. This option is identical to <code>instruction_blocklist</code>, but the list is added to the previous blocklist instead of replacing it. This is useful when you want to block some instructions in addition to the default blocklist.</p> <pre><code>Name: instruction_allowlist\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions to use for generating programs. This list has priority over <code>instruction_categories</code> and over <code>instruction_blocklist</code>, thus adding instructions on top of the categories.</p> <p>The resulting instruction pool is:      (instructions from instruction_categories - instruction_blocklist) + instruction_allowlist</p> <pre><code>Name: program_generator_seed\nDefault: 0\n</code></pre> <p>Seed of the program generator. If set to zero, a random seed will be used for each run.</p> <pre><code>Name: program_size\nDefault: 24\n</code></pre> <p>Number of instructions per program. The actual size might be larger because of the instrumentation.</p> <pre><code>Name: avg_mem_accesses\nDefault: 12\n</code></pre> <p>Average number of memory accesses in generated programs. The actual number will be random, but the average over all programs will be close to this value.</p> <pre><code>Name: min_bb_per_function\nDefault: 1\n</code></pre> <p>Minimal number of basic blocks per function in generated programs.</p> <pre><code>Name: max_bb_per_function\nDefault: 2\n</code></pre> <p>Maximal number of basic blocks per function in generated programs.</p> <pre><code>Name: min_successors_per_bb\nDefault: 1\n</code></pre> <p>Minimal number of successors for each basic block in generated programs.</p> <p>Note 1: this config option is a hint; it could be ignored if the instruction set does not have the necessary instructions to satisfy it, or if a certain number of successor is required for correctness</p> <p>Note 2: If min_successors_per_bb &gt; max_successors_per_bb, the value is overwritten with max_successors_per_bb</p> <pre><code>Name: max_successors_per_bb\nDefault: 1\n</code></pre> <p>Maximal number of successors for each basic block in generated programs.</p> <p>Note: this config option is a hint; it could be ignored if the instruction set does not have the necessary instructions to satisfy it, or if a certain number of successor is required for correctness</p> <pre><code>Name: register_allowlist\nDefault: []\nOptions: (any register names)\n</code></pre> <p>A list of registers that CAN be used for generating programs.</p> <p>This list has higher priority than <code>register_blocklist</code>. The resulting list is: (all registers - <code>register_blocklist</code>) + <code>register_allowlist</code>.</p> <pre><code>Name: register_blocklist\nDefault: (all but RAX, RBX, RCX, RDX, RDI, RSI, XMM0-XMM7)\nOptions: (any register names)\n</code></pre> <p>A list of registers that will NOT be used for generating programs.</p> <p>This list has lower priority than <code>register_allowlist</code>. The resulting list is: (all registers - <code>register_blocklist</code>) + <code>register_allowlist</code>.</p> <p>The default blocked registers are used by the executor internally, and thus should be avoided.</p> <pre><code>Name: generator_faults_allowlist\nDefault: []\nOptions: 'div-by-zero' | 'div-overflow' | 'opcode-undefined' | 'bounds-range-exceeded' | 'breakpoint' | 'debug-register' | 'non-canonical-access' | 'user-to-kernel-access'\n</code></pre> <p>By default, the generator will produce programs that never trigger exceptions. This option modifies this behavior by permitting the generator to produce 'unsafe' instruction sequences that could potentially trigger an exception. The model and executor will also be configured to handle these exceptions gracefully.</p> <p>The available options are:</p> <ul> <li><code>div-by-zero</code> - generate divisions with unmasked divisor, which can cause a division by zero exception.</li> <li><code>div-overflow</code> - generate divisions with unmasked dividend, which can cause an overflow exception.</li> <li><code>opcode-undefined</code> - generate undefined opcodes, which can cause an undefined opcode exception.</li> <li><code>bounds-range-exceeded</code> - apply MPX instructions for random bounds checks.   This is possible only if MPX is included in the tested instruction set.</li> <li><code>breakpoint</code> - generate breakpoints, which can cause INT3 exceptions.</li> <li><code>debug-register</code> - generate instructions that cause INT1 exceptions.</li> <li><code>non-canonical-access</code> - randomly select a memory access in a generated program and instrument it to access a non-canonical address.</li> <li><code>user-to-kernel-access</code> - randomly select a memory access in a user actor's code and instrument it to access a kernel address; works only if there is at least one user actor.</li> </ul>"},{"location":"user/config/#actor-configuration","title":"Actor Configuration","text":"<p>All actors are defined in the <code>actors</code> list, with the following syntax:</p> <pre><code>actors:\n  - &lt;actor1_name&gt;\n    - &lt;actor_option&gt;: &lt;value&gt;\n    - &lt;actor_option&gt;:\n       - &lt;sub_option1&gt;: &lt;value1&gt;\n       - &lt;sub_option2&gt;: &lt;value2&gt;\n    ...\n  - &lt;actor2_name&gt;\n      ...\n  ...\n</code></pre> <p>The following options are available for each actor:</p> <pre><code>Actor Option: mode\nDefault: 'host'\nOptions: 'host' | 'guest'\n</code></pre> <p>The execution mode of the actor. The available options are:</p> <ul> <li><code>host</code> - the actor runs in the normal, non-virtualized mode.</li> <li><code>guest</code> - the actor runs in a VM (one VM per actor).</li> </ul> <pre><code>Actor Option: privilege_level\nDefault: 'kernel'\nOptions: 'user' | 'kernel'\n</code></pre> <p>The privilege level of the actor. The available options are:</p> <ul> <li><code>user</code> - the actor runs in user mode (CPL=3).</li> <li><code>kernel</code> - the actor runs in kernel mode (CPL=0).</li> </ul> <pre><code>Actor Option: data_properties\nDefault: (see below)\nOptions: 'present' | 'writable' | 'user' | 'accessed'\n         | 'dirty' | 'executable' | 'reserved_bit' | 'randomized'\n</code></pre> <p>The properties of the data memory used by the actor. These properties are applied only to the second page (FAULTY_AREA) of the actor's data region.</p> <p>The available options are:</p> <ul> <li><code>present</code> [default: True] - the value of the Present bit in the page table entry.</li> <li><code>writable</code> [default: True] - the value of the Writable bit in the page table entry.</li> <li><code>user</code> [default: False] - the value of the User/Supervisor bit in the page table entry.</li> <li><code>accessed</code> [default: True] - the value of the Accessed bit in the page table entry.</li> <li><code>dirty</code> [default: True] - the value of the Dirty bit in the page table entry.</li> <li><code>executable</code> [default: False] - the value of the Executable bit in the page table entry.</li> <li><code>reserved_bit</code> [default: False] - the value of the Reserved bit in the page table entry.</li> <li><code>randomized</code> [default: False] - if true, the values of the above properties will be randomized for each test case.</li> </ul> <p>Note that the above properties are set in the host page tables for actors with <code>mode: host</code>, and in the guest page tables for actors with <code>mode: guest</code>.</p> <pre><code>Actor Option: data_ept_properties\nDefault: (see below)\nOptions: 'present' | 'writable' | 'executable' | 'accessed' | 'dirty' | 'user'\n        | 'reserved_bit' | 'randomized'\n</code></pre> <p>The properties of the EPT entry used by the actor (on Intel) or the NPT entry (on AMD). The properties are applied only to the second page (FAULTY_AREA) of the actor's data region.</p> <p>This property has no effect on actors with <code>mode: host</code>.</p> <p>The available options are:</p> <ul> <li><code>present</code> [default: True] - the value of the Present bit in the EPT/NPT entry.</li> <li><code>writable</code> [default: True] - the value of the Writable bit in the EPT/NPT entry.</li> <li><code>executable</code> [default: False] - the value of the Executable bit in the EPT/NPT entry.</li> <li><code>accessed</code> [default: True] - the value of the Accessed bit in the EPT/NPT entry.</li> <li><code>dirty</code> [default: True] - the value of the Dirty bit in the EPT/NPT entry.</li> <li><code>user</code> [default: False] - the value of the User/Supervisor bit in the EPT/NPT entry.</li> <li><code>reserved_bit</code> [default: False] - the value of the Reserved bit in the EPT/NPT entry.</li> <li><code>randomized</code> [default: False] - if true, the values of the above properties will be randomized for each test case.</li> </ul> <pre><code>Actor Option: observer\nDefault: False\n</code></pre> <p>If enabled, the actor will be an observer actor, hence modelling an attacker. This option is only used if the contract is <code>noninterference</code>, and it is ignored otherwise.</p> <pre><code>Actor Option: instruction_blocklist\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>Actor-specific instruction blocklist. This list has priority over the global <code>instruction_blocklist</code>.</p> <pre><code>Actor Option: fault_blocklist\nDefault: []\nOptions: (any fault names)\n</code></pre> <p>Actor-specific fault blocklist. This list has priority over the global <code>generator_faults_allowlist</code>.</p>"},{"location":"user/config/#input-generator-configuration","title":"Input Generator Configuration","text":"<pre><code>Name: input_generator\nDefault: 'random'\nOptions: 'random'\n</code></pre> <p>The input generator type. Currently, only random input generation is supported.</p> <pre><code>Name: input_gen_seed\nDefault: 10\n</code></pre> <p>Seed of the input generator. If set to zero, a random seed will be used for each run.</p> <pre><code>Name: input_gen_entropy_bits\nDefault: 16\n</code></pre> <p>Entropy of the random values created by the input generator. The maximum value is 31.</p> <pre><code>Name: inputs_per_class\nDefault: 2\n</code></pre> <p>Number of inputs generated for each input class by the Contract-Driven Input Generator. For the explanation of the input classes and the generation algorithm, see (this paper)[https://arxiv.org/pdf/2301.07642], Section 4.D. Contract-driven Input Generator.</p>"},{"location":"user/config/#contract-configuration","title":"Contract Configuration","text":"<pre><code>Name: contract_execution_clause\nDefault: ['seq']\nOptions: 'seq' | 'no_speculation' | 'seq-assist' | 'cond' | 'conditional_br_misprediction' | 'bpas' | 'nullinj-fault' | 'nullinj-assist' | 'delayed-exception-handling' | 'div-zero' | 'div-overflow' | 'meltdown' | 'fault-skip' | 'noncanonical' | 'vspec-ops-div' | 'vspec-ops-memory-faults' | 'vspec-ops-memory-assists' | 'vspec-ops-gp' | 'vspec-all-div' | 'vspec-all-memory-faults' | 'vspec-all-memory-assists'\n</code></pre> <p>The execution clause of the contract.</p> <ul> <li><code>seq</code> - sequential execution.</li> <li><code>no_speculation</code> - sequential execution. Synonym for <code>seq</code>.</li> <li><code>seq-assist</code> - sequential execution with possible microcode assists.</li> <li><code>cond</code> - permitted misprediction of conditional branches.</li> <li><code>conditional_br_misprediction</code> - permitted misprediction of conditional branches. Synonym for <code>cond</code>.</li> <li><code>bpas</code> - permitted speculative store bypass</li> <li><code>nullinj-fault</code> - page faults are permitted to speculatively return zero.</li> <li><code>nullinj-assist</code> - microcode assists are permitted to speculatively return zero.</li> <li><code>delayed-exception-handling</code> - upon an exception or a fault, data-independent instructions that follow the exception are allowed to execute speculatively.</li> <li><code>meltdown</code> - permission-based page faults are permitted to speculatively return the value in the memory.</li> <li><code>fault-skip</code> - upon a fault, the faulting instruction is speculatively skipped.</li> <li><code>noncanonical</code> - permitted speculative non-canonical memory accesses.</li> <li><code>vspec*</code> - experimental contracts for value speculation. See (this paper)[https://www.usenix.org/system/files/usenixsecurity23-hofmann.pdf] for details.</li> <li><code>div-zero</code> - experimental contract; do not use.</li> <li><code>div-overflow</code> - experimental contract; do not use.</li> </ul> <pre><code>Name: contract_observation_clause\nDefault: 'ct'\nOptions: 'none' | 'l1d' | 'memory' | 'pc' | 'ct' | 'loads+stores+pc' | 'ct-nonspecstore' | 'ctr' | 'arch' | 'tct' | 'tcto' | 'ct-ni'\n</code></pre> <p>The observation clause of the contract. In most cases, the default value should be used.</p> <p>For single-actor experiments, the following options are available:</p> <ul> <li><code>none</code> - the model observes nothing. Useful for testing the fuzzer.</li> <li><code>l1d</code> - the model observes the addresses of data accesses, adjusted to imitate the L1D cache trace.   Has very few real applications, and should be generally avoided.</li> <li><code>memory</code> - the model observes the addresses of data accesses.</li> <li><code>ct</code> (constant time tracer) - the model observes the addresses of data accesses and the control flow.</li> <li><code>loads+stores+pc</code> - the model observes the addresses of data accesses and the control flow. Synonym for <code>ct</code>.</li> <li><code>ct-nonspecstore</code> - the model observes the addresses of data accesses and the control flow, but does not observe the addresses of stores during speculation.</li> <li><code>ctr</code> - the model observes the addresses of data accesses and the control flow, as well as the values of the general-purpose registers.</li> <li><code>arch</code> - the model observes the addresses of data accesses and the control flow, as well as the values loaded from memory.   This clause imitates the security guarantees provided by secure speculation mechanisms like STT.</li> <li><code>tct</code> (truncated constant time tracer) - the model observes address of the memory access and of the program counter at cache line granularity.</li> <li><code>tcto</code> (truncated constant time tracer with overflows) - the model address of the memory access and of the program counter at cache line granularity + observe cache line overflows.</li> </ul> <p>In multi-actor context, only one option is available:</p> <ul> <li><code>ct-ni</code> - when executing actors with <code>observer: false</code>, the model observes the same data as as with <code>ct</code>. When executing actors with <code>observer: true</code>, the model observes complete memory of the actor as well as their register values.</li> </ul> <pre><code>Name: model_backend\nDefault: 'unicorn'\nOptions: 'dummy' | 'unicorn' | 'dynamorio'\n</code></pre> <p>The backend used to implement the contract model. The available options are: * <code>unicorn</code> - use the Unicorn emulator. This is the default option and it is recommended for most cases. * <code>dynamorio</code> - use the DynamoRIO dynamic binary instrumentation framework. This option is newly added and experimental. Avoid using it unless you are doing development work on Revizor. * <code>dummy</code> - use a dummy model. This model always returns the same (empty) contract trace, and as such will not produce meaningful results. This option is useful, however, when root-causing violations, because it allows to collect hardware traces without running the model, hence allowing to trace instructions that are not supported by any of the backends.</p> <pre><code>Name: model_min_nesting\nDefault: 1\n</code></pre> <p>Minimum number of nested mispredictions in the model. This value is used to generate the contract traces on the fast path of the fuzzer.</p> <pre><code>Name: model_max_nesting\nDefault: 30\n</code></pre> <p>Maximum number of nested mispredictions in the model. This value is used to generate the contract traces on the slow path of the fuzzer, i.e., when a potential violation is detected and the fuzzer tries to check if it is a true positive.</p> <pre><code>Name: model_max_spec_window\nDefault: 250\n</code></pre> <p>Size of the speculation window in the model.</p>"},{"location":"user/config/#executor-configuration","title":"Executor Configuration","text":"<pre><code>Name: executor\nDefault: (auto-detected)\nOptions: 'x86-64-intel' | 'x86-64-amd'\n</code></pre> <p>The executor type. The default value is auto-detected based on the <code>cpuinfo</code>. Should be changed only if the auto-detection fails.</p> <pre><code>Name: executor_mode\nDefault: 'P+P'\nOptions: 'P+P' | 'F+R' | 'E+R' | 'PP+P' | 'TSC'\n</code></pre> <p>Hardware trace collection mode. The available options are:</p> <ul> <li><code>P+P</code> - prime and probe.</li> <li><code>F+R</code> - flush and reload.</li> <li><code>E+R</code> - evict and reload.</li> <li><code>PP+P</code> - partial prime and probe (i.e., leave a subset of cache lines unprimed).</li> <li><code>TSC</code> - use RDTSCP instruction to measure the time of the execution.</li> </ul> <pre><code>Name: executor_warmups\nDefault: 5\n</code></pre> <p>Number of warmup rounds executed before starting to collect hardware traces.</p> <pre><code>Name: executor_sample_sizes\nDefault: [10, 50, 100, 500]\n</code></pre> <p>A list of sample sizes to be used during the measurements. The executor will first collect the hardware traces with the first sample size in the list, and if a violation is detected, it will try to reproduce it with all the following sample sizes.</p> <pre><code>Name: executor_filtering_repetitions\nDefault: 10\n</code></pre> <p>The sample size to be used by the speculation and observation filters.</p> <pre><code>Name: executor_taskset\nDefault: 0\n</code></pre> <p>The ID of the CPU core on which the executor is running test cases.</p> <pre><code>Name: enable_pre_run_flush\nDefault: True\n</code></pre> <p>If enabled, the executor will do its best to flush the microarchitectural state before running test cases.</p> <pre><code>Name: x86_executor_enable_ssbp_patch\nDefault: True\n</code></pre> <p>Enable a microcode patch against Speculative Store Bypass, if available.</p> <pre><code>Name: x86_executor_enable_prefetcher\nDefault: False\n</code></pre> <p>Enable all prefetchers, if the software controls are available.</p> <pre><code>Name: x86_disable_div64\nDefault: True\n</code></pre> <p>Do not generate 64-bit division instructions. Useful for avoiding certain types of speculation that are specific to 64-bit division.</p> <pre><code>Name: x86_enable_hpa_gpa_collisions\nDefault: False\n</code></pre> <p>When a test case contains at least one guest actor, allocate its memory in the guest physical address space to match the corresponding host physical addresses of the main actor. Useful for testing Foreshadow-like leaks.</p> <pre><code>Name: x86_generator_align_locks\nDefault: True\n</code></pre> <p>When generating memory accesses with locks, apply instrumentation to align the locks to 8 bytes. Useful for avoiding faults on unaligned accesses.</p>"},{"location":"user/config/#analyser-configuration","title":"Analyser Configuration","text":"<pre><code>Name: analyser\nDefault: 'chi2'\nOptions: 'chi2' | 'mwu' | 'sets' | 'bitmaps'\n</code></pre> <p>The type of the analyser that is used to compare the hardware traces and contract traces.</p> <p>The available options are:</p> <ul> <li><code>sets</code> - combine the hardware traces for each input into a set. A violation is reported if two inputs in the same contract-equivalence class have different sets of hardware traces.</li> <li><code>bitmaps</code> - combine the hardware traces for each input into a bitmap. A violation is reported if two inputs in the same contract-equivalence class have different bitmaps of hardware traces.</li> <li><code>chi2</code> - use the chi-squared homogeneity test to compare the hardware traces of inputs in the same contract-equivalence class. This test effectively checks if the hardware traces from two different inputs come from the same distribution. A violation is reported if the test fails.</li> <li><code>mwu</code> - [experimental; both false positives and negatives are possible]   use the Mann-Whitney U test to compare the hardware traces of inputs in the same contract-equivalence class. This test effectively checks if the hardware traces from two different inputs come from the same distribution. A violation is reported if the test fails.</li> </ul> <pre><code>Name: analyser_subsets_is_violation\nDefault: False\n</code></pre> <p>This option is relevant only for the <code>sets</code> and <code>bitmaps</code> analysers.</p> <p>If enabled, the analyser will not label hardware traces as mismatching if they form a subset relation.</p> <pre><code>Name: analyser_outliers_threshold\nDefault: 0.1\n</code></pre> <p>This option is relevant only for the <code>sets</code> and <code>bitmaps</code> analysers.</p> <p>The analyser will ignore the hardware traces that appear in less than this percentage of the repetitions.</p> <pre><code>Name: analyser_stat_threshold\nDefault: 0.5\n</code></pre> <p>This option is relevant only for the <code>chi2</code> and <code>mwu</code> analysers.</p> <p>The threshold for the statistical tests. If a pair of hardware traces has the (normalized) statistics below the threshold, then the traces are considered equivalent.</p> <p>For the chi2 test, the threshold is applied to the <code>statistics / (len(htrace1) + len(htrace2))</code>.</p> <p>For the mwu test, the threshold is applied to the p-value.</p>"},{"location":"user/config/#miscellaneous-configuration","title":"Miscellaneous Configuration","text":"<pre><code>Name: coverage_type\nDefault: 'none'\nOptions: 'none' | 'model_instructions'\n</code></pre> <p>The type of coverage tracking. The available options are:</p> <ul> <li><code>none</code> - disable coverage tracking.</li> <li><code>model_instructions</code> - track how many times the model executed each instruction.</li> </ul> <pre><code>Name: minimizer_retries\nDefault: 1\n</code></pre> <p>Number of minimization retries. When the minimizer performs a check to reduce a test case, each check is attempted this number of times and it succeeds if at least one check is successful.</p>"},{"location":"user/fuzzing-guide/","title":"Tutorial: Root-Causing a Violation Detected by Revizor","text":"<p>This tutorial walks you through analysis of a contract violation detected by Revizor. The goal is to simplify the violation artifacts (program and inputs) and identify the root cause of the violation. The tutorial includes practical examples, explanations of commands, and interpretation of outputs.</p> <p>The examples below will show the process of root-causing a violation of the CT-SEQ contract on an x86-64 CPU. The same general procedure can be applied to other contracts and architectures.</p>"},{"location":"user/fuzzing-guide/#prerequisites","title":"Prerequisites","text":"<ol> <li>Revizor Installed: Ensure Revizor is installed and functional.</li> <li>Detected Violation: Revizor has already surfaced a violation and stored it in a <code>violation-&lt;timestamp&gt;</code> directory.</li> <li>Configuration Files: You have access to the configuration file (<code>config.yaml</code>) used in the fuzzing campaign.</li> </ol>"},{"location":"user/fuzzing-guide/#step-1-locate-the-violation-files","title":"Step 1: Locate the Violation Files","text":"<p>When Revizor detects a violation, it creates a directory (<code>violation-&lt;timestamp&gt;</code>) containing: - <code>program.asm</code>: The test case program that caused the violation. - <code>input_*.bin</code>: A sequence of inputs that triggered the violation. - <code>report.txt</code>: Additional details about the violation, including hardware and contract traces. - <code>org-config.yaml</code>: The original configuration file used in the fuzzing campaign. - <code>reproduce.yaml</code>: A configuration file for reproducing the violation. - <code>minimize.yaml</code>: A configuration file for minimizing the test case.</p>"},{"location":"user/fuzzing-guide/#step-2-reproduce-the-violation","title":"Step 2: Reproduce the Violation","text":"<p>To confirm the violation and analyze its context, reproduce it using the following command:</p> <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t ./violation-&lt;timestamp&gt;/program.asm -i ./violation-&lt;timestamp&gt;/input_*.bin\n</code></pre> <p>If the violation is reproducible, Revizor will print \"Violation detected\" in the terminal output. The distribution of hardware traces in the reproduced violation should be roughly similar to the original violation. If the traces are significantly different, this might be a sign of a bug or a misconfiguration in the fuzzer.</p> <p>Note: The cases of non-reproducible violations are expected to be rare, no more than one or two per machine/week of fuzzing. If your fuzzing campaign produces more, consider adjusting the configuration file to increase noise tolerance (see the Configuration File Documentation).</p>"},{"location":"user/fuzzing-guide/#step-2a-analyze-reproduction-output","title":"Step 2a: Analyze Reproduction Output","text":"<p>The output of the reproduction command provides valuable insights into the violation. Here is an example output:</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 14907365725669422044 (hash)\nHardware traces:\n  Input group 1: [1, 21]\n  Input group 2: [11]\n  ^.^....^.....^.................^...^............^............... [500    | 10    ]\n  ^.^....^.....^................^^...^............^............... [0      | 490   ]\n\n================================ Statistics ===================================\nTest Cases: 1\nInputs per test case: 30.0\nViolations: 1\nEffectiveness:\n  Total Cls: 30.0\n  Effective Cls: 30.0\nDiscarded Test Cases:\n  Speculation Filter: 0\n  Observation Filter: 0\n  Fast Path: 0\n  Max Nesting Check: 0\n  Tainting Check: 0\n  Early Priming Check: 0\n  Large Sample Check: 0\n  Priming Check: 0\n\nDuration: 8.2\nFinished at 12:00:05\n</code></pre>"},{"location":"user/fuzzing-guide/#insights-from-the-output","title":"Insights from the Output","text":"<ul> <li>Violation detected: Indicates that the violation was successfully reproduced.</li> <li>Contract Trace: The value (<code>14907365725669422044</code>) summarizes the contract trace for the inputs that triggered the violation. This value is a hash so it does not provide direct information about the contract trace, but it should match the value from the original violation. If you would like to see the complete contract trace, enable <code>dbg_dump_ctraces</code> in the configuration file.</li> <li>Hardware Traces: The text under the <code>Hardware traces</code> section summarizes the hardware traces that constitute the violation.</li> <li>The text starting with <code>Input group</code> tells us that the violation was triggered by inputs #1, #11, and #21. The inputs #1 and #21 produced the same (or very similar) hardware traces, while input #11 produced a different set of traces - hence they are put into two different groups.</li> <li>The line with <code>^</code> and <code>.</code> characters represents the observed cache changes. Each character encodes the state of the corresponding L1D cache line after the test case has been executed with the given input. Character <code>^</code> indicates that the cache line was accessed (e.g., evicted if P+P mode is used), while <code>.</code> indicates that the cache line was not accessed. The cache sets are numbered left-to-right, starting from zero (TIP: set <code>color: true</code> in config file to improve readability). So, in the above example, the first hardware trace shows the accessed cache sets were 0, 2, 7, 13, 31, 35, and 49: <pre><code>      Set 2 accessed\n      |         Set 13 accessed\n      |          |                    Set 35 accessed\n      |          |                     |\n    ^.^....^.....^.................^...^............^...............\n    |      |                       |                |\n    |      |                       |                Set 49 accessed\n    |      |                       Set 31 accessed\n    |      Set 7 accessed\n    Set 0 accessed\n</code></pre></li> <li>The numbers at the end of the line (<code>[500    | 10    ]</code>) are the numbers of occurrences of the given hardware trace in the sample. Recall that the executor collects each hardware trace multiple times to deal with non-determinism and to filter noise (see <code>executor_sample_sizes</code> configuration option). The first number is the number of occurrences of the trace in the first input group (i.e., inputs #1 and #21), and the second number is the number of occurrences in the second input group (input #11). So, we can tell that the first input group always produced the same hardware trace, while the second input group mainly produced the second hardware trace, but there were a few (10) occurrences of the first trace as well.</li> <li>Statistics: The statistics section can be largely ignored when root-causing the violation. Is it only useful for fine-tuning the fuzzing campaign.</li> </ul>"},{"location":"user/fuzzing-guide/#step-3-minimize-the-program","title":"Step 3: Minimize the Program","text":"<p>The violation program (<code>program.asm</code>) is a large, randomly generated sequence of instructions and it often contains many unnecessary instructions.</p> <p>TIP: If the violation is stable and reproducible, you can try to reduce the sample size to speed up the minimization process. To do so, modify the <code>executor_sample_sizes</code> parameter in the configuration file.</p> <p>Use minimization passes to simplify the program while preserving the violation:</p> <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t ./violation-&lt;timestamp&gt;/program.asm -o minimized.asm -i &lt;num_inputs&gt; \\\n    --num-attempts 10 \\\n    --enable-instruction-pass 1 \\\n    --enable-simplification-pass 1 \\\n    --enable-label-pass 1\n</code></pre>"},{"location":"user/fuzzing-guide/#explanation-of-passes","title":"Explanation of Passes","text":"<ul> <li>The default pass (no flag required) removes unnecessary instructions.</li> <li><code>--enable-simplification-pass</code> replaces complex instructions with simpler ones.</li> <li><code>--enable-label-pass</code> cleans up unused labels.</li> <li>The sequence of three passes is executed 10 time (<code>--num-attempts 10</code>) to ensure the best possible simplification.</li> </ul> <p>This example is the simplest form of minimization. For more advanced minimization options, consider adding the flags described in the Minimization Passes Documentation.</p>"},{"location":"user/fuzzing-guide/#verify-minimization","title":"Verify Minimization","text":"<p>The <code>minimized.asm</code> file contains a reduced version of the original program that still reproduces the violation. Run the <code>reproduce</code> command to ensure the minimizer did not introduce non-determinism. <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t minimized.asm -i &lt;num_inputs&gt;\n</code></pre></p> <p>If the violation is not reproducible, try re-running the minimizer without some some of the passes or decrease the number of attempts.</p>"},{"location":"user/fuzzing-guide/#step-4-minimize-inputs","title":"Step 4: Minimize Inputs","text":"<p>A test case input is the data used to initialize memory and register before executing the test case program. Hence, if we minimize the inputs that trigger the violation, we can isolate the exact conditions causing the violation and the data that leaks.</p> <p>Run the following command to minimize the inputs: <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t minimized.asm -o commented.asm -i &lt;num_inputs&gt; \\\n    --input-outdir ./inputs \\\n    --enable-input-diff-pass 1 \\\n    --enable-comment-pass 1\n</code></pre></p> <p>Result: - <code>./inputs/min_input_*.bin</code>: Minimized input sequence that still trigger the violation. - A printed summary of Leaked bytes in the terminal output. Be sure to record these for further analysis.</p>"},{"location":"user/fuzzing-guide/#insights-from-the-summary","title":"Insights from the Summary","text":"<p>Below is an example of the printed summary from the differential input minimizer: <pre><code>[PASS 2] Differential Input Minimizer\n  &gt; Minimizing the difference between inputs 1 and 11\n\nAddress    +0x0     +0x40    +0x80    +0xc0    +0x100   +0x140   +0x180   +0x1c0\n0x00000000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000200 ........ =....... ........ ........ ........ ........ ........ ........\n0x00000400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00002000 .....^..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2028']\n</code></pre></p> <p>The minimizer goes through the pair of inputs that trigger the violation - inputs #1 and #11 in this case - and tries to minimize the differences between them: * If both inputs already have identical values at a given address, the minimizer prints <code>=</code> for that address. In this example, this is the case for address <code>0x240</code>. * Next, the pass attempts to zero out one byte at a time in both inputs. If the violation persists, then the minimizer prints <code>.</code> for that address. In this example, most of the addresses are zeroed out. * Next, the pass attempts to copy one byte from input #1 into the same address in input #11. If the violation persists, then the minimizer prints <code>+</code> for that address. This example does not have such cases. * If both attempts fail, the pass restores the original values at the given address, prints <code>^</code>, and moves to the next address. In this example, the minimizer restored the original value at address <code>0x2028</code>.</p> <p>The interpretation of these results is case-specific, but generally, the values with <code>+</code> or <code>=</code> are those that create conditions for leakage, and the values with <code>^</code> are the addresses whose value leaks.</p> <p>In this example, the minimizer found that this test case leaks one byte at address <code>0x2028</code> (used to initialize RDI). The minimizer also found that the address <code>0x240</code> must contain specific non-zero values that must be the same in both inputs. This address in the input is used to initialize the corresponding offset in the sandbox of actor 0. See Sandbox Memory Layout for more details about register and memory initialization.</p> <p>TIP 1: The <code>--enable-comment-pass 1</code> flag adds comments to the minimized input files, which can help you understand which instructions used which addresses.</p> <p>TIP 2: Ideally, the minimizer should be able to reduce the leakage to a single byte. If more then a couple bytes leak, it typically indicates that the violation is non-deterministic, and it might be a good idea to re-run the program minimizer or to change the configuration to increase the number of attempts/increase the noise threshold. If no bytes leak, this is a certain sign that something went wrong; re-run the minimizer.</p>"},{"location":"user/fuzzing-guide/#verify-minimization_1","title":"Verify Minimization","text":"<p>Run the minimized program with the reduced inputs to ensure the violation is still reproducible: <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t commented.asm -i ./inputs/min_input*.bin\n</code></pre></p>"},{"location":"user/fuzzing-guide/#step-5-insert-speculation-fences","title":"Step 5: Insert Speculation Fences","text":"<p>To isolate speculative behavior, add fences: <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t commented.asm -o fenced.asm -i &lt;num_inputs&gt; \\\n    --enable-fence-pass 1\n</code></pre></p> <p>This pass with attempt to insert an <code>LFENCE</code> after every instruction in the program and check if the violation still occurs.</p> <p>In the resulting file (<code>fenced.asm</code>) the region without fences is the one that causes the violation. The remaining instructions are just setting up the data for the violation, and are likely irrelevant.</p> <p>TIP: If an <code>LFENCE</code> is inserted after every instruction in the test case and the violation still occurs, this is most likely due to a bug in the model or the executor. If you are using a custom model, consider checking the model for correctness. If you haven't made changes to the Revizor source code, please, open an issue in the bug tracker.</p>"},{"location":"user/fuzzing-guide/#step-6-map-hardware-traces-to-minimized-program-and-data","title":"Step 6: Map Hardware Traces to Minimized Program and Data","text":"<p>When both program and its inputs are minimized, you should be able to identify which instructions caused the cache accesses in the hardware traces and which data was leaked.</p> <p>When we run the <code>reproduce</code> command with the minimized program and inputs, we will see the following hardware traces:</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 2362171776002334258 (hash)\nHardware traces:\n  Input group 1: [1]\n  Input group 2: [11]\n  ^...............................................^............... [420    | 0     ]\n  ^............................................................... [80     | 0     ]\n  ^..............^................................................ [0      | 500   ]\n</code></pre> <p>TIP: If in your case the input IDs have changed after minimization, you can either exclude some of the inputs from the arguments of the <code>reproduce</code> command, or re-run the minimizer with fewer passes.</p> <p>We see that the hardware traces have been significantly simplified compared to the original violation, and now there are at most two accessed cache sets in each trace: 0 and 48 for input #1, and 0 and 15 for input #11. This is a good sign: the minimization was successful.</p> <p>We can also tell that the only difference between the two traces is the accessed cache set 48 vs 15 . This is the cache set that is causing the violation, and we should be aiming to find the instruction that does the access.</p> <p>To do so, let's look at the contents of the <code>commented.asm</code> file. This file contains the minimized program with comments that show which memory addresses or cache lines are accessed by each instruction.</p> <pre><code>; ... skipped header ...\n1.  and rax, 0b1111111111111 # instrumentation\n2.  lfence\n3.  mov edx, dword ptr [r14 + rax]\n4.  # mem access: [1] 0x0 cl 0:0 | [11] 0x0 cl 0:0\n5.  or cx, 0b1000 # instrumentation\n6.  and cl, 0b11111000 # instrumentation\n7.  and dx, 0b11 #\n8.  and rsi, 0b1111111111111 #\n9.  add cl, 39 #\n10. mov rbx, 0b1111111111111 #\n11. bt si, dx\n12. jbe .bb_0.1\n13. jmp .exit_0\n14. .bb_0.1:\n15. mov ecx, edi\n16. and rcx, 0b1111111111000 # instrumentation\n17. mov byte ptr [r14 + rcx], 88\n; ... skipped footer ...\n</code></pre> <p>TIP: You can find the same information in a different format if you enable <code>dbg_violation</code> in the configuration file and run the <code>reproduce</code> command.</p> <p>This program contains only two memory accesses, at lines 3 and 17.</p> <p>The annotation at line 4 tells us that the <code>mov</code> instruction accesses memory offset <code>0x0</code> when executed with input 1 (<code>[1]</code>) and the same cache set when executed with input 11 (<code>[11]</code>). The notation <code>0:0</code> stands for cache set <code>0</code> and cache line offset <code>0</code>.</p> <p>This information lets us map this instruction to the first access in the hardware trace:</p> <pre><code>    ^...............................................^...............\n    |\n  This eviction maps to `mov edx, dword ptr [r14 + rax]` at line 3\n</code></pre> <p>The second memory access (line 17) does not have an annotation, which implies that the contract model has not executed this instruction with the inputs provided. It does not, however, mean that the CPU has not executed this instruction, as there is a chance that this instruction was executed speculatively. This is a typical scenario in violations detected by Revizor.</p> <p>If we look at the instructions prior to the memory access, we can see <code>jbe</code> instruction at line 12, which is a conditional jump - a common source of speculation, namely branch prediction. This type of speculation is not permitted by the target contract (CT-SEQ), so it could cause a violation. From this, we can make a hypothesis that the memory access at line 17 is speculative and is the one causing the second cache access:</p> <pre><code> Inputs [1]:\n              Hypothesis: This eviction maps to `mov` at line 17\n                                                  |\n  ^...............................................^...............\n\n Inputs [11]:\n  ^..............^................................................\n                 |\n           Hypothesis: This eviction maps to `mov` at line 17\n</code></pre> <p>To check if our hypothesis is correct, let's cross-reference this information with the leaked bytes from the differential input minimizer:</p> <pre><code>; .. skip zero bytes\n0x00002000 .....^..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2028']\n</code></pre> <p>This summary tells us that <code>rdi</code> has a differing value between inputs #1 and 11. At the same time, the first time <code>rdi</code> is used in the program is at line 15, where it is moved to <code>rcx</code>, and then later used as a part of the address in the memory access at line 17. This would make the speculative memory access at line 17 access different addresses with the two inputs, and would explain the difference between the hardware traces.</p> <p>At this point, the hypothesis is more-or-less confirmed, and we can declare that the root cause of the leak was the misprediction of the <code>jbe</code> branch at line 12, which caused the speculative execution of the memory access at line 17, and which in turn leaked the value of <code>rdi</code>.</p> <p>If we want to further increase our confidence, we can manually inspect the contents of the inputs at the address <code>0x2028</code> to see if the values correspond to the cache set ID that we observe in the hardware traces. This can be done by running the <code>hexdump</code> command on the input files:</p> <pre><code>$ hexdump -C ./inputs/min_input_0001.bin | grep 2020\n00002020  00 00 00 00 00 00 00 00  1e 1c 4a 00 1e 1c 4a 00  |..........J...J.|\n$ hexdump -C ./inputs/min_input_0011.bin | grep 2020\n00002020  00 00 00 00 00 00 00 00  c8 13 58 00 c8 13 58 00  |..........X...X.|\n</code></pre> <p>The values are <code>0x4a1c1e004a1c1e</code> for input #1 and <code>0x5813c8005813c8</code> for input #11. These are masked with <code>0b1111111111000</code> by <code>and</code> at line 16 and become <code>7192</code> and <code>5064</code> respectively. If we translate these values to cache set IDs (<code>id = (addr % 0x1000) // 64</code>), we get <code>48</code> and <code>15</code>. These values match the cache set IDs that we observed in the hardware traces, which confirms our hypothesis.</p> <p>If we want even more confidence, we can manually modify the input files (e.g, with <code>hexedit</code> tool) to see if the hardware traces change when we modify the value of <code>rdi</code> in the input files.</p>"},{"location":"user/fuzzing-guide/#step-7-modify-the-program","title":"Step 7: Modify the Program","text":"<p>In many cases, the minimization process will not provide a clear result as in the example above and you will not be able to make a specific hypothesis about the root cause of the violation. In such cases, you can try to modify the program in various ways to see if the violation still occurs. There are no strict rules on which modifications to make and you will have to rely on your intuition and knowledge of the target microarchitecture, but here are some general guidelines:</p> <ol> <li>Simplify Instructions: Start by trying to manually replace instructions in <code>minimized.asm</code> with simpler ones. For example, replace complex instructions with memory operands with simple loads or stores.</li> <li>Increase/Decrease Aliasing: Try to change the addresses of memory accesses to match (or not match if they already do) the addresses of other instruction. Such aliasing often triggers speculation (e.g., in Speculative Store Bypass or MDS attacks).</li> <li>Add/Remove Dependent Instructions: If you have a hypothesis about which instruction triggers speculation, try adding or removing data-dependent instructions before it. This will change the size of the speculative window and might change hardware traces, which will give you more insight into the violation.</li> <li>Change Memory Permissions: If the violation is related to memory accesses, try changing the permissions of the memory regions that are accessed by the program. For example, if the memory is read-only, try changing it to read-write. If the violation disappears, it might indicate that the violation is related to the permission checks in the CPU.</li> <li>Change Instruction Operands: Try changing operands to add or remove data dependencies between instructions. For example, if you have a sequence of two moves <code>mov rax, [rax]; mov rbx, [rax]</code>, try changing the second move to <code>mov rbx, [rbx]</code> to see if the violation still occurs if there are no data dependencies between the instructions.</li> </ol> <p>After each modification, run the <code>reproduce</code> command to see if the violation still occurs:</p> <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t modified.asm -i ./inputs/min_input*.bin\n</code></pre> <p>NOTE: If you find any other strategies that work well, please consider sharing them by opening a pull request to this documentation. We would love to hear about your experiences and learn from them.</p>"},{"location":"user/fuzzing-guide/#additional-resources","title":"Additional Resources","text":"<ul> <li>Command Line Interface</li> <li>Minimization Passes</li> <li>Configuration File Documentation</li> <li>Sandbox Memory Layout</li> </ul>"},{"location":"user/minimization/","title":"Minimization of Violation Artifacts","text":"<p><code>minimize</code> mode of Revizor performs post-processing of the violation artifacts produced as a result of testing a CPU in the <code>fuzz</code> mode. This mode takes a violating program and its sequence of inputs, and it performs a series of transformation passes to simplify the program and the inputs while preserving the violation. The goal is to produce a minimal artifact that would be easier to understand and analyze by a human.</p>"},{"location":"user/minimization/#usage","title":"Usage","text":"<p>To run the minimization mode, you need a program that violates the contract (e.g., <code>program.asm</code>), a configuration file that was used to detect the violation (e.g., <code>config.yaml</code>), a specification of the instruction set (e.g., <code>base.json</code>). The config file must set the input generation seed (<code>input_gen_seed</code>) to the value that matches the seed used in the <code>fuzz</code> mode to generate the violating inputs.</p> <p>The syntax of the command is as follows:</p> <pre><code>rvzr minimize -s &lt;spec_file&gt; -c &lt;config_file&gt; -t &lt;program_file&gt; -o &lt;output_file&gt; -i &lt;num_inputs&gt; --input-outdir &lt;input_outdir&gt; --num-attempts &lt;num_attempts&gt; &lt;pass_list&gt;\n</code></pre> <p>A typical example of the command is:</p> <pre><code>rvzr minimize -s base.json -c config.yaml -i 25 -t program.asm -o min.asm --input-outdir ./inputs --num-attempts 10 --enable-instruction-pass 1\n</code></pre> <p>This example command will take the program <code>program.asm</code>, generate an input sequence of length 25 based on the seed in <code>config.yaml</code>, and then apply a series of transformation passes (see the list of supported passes below) to simplify the program and the inputs. The passes will be applied 10 times. The resulting simplified program will be written to <code>min.asm</code>, and the simplified input sequence will be written to the directory <code>&lt;dir&gt;</code>.</p>"},{"location":"user/minimization/#supported-passes","title":"Supported Passes","text":"<p><code>minimize</code> mode supports three types of passes: program passes modify the program, input passes modify the input sequence, and analysis passes provide additional information about the violation, usually by adding comments to the program.</p>"},{"location":"user/minimization/#program-passes","title":"Program Passes","text":"<pre><code>--enable-instruction-pass\n</code></pre> <p>Enables the instruction minimization pass that iteratively removes instructions from the program while preserving the violation.</p> <pre><code>--enable-simplification-pass\n</code></pre> <p>Enables the instruction simplification pass that replaces complex instructions with simpler ones while preserving the violation.</p> <pre><code>--enable-nop-pass\n</code></pre> <p>Enables the NOP replacement pass that iteratively replaces instructions with NOPs of the same size while preserving the violation.</p> <pre><code>--enable-constant-pass\n</code></pre> <p>Enables the constant simplification pass that replaces immediate arguments of instructions with 0s while preserving the violation.</p> <pre><code>--enable-mask-pass\n</code></pre> <p>Enables the mask simplification pass that reduces the size of the instrumentation masks while preserving the violation.</p> <pre><code>--enable-label-pass\n</code></pre> <p>Enables the label removal pass that removes unused labels from the assembly file.</p> <pre><code>--enable-fence-pass\n</code></pre> <p>Enables the fence insertion pass that adds LFENCEs after instructions while preserving the violation.</p>"},{"location":"user/minimization/#input-passes","title":"Input Passes","text":"<pre><code>--enable-input-seq-pass\n</code></pre> <p>Enables the input sequence minimization pass that removes inputs from the original generated sequence while preserving the violation.</p> <pre><code>--enable-input-diff-pass\n</code></pre> <p>Enables the violating input difference minimization pass that operates on the pair of (contract-equivalent) inputs that triggered the violation and attempts to minimize the difference between the two inputs. It does so by iterating over all bytes in the inputs, and (1) attempting to replace each byte with zero, and if it fails, (2) copying the byte from the first input to the second input.</p>"},{"location":"user/minimization/#analysis-passes","title":"Analysis Passes","text":"<pre><code>--enable-source-analysis\n</code></pre> <p>Enables the speculation source identification pass that analyzes the program to identify suspected sources of speculation, and adds the corresponding comments to the assembly file. Note that the analysis is not guaranteed to be correct, and it may produce false results.</p> <pre><code>--enable-comment-pass\n</code></pre> <p>Enables the violation comment pass that adds comments to the assembly file with details about the violation. Namely, it adds comments to every memory access in the following format:</p> <p><code># mem access: [input1_id] [load_addr]-[store_addr] CL [cache_set_id]:[cache_line_offset] | [input2_id] [load_addr]-[store_addr] CL [cache_set_id]:[cache_line_offset]</code></p> <p>The comment indicates the addresses (<code>load_addr</code> and <code>store_addr</code>) of the given memory operation when executed with the two inputs that triggered the violation (<code>input1_id</code> and <code>input2_id</code>). For convenience, it also provides the L1D cache set ID and line offset that correspond to the addresses of the memory operation.</p> <p>For example, this comment</p> <p><code># mem access: [1] 0x800-0x800 CL 32:0 | [11] 0x710-0x710 CL 28:10</code></p> <p>indicates that the memory operation preceded by this comment was executed with two inputs, <code>1</code> and <code>11</code>, and the memory operation accessed the addresses <code>0x800</code> and <code>0x710</code> in the two inputs, respectively. The address <code>0x800</code> corresponded to cache set <code>32</code> and line offset <code>0</code>, while the address <code>0x710</code> corresponded to cache set <code>28</code> and line offset <code>10</code>.</p>"},{"location":"user/minimization/#interpreting-the-output","title":"Interpreting the Output","text":"<p>When a pass executes, it prints out the progress into the console.</p>"},{"location":"user/minimization/#output-of-program-passes","title":"Output of Program Passes","text":"<p>Most of the passes print out one character per instruction, with <code>.</code> indicating that the pass succeeded, and <code>-</code> indicating that the pass failed on the given instruction. For example, if <code>--enable-instruction-pass</code> is enabled, the output may look like this:</p> <p><pre><code>[Pass 2] Instruction Removal Pass\n\n.............-.....--.-------..----\n</code></pre> This means that the pass successfully removed the last 13 instructions, failed to remove the 14th instruction, succeeded on the 15th instruction, and so on. Note that the pass iterates from bottom to top, hence the output is printed in reverse order.</p>"},{"location":"user/minimization/#output-of-input-passes","title":"Output of Input Passes","text":"<p>The <code>input-diff</code> pass has a slightly different output format. It prints out a compact representation of the input difference, with each character representing a byte in the input sequence: * <code>.</code> indicates that zeroing the byte succeeded * <code>+</code> indicates that copying the byte succeeded * <code>=</code> indicates that the byte was already the same in both inputs * <code>^</code> indicates that the pass failed to minimize the byte, and it remained different in the two inputs</p> <p>For example, the output of the <code>input-diff</code> pass may look like this:</p> <pre><code>Address    +0x0     +0x40    +0x80    +0xc0    +0x100   +0x140   +0x180   +0x1c0\n0x00000000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00002000 ====^=..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2020']\n</code></pre> <p>This output indicates that the pass successfully minimized the input difference for all bytes except for the byte at address <code>0x2020</code>, which remained different in the two inputs, and the bytes at addresses <code>0x2000-0x2018</code> and <code>0x2028</code> were already the same in both inputs.</p>"},{"location":"user/minimization/#usage-example","title":"Usage Example","text":"<p>The following example demonstrates a typical workflow of using the <code>minimize</code> mode to simplify a violating program and its input sequence.</p> <p>Let's assume that a violation artifact was produces as a result of a fuzzing campaign like this:</p> <pre><code>rvzr fuzz -s base.json -c config.yaml -n 1000 -i 25 -w .\n</code></pre> <p>The first step is to minimize the violating program by enabling all program passes:</p> <pre><code>rvzr minimize -s base.json -c ./violation-000000-000000/minimize.yaml \\\n     -t ./violation/violation-000000-000000/program.asm \\\n     -o min.asm -i 25 --num-attempts 3 \\\n     --enable-instruction-pass 1 \\\n     --enable-simplification-pass 1 \\\n     --enable-nop-pass 1 \\\n     --enable-constant-pass 1 \\\n     --enable-mask-pass 1 \\\n     --enable-label-pass 1\n</code></pre> <p>Then verify the violation is preserved by reproducing it with the minimized program and the original input sequence:</p> <pre><code>rvzr fuzz -s base.json -c minimize.yaml -t min.asm -i 25\n</code></pre> <p>If the violation is detected, move to the next step. Otherwise, re-run the first command with a lower number of <code>--num-attempts</code> or try to disable some of the passes.</p> <p>The next step is to minimize the inputs by enabling all input passes, and to add analysis comments:</p> <pre><code>rvzr minimize -s base.json -c ./violation/violation-240712-132351/minimize.yaml \\\n    -t min.asm \\\n    -o commented.asm -i 25  \\\n    --input-outdir ./inputs \\\n    --enable-input-diff-pass 1 \\\n    --enable-input-seq-pass 1 \\\n    --enable-source-analysis 1 \\\n    --enable-comment-pass 1\n</code></pre> <p>The final step is to try to reproduce the violation with the minimized program and inputs to verify that the violation is preserved:</p> <pre><code>rvzr reproduce -s base.json -c ./violation/violation-240712-132351/reproduce.yaml \\\n    -t commented.asm -i ./inputs/min_input*.bin\n</code></pre> <p>If the violation is detected, the minimized program and inputs can be used for further analysis.</p>"},{"location":"user/modes/","title":"Modes of Operation","text":"<p>Revizor supports several modes of operation, each targeting a different use cases. The selection of the mode is described in the CLI documentation. Below is a brief description of each mode.</p> Mode CLI Key Use Case Description Fuzzing fuzz General Testing Test a CPU against a contract model. Test cases generated randomly Template Fuzzing tfuzz Targeted Testing Test a CPU against a contract model. Test cases generated based on a template Reproduce reproduce Reproducing a Violation Reproduce a violation found by fuzzing OR run a manually-written test case Minimization minimize Violation Simplification Simplify a test case by applying a series of simplification passes to the test case program and its inputs Trace Analysis analyse Stand-alone Analysis Analyze pre-recorded traces for violations Generation generate Stand-alone Generation Only generate test cases, without testing them ISA Spec Install download_spec Tool Installation Call a script that downloads the instruction set specification"},{"location":"user/modes/#fuzzing-and-template-fuzzing-modes","title":"Fuzzing and Template Fuzzing Modes","text":"<p>Two main modes of operation in revizor are fuzzing and template fuzzing. These modes are used to test a CPU against a contract model. In both modes, revizor generates test cases and executes them on the target CPU and the model, records the corresponding traces, and checks if the hardware traces contain the same (or less) information as the contract traces.</p> <p>In the fuzzing mode, test cases are generated randomly, with the instruction set and size of test cases defined by the config file. This mode is used for broad testing of the CPU.</p> <p>In the template fuzzing mode, test cases are generated based on a template: The generator takes an assembly template as an input, and produces a test case by expanding the <code>random_instructions</code> macro in the template. This mode is used to narrow down the fuzzing space and focus on specific scenarios, such as testing microarchitectural patches or certain interactions between actors.</p>"},{"location":"user/modes/#reproduce","title":"Reproduce","text":"<p>In this mode, Revizor loads a test case from a set of files and runs a single round of the fuzzer with this test case. The test case is usually a violation previously found in the (template) fuzzing mode, but it can also be written manually.</p> <p>There are three main use cases for this mode:</p> <ol> <li>Analysis of the violation: to understand the root cause of the violation, the user may manually modify the test case and re-run it in the reproduce mode to see if the violation is still present.</li> <li>Reproducibility check: to check if a violation is reproducible on different CPUs, or on different configurations of the same CPU (e.g., after a microcode patch has been applied).</li> <li>Manual testing: to test a manually-written test case.</li> </ol>"},{"location":"user/modes/#minimization","title":"Minimization","text":"<p>In this mode, Revizor takes a test case that causes a violation and applies a series of simplification passes to the test case program and its inputs. The goal is to reduce the test case to its minimal form to simplify the root cause analysis of the violation. Revizor supports an extensive list of passes, described in the minimization documentation.</p>"},{"location":"user/modes/#stand-alone-interfaces","title":"Stand-alone Interfaces","text":"<p>The <code>analyse</code> and <code>generate</code> modes are used to perform stand-alone access to modules of Revizor. In the <code>analyse</code> mode, the user can analyze pre-recorded traces for violations. In the <code>generate</code> mode, the user can generate test cases without testing them.</p>"},{"location":"user/modes/#isa-spec-install","title":"ISA Spec Install","text":"<p>The <code>download_spec</code> mode isn't used for testing, but rather for tool installation. It provides an interface to download, parse, and store the instruction specifications for the tested ISA in the JSON format.</p>"}]}