{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Revizor","text":"<p>Welcome to Revizor.</p>"},{"location":"contracts/","title":"Primer: Speculation Contracts and Model-Based Relational Testing","text":"<p>Author: Oleksii Oleksenko | Last Updated: 2025-04-02</p> <p>Below is a brief primer on the theoretical foundations of speculation contracts and model-based relational testing\u2014concepts that underlie the Revizor tool. This primer provides a high-level overview of the topic, introducing the concepts of noninterference, speculation contracts, and model compliance.</p> <p>This document is intended for those new to the topic, particularly people without a background in information-flow analysis. For a more detailed and technical explanation, refer to the original contracts paper.</p>"},{"location":"contracts/#information-flow-properties","title":"Information-Flow Properties","text":"<p>We will start with the basics: the concepts of confidentiality and noninterference, which are fundamental to understanding how speculation contracts work.</p> <p>Traditionally, security mechanisms like access control and encryption have focused on protecting data at rest or in transit. However, these mechanisms do not address the problem of information flow within a system. For example, consider a program that reads a secret input and then writes it to a public output, such as a web server that logs failed login attempts along with the username and masked password entered. Even if the program is secure in the sense that it does not allow unauthorized access to the secret data, it may still leak the secret through its public output, such as logging \"User admin failed login with password starting with 'P@ss'\" \u2014 revealing partial information about the secret password. This is where information-flow security comes into play.</p> <p>Information-flow security is concerned with how data moves through a computation and how it can be observed by an attacker. The goal is to ensure that secret information does not leak to observers who are unauthorized to access it. An end-to-end confidentiality policy might be stated as: \u201cNo secret input data can be inferred by an attacker through observations of system output.\u201d In other words, even if an adversary can see all public outputs of a computation, they should learn nothing about the secret inputs.</p> <p>Information-flow properties generally classify program variables or inputs/outputs into security levels (e.g., <code>Secret</code> and <code>Public</code>). The key property for confidentiality is that no information flows from Secret to Public. But how can information flow? There are two primary routes:</p> <ul> <li> <p>Explicit flows: These occur when confidential data is directly assigned or passed into a public variable or output. For example, in code, writing <code>public = secret</code> is an explicit flow from a secret variable to a public variable (an obvious violation of confidentiality). Any mechanism that directly transfers the bits of a secret into a publicly observable sink is an explicit flow. Such flows are usually straightforward to detect.</p> </li> <li> <p>Implicit flows: These occur indirectly, through the control structure of the program. An implicit flow arises when the control path taken by a program (e.g., which branch of an <code>if</code> or how many loop iterations) depends on a secret, thereby implicitly leaking information.</p> </li> </ul> <p>Example 1 (Implicit Flow)</p> <p>Consider this pseudocode example:</p> <pre><code>if (Sec == 0) {\n    Pub = 0;\n} else {\n    Pub = 1;\n}\n</code></pre> <p>Here <code>Sec</code> is a secret input and <code>Pub</code> is a public output. There is no direct assignment of <code>Sec</code> to <code>Pub</code>. However, an observer of <code>Pub</code> can deduce information about <code>Sec</code>. In fact, this program sets <code>Pub</code> to 0 if <code>Sec</code> was 0; otherwise, it sets <code>Pub</code> to 1\u2014effectively copying the one-bit information \u201cis Sec zero?\u201d into <code>Pub</code>. This is an implicit flow of information from <code>Sec</code> to <code>Pub</code> through the control structure (the <code>if</code> condition on <code>Sec</code>).</p>"},{"location":"contracts/#noninterference-definition-and-examples","title":"Noninterference: Definition and Examples","text":"<p>Noninterference is a formal property that captures the idea of perfect confidentiality: changes in secret data have no observable effect on public outputs. This property can be formalized as: \"a system is noninterferent if variations in Secret inputs cause no differences in Public outputs\". Equivalently, confidential inputs do not interfere with the publicly visible state of the system.</p> <p>To make this more concrete, imagine we run a program twice with two different secret inputs but the same public inputs. If no attacker can distinguish the two runs by observing anything public, then the program satisfies the noninterference property. The \u201cattacker\u201d here is assumed to have complete access to all public outputs, which are formalized as a function <code>PublicOut</code>:</p> <pre><code>output = PublicOut(Sec, Pub)\n</code></pre> <p>Noninterference essentially demands that for any two secrets <code>Sec1</code> and <code>Sec2</code> and any public input <code>Pub</code>, the program\u2019s behavior from an attacker\u2019s perspective is identical when run on <code>(Sec1, Pub)</code> versus <code>(Sec2, Pub)</code>:  Definition 1 (Noninterference): A program <code>P</code> is noninterferent if, for allpublic inputs <code>Pub</code> and all pairs of secret inputs <code>Sec1</code>, <code>Sec2</code> it holds that <code>PublicOut(P, Sec1, Pub) = PublicOut(P, Sec2, Pub)</code>. </p> <p>Here are some examples to illustrate this principle:</p> <p>Example 2 (Interfering program)</p> <p>Suppose our program simply copies a secret to output:</p> <pre><code>void copy(int* sec, int* output) {\n    *output = *sec;\n}\n</code></pre> <p>Running it with two different secrets clearly yields different public outputs (e.g., <code>output</code> becomes 5 in one run and 7 in another). An attacker would distinguish these runs, so the program is not noninterferent\u2014it blatantly leaks information.</p> <p>Example 3 (Noninterfering program)</p> <p>A trivial example of a noninterferent program is one that produces no output dependent on the secret. For instance:</p> <pre><code>void assign_zero(int* sec, int* output) {\n    *output = 0;\n}\n</code></pre> <p>This program ignores secret <code>sec</code> entirely and always sets the public output <code>output</code> to 0. No matter what the secret input is, the public output is constant (0), so an attacker gains no information about <code>sec</code>. Indeed, any two runs are indistinguishable (both runs output 0). This satisfies noninterference (albeit by doing nothing useful with the secret).</p> <p>Example 4 (Allowed benign dependency)</p> <p>It is possible for a program to use secret data internally yet still be noninterferent as long as the final public outputs don\u2019t reveal those secrets. For instance:</p> <pre><code>void mask_secret(int* sec, int* output) {\n    int temp = *sec;\n    temp = temp * 0;   // multiply secret by 0\n    *output  = temp;\n}\n</code></pre> <p>Here the program did read the secret (<code>sec</code>) and even manipulated it, but it \u201cwashed out\u201d the secret by multiplying by 0. The value assigned to <code>output</code> is always 0. From an external view, this is just like the previous example\u2014no dependence of <code>output</code> on <code>sec</code>. Noninterference is concerned only with what can be observed by the attacker, not with whether the program internally used the secret. As long as any use of the secret eventually has no effect on outputs, the policy holds.</p> <p>Naturally, this example is not useful either, as it does nothing with the secret. In practice, however, there are techniques to ensure noninterference while still making use of secret data for useful computations. We won't go into these techniques here as they are beyond the scope of this primer.</p> <p>One important insight is that noninterference is relative to a given specification of what is \u201cobservable.\u201d If you consider only the functional outputs as observable, a program might be noninterferent in that model. But if in reality the attacker can observe more (e.g., the execution time of a program), then the program that was secure in theory might be insecure in practice. This leads us to examine how side channels break the assumptions of basic noninterference.</p>"},{"location":"contracts/#beyond-direct-outputs-side-channels","title":"Beyond Direct Outputs: Side Channels","text":"<p>The original works on information-flow properties focused on direct outputs of a program (e.g., writing to a file or a network socket). However, in practice, attackers can extract information from more than just the \u201cofficial\u201d outputs of a program. For example, the attacker might observe how long a computation takes or measure the power consumption of a device. These additional sources of information are called side channels. Side channels are unintended channels through which secret data can be inferred by observing the system\u2019s behavior, even if the direct outputs are secure.</p> <p>These side channels can reveal information about the secret inputs, and so we must include them in the definition of noninterference. Similarly to how we defined <code>PublicOut(Sec, Pub)</code> as the observable output, we can define <code>Trace</code> as the observable side-channel information for a given program <code>P</code>.</p> <pre><code>trace = Trace(P, Sec, Pub)\n</code></pre> <p>For example, a trace might be the execution time of the program or its cache access pattern.</p> <p>Noninterference then requires that the traces of two runs with different secrets - <code>(Sec1, Pub)</code> versus <code>(Sec2, Pub)</code> - are indistinguishable to an attacker. This is a stronger requirement than just looking at the functional outputs.</p> <p> Definition 2 (Side-Channel Noninterference): Given a side channel that produces a trace <code>Trace</code>, a program <code>P</code> is noninterferent with respect to this side channel if, for all public inputs\u00a0<code>Pub</code> and all pairs of secret inputs <code>Sec1</code>, <code>Sec2</code> it holds that <code>Trace(P, Sec1, Pub) = Trace(P, Sec2, Pub)</code>. </p> <p>Here are some examples of side channels and how they can violate noninterference:</p> <p>Example 5A (Timing side channel)</p> <p>Consider a program that reads a compares a password with a user\u2019s input:</p> <pre><code>bool check_password(const char *attempt, const char *pswd) {\n    for (int i = 0; i &lt; length(pswd); i++) {\n        if (attempt[i] != pswd[i]) {\n            return false;  // mismatch found, return early\n        }\n    }\n    return true; // all characters matched\n}\n</code></pre> <p>If the attacker can measure how long the function takes to reject a guess, they can infer the password one character at a time. This leakage surfaces as a violation of the noninterference property with respect to timing observations.</p> <p>A counterexample to Definition 2 could be as follows: Let's say we use the same input on two different secrets:</p> <ul> <li><code>input1={attempt=\"aaa\", pswd=\"abc\"}</code></li> <li><code>input2={attempt=\"aaa\", pswd=\"aab\"}</code></li> </ul> <p>The traces of these inputs will be:</p> <ul> <li><code>trace1 = Trace(check_password, input1) = 1</code></li> <li><code>trace2 = Trace(check_password, input2) = 2</code></li> </ul> <p>These inputs constitute a violation of Definition 2, as <code>trace1 != trace2</code> even though the two inputs have the same public values.</p> <p>Example 5B (Timing side channel - Password lenght)</p> <p>Noninterference is able to model different kinds of secret-dependent leaks. Let's take for example a patched version of the previous program:</p> <pre><code>bool check_password(const char *attempt, const char *pswd) {\n    int len = min(length(attempt), length(pswd));\n    bool same = true;\n    for (int i = 0; i &lt; len; i++) {\n        same = same &amp;&amp; (attempt[i] == pswd[i]); // all the loop is executed\n    }\n    return same;\n}\n</code></pre> <p>In this version there is no early-exit condition, yet the attacker is still able to infer the length of the password through a side-channel. This is captured by the following counterexample:</p> <ul> <li><code>input1={attempt=\"aaaaaa\", pswd=\"b\"}</code>, <code>trace1 = 1</code></li> <li><code>input2={attempt=\"aaaaaa\", pswd=\"bbb\"}</code>, <code>trace2 = 3</code></li> </ul> <p>Which shows that the program still violates Definition 2.</p> <p>Example 6 (Cache side channel)</p> <p>Consider a program that uses a secret value to index into an array, as in the following code:</p> <pre><code>int multiply(const char *array, int pub, int sec) {\n    char x = array[sec];\n    return x * pub;\n}\n</code></pre> <p>A co-located attacker could observe the cache access pattern of the program by using Prime+Probe or Flush+Reload attack. Such traces can reveal the addresses accessed by the program and thus leak the secret value. This leakage would violate the noninterference property with respect to cache observations.</p> <p>A violation could be surfaced by two inputs:</p> <ul> <li><code>input1={array=0x10000, pub=1, sec=0x40}</code></li> <li><code>input2={array=0x10000, pub=1, sec=0x80}</code></li> </ul> <p>Let's assume that the cache line size is 64 bytes, and the cache is direct-mapped, meaning that the cache line ID is based on the memory access address <code>addr</code> as <code>line_id = (addr % 0x1000) // 0x40</code>. Since the array access in the first line of <code>multiply</code> will access two different addresses for the two inputs, they will also produce two different traces:</p> <ul> <li><code>trace1 = Trace(multiply, input1) = ((0x10000 + 0x40) % 0x1000) // 0x40 = 1</code></li> <li><code>trace2 = Trace(multiply, input2) = ((0x10000 + 0x80) % 0x1000) // 0x40 = 2</code></li> </ul> <p>Since we have two inputs that match on the secret value <code>sec</code> but differ on the cache trace, this constitutes a violation of Definition 2.</p>"},{"location":"contracts/#challenges-of-side-channel-noninterference","title":"Challenges of Side-Channel Noninterference","text":"<p>Despite its completeness, the above formalization of side-channel noninterference is too simplistic to faithfully capture the side effects of program execution on modern, highly optimized hardware, especially CPUs. There are two key challenges:</p> <ul> <li> <p>Challenge 1 - Noisy and Non-Deterministic Traces: The traces observed by the attacker over a side channel are typically noisy, non-deterministic, and depend on the microarchitectural state of the CPU. For example, cache access patterns can be influenced by other programs running on the machine, the operating system and its interrupts, and can depend on microarchitectural buffers like store buffers or branch history tables. This means that the <code>Trace</code> function is not a simple deterministic function of the program inputs, but a complex function of many factors, some of which affect the result concurrently and in a non-deterministic fashion.</p> </li> <li> <p>Challenge 2 - Unknown Side Channels: Modern CPUs have a plethora of side channels, including cache timing, branch prediction, and many others. To ensure complete confidentiality, we need to check that the program does not leak information over any of them. This is a challenging task, as we do not know the full set of possible side channels when it comes to commercial hardware with proprietary microarchitectures. For example, a CPU might have an obscure microarchitectural optimization that vastly expands possibilities for information leaks, as was the case with Spectre and Meltdown vulnerabilities. Not including this optimization will undermine the noninterference analysis. Therefore, to test for noninterference comprehensively, we need a way to discover and reason about all possible side channels that could leak information.</p> </li> </ul> <p>The next two sections discuss how speculation contracts address these challenges.</p>"},{"location":"contracts/#speculation-contracts-dealing-with-the-complexity-of-modern-hardware","title":"Speculation Contracts: Dealing with the Complexity of Modern Hardware","text":"<p>As a solution to the first challenge, Guarnieri et al. (2021) introduced the concept of speculation contracts. A speculation contract is a simplified and deterministic model of the hardware, designed to capture the information that a given program could leak over side channels when executed with the given inputs. The key term here is \"could\"\u2014the contract is not meant to exactly predict the side-channel traces, but instead, it errs on the side of caution, overestimating the possible leaks to achieve deterministic and noise-free traces.</p> <p>A speculation contract works by defining two key aspects for every instruction in the CPU's ISA:</p> <ol> <li> <p>Observation Clause: For each instruction that may have an observable side effect, the contract declares an observation clause. It describes the data exposed by the instruction.</p> </li> <li> <p>Execution Clause: For each instruction whose semantics may be affected by hardware optimizations (e.g., speculative execution), the contract declares an execution clause. It describes the effect of such optimizations, but without specifying the exact mechanism of the optimization.</p> </li> </ol> <p>At a high level, a contract implements a function <code>ContractTrace</code> that maps a program <code>P</code> and its inputs <code>Sec, Pub</code> to a contract trace <code>ctrace</code>. It is essentially a conservative approximation of the <code>Trace</code> function.</p> <pre><code>ctrace = ContractTrace(P, Sec, Pub)\n</code></pre> <p>The contract trace is a sequence of all data that is exposed when a program is executed according to a contract. It captures the side-channel observations that could be visible if the CPU followed the speculation contract\u2019s rules for a given program execution.</p> <p>Accordingly, the noninterference property is redefined in terms of the contract trace:</p> <p> Definition 3 (Contract Noninterference): Given a contract that produces a contract trace\u00a0<code>ContractTrace</code>, a program <code>P</code> is noninterferent with respect to this contract if,for all public inputs\u00a0<code>Pub</code> and all secret inputs <code>Sec1</code>, <code>Sec2</code>, it holds that <code>ContractTrace(P, Sec1, Pub) = ContractTrace(P, Sec2, Pub)</code>. </p> <p>The following examples illustrate how a contract can be used to model side-channel leaks on a CPU.</p> <p>Example 7: Memory Observation Contract, MEM-SEQ</p> <p>Let's imagine a CPU with a shared data cache and no other optimizations (i.e., no speculation). A co-located attacker can recover the addresses of loads/stores by observing which of the cache sets changed their state via a cache timing side-channel attack (e.g., Prime+Probe). We can encode these expectations in an observation clause for loads and stores by specifying that they expose their address. Since the CPU does not speculate, the execution clause for all instructions is empty. We call this contract MEM-SEQ (memory leakage with sequential execution), and it can be summarized as a table:</p> Observation Clause Execution Clause Load Expose Address - Store Expose Address - Other - - <p>Note that MEM-SEQ intentionally overestimates the leaks by assuming that the attacker observes complete addresses loads/stores (in contrast to a subset of bits that are actually leaked in practice) and that all loads/stores are observable (in reality, they might be masked by noise or other factors). This overestimation is intentional to ensure that the contract is conservative and captures all possible corner cases.</p> <p>Let's now consider how we can produce a contract trace using MEM-SEQ. We will use a slightly modified version of the <code>multiply</code> function from Example 6:</p> <pre><code>int multiply(const char *array, int pub, int sec) {\n    char x = array[sec];   // MEM-SEQ exposes: &amp;array[sec]\n    char y = array[pub];   // MEM-SEQ exposes: &amp;array[pub]\n    return x * y;\n}\n</code></pre> <p>The inputs are:</p> <ul> <li><code>input1 = {array=0x10000, pub=1, sec=2}</code></li> <li><code>input2 = {array=0x10000, pub=1, sec=3}</code></li> </ul> <p>The model collects a trace by executing the program line-by-line according to the rules in the table above (in practice, this is usually done using a modified CPU emulator). The first line has a load from memory, so the model records the address <code>&amp;array[sec]</code> as exposed. The second line has another load, so the model records the address <code>&amp;array[pub]</code> as exposed. The contract traces for this program would be:</p> <ul> <li><code>ctrace1 = ContractTrace(multiply, input1) = [0x10002, 0x10001]</code></li> <li><code>ctrace2 = ContractTrace(multiply, input2) = [0x10003, 0x10001]</code></li> </ul> <p>Finally, this model can be used to check for noninterference by comparing contract traces according to Definition 3. In this case, we have two inputs with matching public values and different secrets, and they produced different contract traces, <code>ctrace1 != ctrace2</code>. This constitutes a violation and means that the <code>multiply</code> function is not noninterferent with respect to MEM-SEQ.</p> <p>Example 8: Branch Prediction Contract, MEM-COND</p> <p>Now let's consider a more complex scenario, with a CPU that implements branch prediction\u2014a common form of speculative execution. In this case, the CPU may incorrectly predict branch targets and execute instructions that are not part of the correct control flow. We can model this behavior in a contract by introducing an execution clause for conditional jumps that specifies the mispredicted target. To make the example useful, we will assume that the CPU also has a data cache, so the observation clause for loads and stores remains the same as in MEM-SEQ. We call this contract MEM-COND (memory leakage with conditional branch misprediction).</p> Observation Clause Execution Clause Load Expose Address - Store Expose Address - Cond. Jump - Mispredict Target Other - - <p>As a target program we will use the following function:</p> <pre><code>int conditional_multiply(char *array, int pub, int sec) {\n    int z = array[pub];   // MEM-COND exposes: &amp;array[pub]\n    if (z &lt; 10) {         // MEM-COND mispredicts (assume z = 10)\n        z *= array[sec];  // MEM-COND exposes: &amp;array[sec]\n    }\n    return z;\n}\n</code></pre> <p>and a pair of inputs with the same public value but different secrets:</p> <ul> <li><code>input1 = {array=0x10000, pub=1, secret=2}</code></li> <li><code>input2 = {array=0x10000, pub=1, secret=3}</code></li> </ul> <p>The first line of <code>conditional_multiply</code> has a load, so it exposes its address, <code>&amp;array[pub]</code>. For the sake of this example, let's assume this load returns <code>10</code>, so the next branch is not supposed to be taken. However, according to MEM-COND, branches take the wrong target, so the model executes the third line anyway. This line is a load, so it exposes the address <code>&amp;array[sec]</code>. After this, the program terminates, and the resulting traces are:</p> <ul> <li><code>ctrace1 = ContractTrace(conditional_multiply, input1) = [0x10002, 0x10001]</code></li> <li><code>ctrace2 = ContractTrace(conditional_multiply, input2) = [0x10003, 0x10001]</code></li> </ul> <p>Again, the traces are different, so the program violates noninterference with respect to MEM-COND. Notably, however, these two inputs would not violate noninterference with respect to MEM-SEQ, as the branch at line 2 would not be mispredicted, and the traces would be identical:</p> <p><code>ctrace_mem_seq1 = ctrace_mem_seq2 = [0x10001]</code></p>"},{"location":"contracts/#building-and-testing-speculation-contracts","title":"Building and Testing Speculation Contracts","text":"<p>Speculation contracts are typically built by hand, with the initial versions based on public knowledge of the CPU's microarchitecture and its side-channel vulnerabilities. However, in the case of commercial CPUs, the exact details of the microarchitecture are often proprietary and not publicly disclosed. In these cases, the contract could\u2014and often will\u2014be incomplete. This is where the testing of speculation contracts becomes crucial: the initial \"draft\" of a contract is tested against the real hardware to ensure that it captures all side-channel leaks that the CPU exhibits. If the contract misses something, it is refined based on the results of the testing, and the process is repeated until the contract is deemed safe to use.</p> <p>But how do we test a speculation contract? A naive approach might be to directly compare the traces produced by the model with the traces collected from the real CPU for the same program and inputs. However, this approach is generally not feasible because the contract traces intentionally overestimate the hardware traces, so mismatches are expected. Moreover, the model might expose information differently than the real hardware (e.g., the model might expose load/store addresses, while the hardware exposes cache set indexes), meaning direct comparison is often impossible.</p> <p>Instead, a more precise approach is to compare the information contained in the traces. The idea is to check that the information exposed by the model is a strict superset of the information exposed by the real hardware. This is done by verifying that all inputs producing identical contract traces for a given program also produce identical hardware traces. If this property holds for all possible programs and inputs (ignore the complexity question for now), then any program that would be noninterferent with respect to the real hardware is guaranteed to be noninterferent with respect to the speculation contract. At this point, the model is safe to use as a proxy for real hardware when analyzing side-channel leaks.</p> <p>To formalize this idea, let's introduce a new function <code>HardwareTrace</code> to denote the trace collected from the real hardware, and it will take an extra argument <code>Ctx</code> to capture the fact that real-world hardware traces depend on the microarchitectural state (e.g., on the state of branch predictors or caches).</p> <p> Definition 4: Contract Compliance. A CPU complies with a speculation contract if, for all programs <code>P</code>, all input pairs <code>(Sec1, Pub), (Sec2, Pub)</code>, and all initial microarchitectural states\u00a0<code>Ctx</code>, if <code>ContractTrace(P, Sec1, Pub) = ContractTrace(P, Sec2, Pub)</code>, then <code>HardwareTrace(P, Sec1, Pub, Ctx) = HardwareTrace(P, Sec2, Pub, Ctx)</code>. </p> <p>and conversely</p> <p> Definition 5: Contract Violation. A CPU violates a speculation contract if there exists a program\u00a0<code>P</code>, a microarchitectural state\u00a0<code>Ctx</code>, and two inputs <code>(Sec1, Pub), (Sec2, Pub)</code> such that <code>ContractTrace(P, Sec1, Pub) = ContractTrace(P, Sec2, Pub)</code> and <code>HardwareTrace(P, Sec1, Pub, Ctx) != HardwareTrace(P, Sec2, Pub, Ctx)</code>. </p> <p>We call the tuple <code>(P, Ctx, Sec1, Sec2)</code> a contract counterexample. The counterexample demonstrates that an adversary can learn more information from hardware traces than what the contract specifies. A counterexample indicates a potential microarchitectural leakage that was not accounted for by the contract. The goal of Revizor is to find such counterexamples.</p>"},{"location":"contracts/#model-based-relational-testing-and-revizor","title":"Model-Based Relational Testing and Revizor","text":"<p>Revizor applies the principles above, and provides a framework for building executable speculation contracts together with a mechanism to test real hardware (currently only CPUs) against these contracts by searching for contract counterexamples, as in Definition 5. However, there are certain issues that appear when the theory from the previous section is applied in practice, which we had to address in Revizor.</p> <p>The first issue is the search space: testing all possible programs and inputs is literally impossible. We mitigate this issue by relying on a sampling-based approach, similar to fuzzing, where we approximate the complete search space via random sampling. Specifically, Revizor generates small (50-100 instructions long) programs, creates random inputs for them, collects both the contract and hardware traces for these inputs, and checks whether any of the traces constitute a contract counterexample. This process is called Model-based Relational Testing, and it is detailed further in the Architecture Overview.</p> <p>This approach works well in practice because any given hardware optimization can typically be triggered by many different programs, and we need to find only one instance to detect a violation. Evidence of this is the list of trophies that Revizor has already amassed.</p> <p>The second issue we encountered is nondeterminism. As mentioned earlier, hardware traces can be non-deterministic due to various factors like interrupts or other programs running on the machine. To handle this, we use statistical methods: Revizor collects hardware traces for each program-input pair multiple times and then compares their distributions. If the distributions of the traces are statistically similar, Revizor considers the traces to be equivalent. This approach helps us account for noise in the hardware traces while still making reliable decisions about contract compliance.</p>"},{"location":"contracts/#conclusion","title":"Conclusion","text":"<p>In this primer, we have introduced the concepts of noninterference, side channels, and speculation contracts, which all underlie the design of Revizor:</p> <ul> <li>The hardware fuzzer in Revizor uses speculation contracts and the concepts of noninterference (1) to detect unexpected side channels and dangerous microarchitectural optimizations in commercial CPUs, and (2) to aid in building sound leakage models for those CPUs.</li> <li>The software fuzzer in Revizor (NOTE: currently under construction) uses the leakage models produced by the hardware fuzzer, and applies the principles of noninterference testing to detect side-channel vulnerabilities in real-world software.</li> </ul> <p>With these two components, we aim to provide a comprehensive tool for discovering and mitigating side-channel vulnerabilities software that can handle even the most obscure and complex microarchitectural optimizations in modern hardware.</p>"},{"location":"contracts/#sources-and-further-reading","title":"Sources and Further Reading","text":"<ul> <li>A. Sabelfeld and A. C. Myers. Language-Based Information-Flow Security. IEEE Journal on Selected Areas in Communications, 21(1), 2003. (Survey of information-flow security, implicit/explicit flows, covert channels, etc.)</li> <li>J. A. Goguen and J. Meseguer. Security Policies and Security Models. IEEE Symposium on Security and Privacy, 1982. (Origin of noninterference as a security policy formalism.)</li> <li>J. B. Almeida et al. Verifying Constant-Time Implementations. USENIX Security Symposium, 2016. (Constant-time programming principles and the ct-verif tool for automated verification.)</li> <li>M. Guarnieri, B. K\u00f6pf, J. Reineke, P. Vila. Hardware-Software Contracts for Secure Speculation. IEEE Symposium on Security and Privacy, 2021. (Original paper on speculation contracts.)</li> <li>O. Oleksenko, C. Fetzer, B. K\u00f6pf, M. Silberstein. Revizor: Testing Black-box CPUs against Speculation Contracts. ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), 2022. (Paper describing Model-based Relational Testing and Revizor.)</li> </ul>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#installation","title":"Installation","text":"<p>Warning: Revizor runs randomly-generated code in kernel space. This means that a misconfiguration (or a bug) can crash the system and potentially lead to data loss. Make sure you're not running Revizor on a production machine, and that you have a backup of your data.</p>"},{"location":"quick-start/#1-requirements","title":"1. Requirements","text":"<ul> <li> <p>Architecture: Revizor supports Intel and AMD x86-64 CPUs. We have experimental support for ARM CPUs (see <code>arm-port</code> branch) but it is at very early stages, so use it on your own peril.</p> </li> <li> <p>No virtualization: You will need a bare-metal OS installation. Testing from inside a VM is not supported.</p> </li> <li> <p>OS: The target machine has to be running Linux v4.15 or later.</p> </li> </ul>"},{"location":"quick-start/#2-python-package","title":"2. Python Package","text":"<p>The preferred installation method is using <code>pip</code> within a virtual environment. The python version must be 3.9 or later.</p> <pre><code>sudo apt install python3.9 python3.9-venv\n/usr/bin/python3.9 -m pip install virtualenv\n/usr/bin/python3.9 -m virtualenv ~/venv-revizor\nsource ~/venv-revizor/bin/activate\npip install revizor-fuzzer\n</code></pre>"},{"location":"quick-start/#3-executor","title":"3. Executor","text":"<p>In addition to the Python package, you will need to build and install the executor, which is a kernel module.</p> <pre><code># building a kernel module require kernel headers\nsudo apt-get install linux-headers-$(uname -r) linux-headers-generic\n\n# get the source code\ngit clone https://github.com/microsoft/sca-fuzzer.git\n\n# build executor\ncd sca-fuzzer/rvzr/executor_km\nmake uninstall  # the command will give an error message, but it's ok!\nmake clean\nmake\nmake install\n</code></pre>"},{"location":"quick-start/#4-optional-dynamorio-backend","title":"4. (Optional) DynamoRIO Backend","text":"<p>If you want to use the DynamoRIO-based model, it has to be installed separately:</p> <pre><code># install dependencies\nsudo apt-get install cmake g++ g++-multilib doxygen git zlib1g-dev libunwind-dev libsnappy-dev liblz4-dev\n\n# install DynamoRIO and the model\nmake -C rvzr/model_dynamorio\n\n# check installation\n~/.local/dynamorio/drrun -c ~/.local/dynamorio/libdr_model.so --list-tracers -- ls\n# expected output:\n#   ct\n#   ...\n#   /dev/null\n</code></pre>"},{"location":"quick-start/#5-download-isa-spec","title":"5. Download ISA spec","text":"<pre><code>rvzr download_spec -a x86-64 --extensions ALL_SUPPORTED --outfile base.json\n\n# Alternatively, use the following command to include system instructions;\n# however, mind that testing these instructions may crash the system if misconfigured!\n# rvzr download_spec -a x86-64 --extensions ALL_AND_UNSAFE --outfile base.json\n</code></pre>"},{"location":"quick-start/#6-test-the-installation","title":"6. Test the Installation","text":"<p>To make sure that the installation was successful, run the following command:</p> <pre><code>./tests/quick-test.sh\n\n# The expected output is:\nDetection: OK\nFiltering: OK\n</code></pre> <p>If you see any other output, check if the previous steps were executed correctly. If you still have issues, please open an issue.</p>"},{"location":"quick-start/#7-optional-system-configuration","title":"7. (Optional) System Configuration","text":"<p>External processes can interfere with Revizor's measurements. To minimize this interference, we recommend the following system configuration:</p> <ul> <li>Disable Hyperthreading (BIOS option);</li> <li>Disable Turbo Boost (BIOS option);</li> <li>Boot the kernel on a single core (add <code>-maxcpus=1</code> to Linux boot parameters).</li> </ul> <p>If you skip these steps, Revizor may produce false positives, especially if you use a low value for <code>executor_sample_sizes</code> for measurements. However, a large sample size (&gt; 300-400) usually mitigates this issue.</p>"},{"location":"quick-start/#quick-start","title":"Quick Start","text":"<p>The following is an example of a simple fuzzing session with Revizor that will detect Spectre V1-like violations.</p> <p>Create a configuration file <code>config.yaml</code> with the following content: <pre><code># config.yaml\ninstruction_categories:\n  - BASE-BINARY  # arithmetic instructions\n  - BASE-COND_BR  # conditional branches\nmax_bb_per_function: 5  # up to 5 branches per test case\nmin_bb_per_function: 1\nmax_successors_per_bb: 2  # enable basic blocks with conditional branches\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n  - no_speculation  # aka SEQ\n</code></pre></p> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 1000 -c config.yaml -w .\n</code></pre></p> <p>You will likely see a violation within a few minutes, as most modern CPUs implement branch prediction, which is a prerequisite for Spectre-like attacks, and so the contract <code>CT-SEQ</code> is likely to be violated.</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 18422470923634754929 (hash)\nHardware traces:\n  Input group 1: [7]\n  Input group 2: [57]\n  ^..........................................^.............^^..^^. [500    | 0     ]\n  ^....^...................................................^^..^^. [0      | 500   ]\n</code></pre> <p>You can find the violating test case as well as the violation report in the directory named <code>./violation-*/</code>. It will contain an assembly file <code>program.asm</code> that surfaced a violation, a sequence of inputs <code>input_*.bin</code> to this program, and some details about the violation in <code>report.txt</code>.</p>"},{"location":"quick-start/#command-line-interface","title":"Command Line Interface","text":"<p>The fuzzer is controlled via a single command line interface <code>rvzr</code> (or <code>revizor.py</code> if you're running directly from the source tree).</p> <p>It accepts the following arguments:</p> <ul> <li><code>-s, --instruction-set PATH</code> - path to the ISA description file</li> <li><code>-c, --config PATH</code> - path to the fuzzing configuration file</li> <li><code>-n , --num-test-cases N</code> - number of test cases to be tested</li> <li><code>-i , --num-inputs N</code> - number of input classes per test case. The number of actual inputs = input classes * inputs_per_class, which is a configuration option</li> <li><code>-t , --testcase PATH</code> - use an existing test case instead of generating random test cases</li> <li><code>--timeout TIMEOUT</code> - run fuzzing with a time limit [seconds]</li> <li><code>-w</code> - working directory where the detected violations will be stored</li> </ul> <p>For example, this command <pre><code>rvzr fuzz -s base.json -n 100 -i 10  -c config.yaml -w ./violations\n</code></pre> will run the fuzzer for 100 iterations (i.e., 100 test cases), with 10 inputs per test case. The fuzzer will use the ISA spec stored in the <code>base.json</code> file, and will read the configuration from <code>config.yaml</code>. If the fuzzer finds a violation, it will be stored in the <code>./violations</code> directory.</p> <p>See docs for more details.</p>"},{"location":"quick-start/#how-to-fuzz-with-revizor","title":"How To Fuzz With Revizor","text":"<p>The fuzzing process is controlled by a configuration file in the YAML format, passed via <code>--config</code> option. At the very minimum, this file should contain the following fields:</p> <ul> <li><code>contract_observation_clause</code> and <code>contract_execution_clause</code> describe the contract that the CPU-under-test is tested against. See this page for a list of available contracts. If you don't know what a contract is, Sec. 3 of this paper will give you a high-level introduction to contracts, and this paper will provide a deep dive into contracts.</li> <li><code>instruction_categories</code> is a list of instruction types that will be tested. Effectively, Revizor uses this list to filter out instructions from <code>base.json</code> (the file you downloaded via <code>rvzr download_spec</code>).</li> </ul> <p>For a full list of configuration options, see docs.</p>"},{"location":"quick-start/#baseline-experiment","title":"Baseline Experiment","text":"<p>After a fresh installation, it is normally a good idea to do a quick test run to check that everything works ok.</p> <p>For example, we can create a configuration file <code>config.yaml</code> with only simple arithmetic instructions. As this instruction set does not include any instructions that would trigger speculation on Intel or AMD CPUs (at least that we know of), the expected contract would be <code>CT-SEQ</code>:</p> <pre><code># config.yaml\ninstruction_categories:\n  - BASE-BINARY  # arithmetic instructions\nmax_bb_per_function: 1  # no branches!\nmin_bb_per_function: 1\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n  - no_speculation  # aka SEQ\n</code></pre> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 100 -c config.yaml  -w .\n</code></pre></p> <p>This command should terminate with no violations.</p>"},{"location":"quick-start/#full-scale-fuzzing-campaign","title":"Full-Scale Fuzzing Campaign","text":"<p>To start a full-scale test, write your own configuration file (see description here and an example config here), and launch the fuzzer.</p> <p>Below is a example launch command, which will start a 24-hour fuzzing session, with 100 input classes per test case, and which uses big-fuzz.yaml configuration: <pre><code>rvzr fuzz -s base.json -c demo/big-fuzz.yaml -i 100 -n 100000000 --timeout 86400 -w `pwd` --nonstop\n</code></pre></p> <p>If there is a violation, you can try to reproduce it with the following command:</p> <pre><code>rvzr reproduce -s base.json -c violation-&lt;timestamp&gt;/reproduce.yaml -t violation-&lt;timestamp&gt;/program.asm -i violation-&lt;timestamp&gt;/input_*.bin\n</code></pre> <p>If the violation is reproducible, it is useful to minimize it, so that it is easier to understand the root cause (note that minimization uses a different config file):</p> <pre><code>rvzr minimize -s base.json -c violation-&lt;timestamp&gt;/minimize.yaml -g violation-&lt;timestamp&gt;/program.asm -o violation-&lt;timestamp&gt;/minimized.asm -i 100 --num-attempts 10 --enable-simplification-pass\n</code></pre> <p>The result of minimization will be stored in <code>violation-&lt;timestamp&gt;/minimized.asm</code>. If the result is still too complicated, try other minimization passes.</p> <p>The further analysis is manual; you can find an example in this guide.</p>"},{"location":"quick-start/#need-help-with-revizor","title":"Need Help with Revizor?","text":"<p>If you find a bug in Revizor, don't hesitate to open an issue.</p> <p>If something is confusing or you need help in using Revizor, we have a discussion page.</p>"},{"location":"quick-start/#documentation","title":"Documentation","text":"<p>For more details, see the website.</p>"},{"location":"devel/","title":"Developer Documentation","text":"<p>This section provides technical documentation for developers contributing to Revizor.</p>"},{"location":"devel/#development-guidelines","title":"Development Guidelines","text":"<ul> <li>General Guidelines: Development environment setup, testing procedures, contribution workflow</li> <li>Code Style: Formatting conventions for Python and C code, naming conventions</li> <li>Git Workflow: Branch management, commit message format, merge procedures</li> </ul>"},{"location":"devel/#architecture-and-modules","title":"Architecture and Modules","text":"<ul> <li>Overview: High-level system architecture and component interaction</li> <li>Code Structure: Organization of the source code directory and key modules</li> <li>Orchestration: Main fuzzing loop and coordination between components</li> <li>ISA Specification: Instruction set architecture definitions and JSON-based specification format</li> <li>Test Case Code Generation: Program generation algorithm and relevant classes</li> <li>Test Case Data Generation: Data generation algorithm and relevant classes</li> <li>Hardware Tracing: Execution of test cases on the target HW and hardware trace collection</li> <li>Contract Tracing: Leakage modeling and contract trace generation (high-level overview; implementation details in backend-specific pages)</li> <li>Trace Analysis: Comparison of contract and hardware traces to detect violations</li> <li>Minimization: Post-detection reduction of test cases to minimal reproducing examples</li> <li>Logging: Logging infrastructure and debugging facilities</li> </ul>"},{"location":"devel/#contract-modeling-backends","title":"Contract Modeling Backends","text":"<p>Revizor supports two different backends for contract-based leakage modeling. They are documented in the following pages:</p> <ul> <li>Unicorn Backend: Backend based on the Unicorn CPU emulator</li> <li>DynamoRIO Backend: Backend based on the DynamoRIO dynamic binary instrumentation engine</li> </ul>"},{"location":"devel/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Register Allocation: Executor reserves a subset of registers for its own use; this page documents their purpose</li> <li>Test Case Sandbox: Memory layout of the sandbox environment in which test cases are executed</li> <li>Macros: Implementation of macros in Executor and Models</li> <li>Binary Formats: Serialized binary formats for test case programs and data</li> </ul>"},{"location":"devel/arch-analysis/","title":"Trace Analysis","text":"Module <code>rvzr/analyser.py</code> Public interface <code>Analyser</code> Inputs <code>CTrace</code>, <code>HTrace</code> Outputs <code>Violation</code> <p>The Analyser compares contract traces with hardware traces to detect violations. The core principle: inputs with identical CTraces should produce equivalent HTraces. When they don't, a contract violation has occurred.</p> <pre><code>For all inputs i, j:\n    if CTrace(i) == CTrace(j) and HTrace(i) != HTrace(j):\n        \u2192 Violation detected\n</code></pre> <p>Analyser implementations:</p> <p>Different analysers define \"equivalent HTrace\" differently:</p> <ul> <li><code>MergedBitmapAnalyser</code> (default) \u2014 Merges samples using bitwise OR, compares bitmaps. For cache-based channels.</li> <li><code>SetAnalyser</code> \u2014 Compares sets of unique samples.</li> <li><code>MWUAnalyser</code> \u2014 Uses Mann-Whitney U statistical test. For timing-based channels.</li> <li><code>ChiSquaredAnalyser</code> \u2014 Uses chi-squared test for distribution differences.</li> </ul>"},{"location":"devel/arch-code/","title":"Test Case Code Generation","text":"Module <code>rvzr/code_generator.py</code> Public interface <code>CodeGenerator</code> Inputs <code>InstructionSet</code> Outputs <code>TestCaseProgram</code> <p>This module generates random assembly programs for testing. The generator creates programs designed to trigger speculative execution and expose microarchitectural leaks.</p>"},{"location":"devel/arch-code/#generation-process","title":"Generation process","text":"<ol> <li> <p>Create control flow graph \u2014 Generate a random Directed Acyclic Graph (DAG) of basic blocks. The DAG structure prevents infinite loops while allowing branches and mispredictions.</p> </li> <li> <p>Add jump instructions \u2014 Insert conditional and unconditional jumps at block boundaries to connect the blocks according to the DAG.</p> </li> <li> <p>Fill basic blocks \u2014 Populate blocks with random instructions from the tested instruction pool, respecting instruction frequencies and operand constraints.</p> </li> <li> <p>Instrument \u2014 (Optionally) Prevent faults by masking memory addresses, avoiding division by zero, and ensuring all accesses stay within the sandbox.</p> </li> <li> <p>Assemble \u2014 Convert to binary and extract metadata.</p> </li> <li> <p>Transform into RCBF \u2014 Serialize the test case into Revizor's custom binary format (RCBF) for execution.</p> </li> </ol>"},{"location":"devel/arch-code/#test-case-representation","title":"Test case representation","text":"<pre><code>TestCaseProgram\n  \u251c\u2500 CodeSection (one per actor)\n  \u2502    \u2514\u2500 Function\n  \u2502         \u2514\u2500 BasicBlock\n  \u2502              \u2514\u2500 InstructionNode\n  \u2502                   \u2514\u2500 Instruction\n  \u2502                        \u2514\u2500 Operand\n  \u2514\u2500 TestCaseBinary\n       \u2514\u2500 SymbolTable\n</code></pre>"},{"location":"devel/arch-code/#variants","title":"Variants","text":"<p>Architecture-specific implementations of the code generator exist for x86 and ARM64, named <code>X86Generator</code> and <code>ARM64Generator</code> in <code>rvzr/arch/*/code_generator.py</code></p>"},{"location":"devel/arch-data/","title":"Test Case Data Generation","text":"Module <code>rvzr/data_generator.py</code> Public interface <code>DataGenerator</code> Inputs <code>Config</code> Outputs <code>InputData</code> <p><code>DataGenerator</code> generates input data that is used to initialize registers and memory before executing a test case, on both the model and the target hardware.</p>"},{"location":"devel/arch-data/#generation-modes","title":"Generation modes","text":"<p>Two input generation modes are supported:</p>"},{"location":"devel/arch-data/#standard-generation","title":"Standard generation","text":"<p>Interface: <code>DataGenerator.generate(...)</code></p> <p>This method creates fully random inputs using a PRNG. Can optionally reduce entropy (to increase trace collisions) or inject special values (zeros, boundary values) to trigger edge cases.</p>"},{"location":"devel/arch-data/#boosted-generation","title":"Boosted generation","text":"<p>Interface: <code>DataGenerator.generate_boosted(...)</code></p> <p>Boosted generation solves the following challenge: Two detect a violation via relational non-interference testing, we always need at least two inputs that produce identical contract traces (see Trace Analysis). Generating such contract-equivalent inputs through pure randomness is extremely inefficient because the entropy of contract traces is usually very high, and thus most random inputs produce unique traces.</p> <p>Boosted generation addresses this by leveraging dynamic taint analysis on the model side. It works as follows: Start by producing a set of random inputs using standard generation. Then, we execute the test case with each input in the model and perform backwards taint analysis to identify which input bytes affect the contract trace (tainted) and which don't (untainted). This produces a set of <code>InputTaint</code> objects that map input bytes to their taint status. These taint maps a fed back into the <code>generate_boosted()</code> method, which creates new inputs such that the tainted bytes remain fixed while the untainted bytes are randomized.</p> <pre><code>Original InputData \u2192 Model \u2192 InputTaint \u2192 N contract-equivalent inputs\n</code></pre> <p>Such \"boosted\" inputs are guaranteed to produce the same contract trace as the original input while still being mostly random.</p>"},{"location":"devel/arch-data/#data-representation","title":"Data Representation","text":"<p>Each input is represented as an <code>InputData</code> object, which is a numpy structured array containing</p> <ul> <li>Memory contents</li> <li>General-purpose registers</li> <li>SIMD registers</li> <li>Flags and special registers</li> </ul> <p>for each actor in the test case. This object can be serialized into Revizor's custom binary format (RDBF) for consumption by the model and executor.</p>"},{"location":"devel/arch-exec/","title":"Hardware Tracing","text":"Module <code>rvzr/executor.py</code>, <code>rvzr/executor_km/</code> Public interface <code>Executor</code> Inputs <code>TestCaseProgram</code>, <code>InputData</code> Outputs <code>HTrace</code>"},{"location":"devel/arch-exec/#executor","title":"Executor","text":"<p>The Executor runs test cases on real hardware and collects hardware traces (HTraces) using side-channel measurements. It uses a two-layer architecture: Python code communicates with a kernel module that performs measurements in kernel space.</p> <pre><code>Python (executor.py)\n  \u251c\u2500 X86IntelExecutor\n  \u251c\u2500 X86AMDExecutor\n  \u2514\u2500 ARM64Executor\n       \u2502\n       \u2502 /sys/rvzr_executor/ interface\n       \u25bc\nKernel Module (executor_km/)\n</code></pre>"},{"location":"devel/arch-exec/#htrace-representation","title":"HTrace representation","text":"<p>The <code>HTrace</code> class (<code>rvzr/traces.py</code>) represents hardware traces collected during execution. The executor produces one <code>HTrace</code> object per program-input pair, meaning that for each <code>TestCaseProgram</code> execution with each <code>InputData</code> input, one <code>HTrace</code> is generated.</p> <p>Each <code>HTrace</code> encapsulates multiple measurements results (samples): This is because the executor typically repeats the execution several times and each execution produces one measurement sample. Such repeated measurements allow us to apply statistical methods when comparing noisy hardware traces (see Trace Analysis below).</p> <p>The structure of an <code>HTrace</code> is as follows:</p> <pre><code>HTrace\n  \u2514\u2500 Array[RawHTraceSample]\n       \u251c\u2500 trace       Main measurement (cache bitmap, timestamp, or registers)\n       \u2514\u2500 pfc0-pfc4   Performance counter values\n</code></pre>"},{"location":"devel/arch-fuzz/","title":"Orchestration Module","text":"Module <code>rvzr/fuzzer.py</code> Public interface <code>Fuzzer</code> Inputs <code>Config</code>, <code>InstructionSet</code>, ASM Template Outputs Violation artifact, logs <p>The <code>Fuzzer</code> class is the main coordinator. It manages the core components (<code>CodeGenerator</code>, <code>DataGenerator</code>, <code>Model</code>, <code>Executor</code>, and <code>Analyser</code>) and orchestrates the fuzzing loop.</p>"},{"location":"devel/arch-fuzz/#main-workflow","title":"Main workflow","text":"<pre><code>Fuzzer.start()\n  \u2514\u2500&gt; for each test case:\n        \u251c\u2500&gt; CodeGenerator.create_test_case() \u2192 TestCaseProgram\n        \u251c\u2500&gt; DataGenerator.generate() \u2192 List[InputData]\n        \u2514\u2500&gt; Fuzzer.fuzzing_round(program, inputs)\n              \u251c\u2500&gt; Model.trace_test_case() \u2192 List[CTrace]\n              \u251c\u2500&gt; Executor.trace_test_case() \u2192 List[HTrace]\n              \u251c\u2500&gt; Analyser.filter_violations() \u2192 List[Violation]\n              \u2514\u2500&gt; if violation: multi-stage filtering pipeline\n</code></pre>"},{"location":"devel/arch-fuzz/#multi-stage-filtering","title":"Multi-stage filtering","text":"<p>When a potential violation is found, the Fuzzer runs it through several validation stages. Each stage modifies parameters and re-checks the violation to rule out false positives:</p> <ol> <li><code>fast</code> \u2014 Initial fast detection using minimal speculative nesting on the model side and small sample size on the executor side</li> <li><code>nesting</code> \u2014 Re-collect ctraces with the model using full speculative nesting. This rules out false positives caused by incomplete speculation modeling</li> <li><code>taint_mistake</code> \u2014 Re-collect ctraces for the boosted inputs to rule out boosting-based generation mistakes</li> <li><code>priming</code> \u2014 Perform a so-called \"priming test\" (swap the order of violating inputs) to rule out false positives caused by inconsistent microarchitectural state across executions</li> <li><code>noise</code> \u2014 Increase sample size on the executor side to increase statistical confidence and rule out noise-induced violations</li> <li><code>arch_mismatch</code> \u2014 Compare the architectural output (i.e., register/memory states) of the model and executor to rule out violations caused by functional mismatches (i.e., by bugs in the model or executor)</li> </ol> <p>If a violation survives all stages, Revizor saves a reproduction package (called \"violation artifact\") containing the test case, inputs, configuration, and detailed report.</p>"},{"location":"devel/arch-fuzz/#fuzzer-variants","title":"Fuzzer variants","text":"<p>The <code>Fuzzer</code> class is abstract. There are several variants modifying the baseline logic:</p> <ul> <li><code>X86Fuzzer</code> / <code>ARM64Fuzzer</code> \u2014 Architecture-specific implementations</li> <li><code>ArchitecturalFuzzer</code> \u2014 Validates model correctness (i.e., performs stage 6 <code>arch_mismatch</code> for all test cases, even non-violating ones)</li> <li><code>ArchDiffFuzzer</code> \u2014 Completely discards the model, and instead compares two hardware executions, one with a normal test case and one with a speculation fence added after every instruction. This variant is used to detect speculation-induced architectural bugs, like zenbleed.</li> </ul>"},{"location":"devel/arch-isa/","title":"Instruction Set Specification","text":"Module <code>rvzr/isa_spec.py</code> Public interface <code>InstructionSet</code> Inputs <code>base.json</code> Outputs <code>InstructionSet</code> <p>This module manages the instruction set available for fuzzing. It loads ISA definitions from a JSON file (<code>base.json</code>) and applies user-configured filters to create a pool of allowed instructions.</p> <p>Each instruction is represented by an <code>InstructionSpec</code> containing instruction name and category, operand specifications, and instruction properties.</p> <p>Processing pipeline:</p> <ol> <li>Load ISA specification from JSON</li> <li>Apply filters (allowlist, blocklist, categories, register restrictions)</li> <li>Remove duplicates</li> <li>Categorize instructions by type (control flow, memory access, etc.)</li> </ol>"},{"location":"devel/arch-logging/","title":"Logging","text":"Module <code>rvzr/logs.py</code> Public interface <code>FuzzLogger</code>, etc. Inputs N/A Outputs Log messages (stdout, stderr) <p>Revizor uses a centralized logging system with configurable verbosity. The system uses the Borg pattern to share state across modules.</p> <p>Available logging modes:</p> <ul> <li>info \u2014 General messages and progress</li> <li>stat \u2014 Statistics</li> <li>dbg_* \u2014 Debug modes for specific components</li> </ul> <p>Logging components:</p> <ul> <li>Basic functions: <code>error()</code>, <code>warning()</code>, <code>inform()</code>, <code>dbg()</code></li> <li>Module-specific loggers: <code>FuzzLogger</code>, <code>GeneratorLogger</code>, <code>ISALogger</code>, <code>ExecutorLogger</code>, <code>AnalyserLogger</code></li> </ul>"},{"location":"devel/arch-mini/","title":"Post-violation Analysis","text":"Module <code>rvzr/postprocessing/</code> Public interface <code>Minimizer</code> Inputs Violation artifact (.asm, .bin) Outputs Minimized test case and inputs <p>After confirming a violation, users can run post-processing to simplify the test case and identify the root cause. The postprocessing module applies minimization passes that reduce complexity while preserving the violation.</p> <p>Class hierarchy:</p> <pre><code>Minimizer\n  \u2514\u2500 Orchestrates passes, manages files\n\nBaseMinimizationPass\n  \u251c\u2500 Instruction passes (modify code)\n  \u251c\u2500 Data passes (modify inputs)\n  \u2514\u2500 Analysis passes (add annotations)\n</code></pre> <p>Instruction passes (operate on test case code):</p> <ul> <li><code>InstructionRemovalPass</code> \u2014 Remove instructions one at a time to find essential ones</li> <li><code>NopReplacementPass</code> \u2014 Replace with NOPs (preserves alignment)</li> <li><code>InstructionSimplificationPass</code> \u2014 Replace complex instructions with simpler ones</li> <li><code>ConstantSimplificationPass</code> \u2014 Simplify immediate values</li> <li><code>MaskSimplificationPass</code> \u2014 Simplify bitmasks</li> <li><code>LabelRemovalPass</code> \u2014 Remove unused labels</li> <li><code>FenceInsertionPass</code> \u2014 Insert fences to identify speculation boundaries</li> </ul> <p>Data passes (operate on inputs):</p> <ul> <li><code>DifferentialInputMinimizerPass</code> \u2014 Use delta debugging to find minimal byte differences</li> <li><code>InputSequenceMinimizationPass</code> \u2014 Reduce number of inputs</li> </ul> <p>Analysis passes (add annotations):</p> <ul> <li><code>AddViolationCommentsPass</code> \u2014 Annotate assembly with memory addresses from execution</li> </ul>"},{"location":"devel/arch-model/","title":"Contract Tracing","text":"Module <code>rvzr/model.py</code> Public interface <code>Model</code> Inputs <code>TestCaseProgram</code>, <code>InputData</code> Outputs <code>CTrace</code>"},{"location":"devel/arch-model/#model","title":"Model","text":"<p>The Model executes test cases according to a leakage contract and produces contract traces (CTraces). These represent the information expected to leak during execution, including speculative execution.</p> <p>Revizor supports two model backends:</p> <ul> <li>Unicorn: This backend is based on the Unicorn CPU emulator. It implements the contract by hooking into instruction execution and memory access events. Documentation is provided in Unicorn Backend.</li> <li>DynamoRIO: This backend uses DynamoRIO for dynamic binary instrumentation. It instruments the test case to insert hooks for tracing and speculation simulation. Documentation is provided in DynamoRIO Backend.</li> </ul> <p>Both implement the same interface defined by the abstract <code>Model</code> class.</p>"},{"location":"devel/arch-model/#contract-trace-representation","title":"Contract Trace Representation","text":"<p>A <code>CTrace</code> is a sequence of typed observations representing leaked information:</p> <pre><code>CTrace\n  \u2514\u2500 List[CTraceEntry]\n       \u251c\u2500 mem    Memory address\n       \u251c\u2500 pc     Program counter\n       \u251c\u2500 val    Data value\n       \u251c\u2500 reg    Register value\n       \u2514\u2500 ind    Indirect branch target\n</code></pre> <p>CTraces use <code>xxhash</code> for fast equality checking, enabling efficient grouping into equivalence classes.</p>"},{"location":"devel/arch-overview/","title":"Architecture Overview &amp; Code Structure","text":"<p>This document introduces Revizor's architecture and key components. It is designed to provide an overview of how the codebase is organized and how the main pieces work together.</p> <p>Prerequisites</p> <p>This document assumes familiarity with the concepts of side-channel attacks, speculative execution, and Speculation Contracts and Model-based Relational Testing (MRT).</p>"},{"location":"devel/arch-overview/#how-revizor-works","title":"How Revizor Works","text":"<p>Revizor detects CPU security vulnerabilities using Model-based Relational Testing (MRT). The core idea is to compare what a CPU should leak (according to a leakage model) with what it actually leaks during execution.</p> <p>Basic process:</p> <ol> <li>Generate random assembly programs</li> <li>Execute them on both a leakage model and real hardware</li> <li>Compare the observed hardware behavior with the model's predictions</li> <li>If they match, the CPU behaves as expected (discard the test)</li> <li>If they differ, a potential vulnerability has been found</li> </ol> <p>The leakage model acts as a reference model of the expected CPU behavior. If the real CPU leaks more information than the model predicts (i.e., if it diverges from the reference), this indicates a potential security vulnerability. For details on how leakage models work, see Speculation Contracts.</p> <p>Revizor runs the following loop until it finds a violation or completes the configured number of test cases:</p> <p></p>"},{"location":"devel/arch-overview/#1-initialization","title":"1. Initialization","text":"<p>This step runs once at startup. Revizor reads the fuzzing configuration, which specifies:</p> <ul> <li>Target CPU architecture</li> <li>ISA (instruction set) specification</li> <li>Which instructions to test</li> <li>Which side channels to monitor</li> <li>Other fuzzing parameters</li> </ul> <p>The <code>cli.py</code> module handles command-line arguments and creates the main objects: <code>InstructionSet</code> (from <code>isa_spec.py</code>), <code>Config</code> (from <code>config.py</code>), and <code>Fuzzer</code> (from <code>fuzzer.py</code>).</p>"},{"location":"devel/arch-overview/#2-code-generation","title":"2. Code Generation","text":"<p>Each fuzzing round starts by generating a random test program. This is an assembly program with semi-random control flow, built from a pool of allowed instructions.</p> <p>The code generator can be configured to control the shape of the control flow graph, which instructions to include, and how often each instruction appears. It also (optionally) instruments the program to prevent faults like division by zero.</p> <p>The <code>Fuzzer</code> calls <code>CodeGenerator.create_test_case()</code> (in <code>code_generator.py</code>), which returns a <code>TestCaseProgram</code> object representing the generated assembly program.</p>"},{"location":"devel/arch-overview/#3-data-generation","title":"3. Data Generation","text":"<p>Next, Revizor generates random inputs for the test program. Each input contains initial values for registers and memory. These values are pseudo-random but use fixed seeds for reproducibility.</p> <p>The <code>DataGenerator</code> class (in <code>data_generator.py</code>) creates these inputs and returns them as <code>InputData</code> objects. See binary formats for the structure of input data.</p>"},{"location":"devel/arch-overview/#35-test-case-filtering-optional","title":"3.5 Test Case Filtering (Optional)","text":"<p>Some test cases are unlikely to reveal vulnerabilities, so Revizor can filter them out early to save time. This is optional and disabled by default.</p> <p>Two filters are available:</p> <ul> <li>Speculation filter: Uses performance counters to check if the test case triggers branch mispredictions. Without mispredictions, the test cannot expose speculative leaks.</li> <li>Observation filter: Compares the original test case with a \"fenced\" version (with serialization instructions added). If both produce identical traces, speculation left no observable effects.</li> </ul> <p>These filters are implemented in architecture-specific fuzzer classes (like <code>X86Fuzzer</code> in <code>rvzr/arch/x86/fuzzer.py</code>).</p>"},{"location":"devel/arch-overview/#4-model-execution","title":"4. Model Execution","text":"<p>The model executes the test program with each generated input and produces contract traces (CTraces). These traces represent what the model predicts should leak during execution.</p> <p>The <code>Model</code> class (in <code>model.py</code>) provides two key methods:</p> <ul> <li><code>load_test_case()</code>: Loads the program into the model</li> <li><code>trace_test_case()</code>: Executes the program with each input and returns CTraces</li> </ul> <p>Revizor supports multiple model backends: Unicorn (CPU emulator) and DynamoRIO (dynamic instrumentation). Both implement the same interface.</p>"},{"location":"devel/arch-overview/#5-hardware-execution","title":"5. Hardware Execution","text":"<p>The executor runs the test program on the target hardware with each input and collects hardware traces (HTraces). A hardware trace is a set of observable microarchitectural effects (like cache state or timing) caused by the test case execution. Traces are typically collected using side-channel techniques (e.g., Prime+Probe, Flush+Reload) or by reading performance counters.</p> <p>To ensure that the measurements reflect the test case execution (rather than noise), the executor creates a controlled measurement environment by disabling interrupts, flushing caches, and repeating executions multiple times.</p> <p>The <code>Executor</code> class (in <code>executor.py</code>) works through a kernel module (<code>executor_km/</code>) that performs measurements in kernel space. It provides the same interface as the model: <code>load_test_case()</code> and <code>trace_test_case()</code>.</p>"},{"location":"devel/arch-overview/#6-trace-analysis","title":"6. Trace Analysis","text":"<p>The analyzer compares contract traces (what should leak) with hardware traces (what actually leaked) to detect violations. Instead of directly comparing traces, it uses an equivalence class approach.</p> <p>How it works:</p> <ol> <li>Group by contract: Inputs with identical CTraces form a ContractEqClass. According to the model, these inputs should be indistinguishable.</li> <li>Group by hardware: Within each ContractEqClass, inputs with similar HTraces form HardwareEqClasses. These inputs are actually indistinguishable on real hardware.</li> <li>Detect violations: If a ContractEqClass splits into multiple HardwareEqClasses, a violation has occurred. The model says the inputs should look the same, but hardware reveals differences between them.</li> </ol> <p>This approach focuses on information leakage rather than exact trace values, and it essentially implements a non-interference check (see Theoretical Foundations).</p> <p>The <code>Analyser</code> class (in <code>analyser.py</code>) implements this logic in its <code>filter_violations()</code> method.</p>"},{"location":"devel/arch-overview/#7-post-violation-analysis","title":"7. Post-violation Analysis","text":"<p>When Revizor detects a potential violation, it runs additional tests to filter out false positives. These tests modify execution parameters and verify the violation still occurs. See post-violation tests for details.</p> <p>If the violation survives all filters, Revizor reports it to the user and saves reproduction artifacts. The user can then use minimization tools to simplify the test case and identify the root cause.</p> <p>The post-violation logic is implemented in <code>Fuzzer.fuzzing_round()</code>, and the <code>FuzzLogger</code> class handles reporting.</p>"},{"location":"devel/binary-formats/","title":"Binary Formats in Revizor","text":"<p>This document describes the structure of the custom binary formats used by Revizor to transfer test cases and their data between different components. For example, these formats are used to pass generated test cases from the executor (python) class to the executor kernel module.</p> <p>Such custom formats are necessary because the components are implemented in different programming languages and different technologies, so passing objects directly is not possible. Using one of the standard formats (e.g., ELF) is also not an option because test cases in Revizor have special structure (e.g., multiple actors in different execution modes, some instructions are macros, etc.) and this structure is not supported by the standard formats.</p> <p>The formats are designed to as simple as possible to minimize the overhead of serialization and deserialization.</p>"},{"location":"devel/binary-formats/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Binary Formats in Revizor</li> <li>Table of Contents</li> <li>Revizor Code Binary Format (RCBF)</li> <li>Revizor Data Binary Format (RDBF)</li> </ul>"},{"location":"devel/binary-formats/#revizor-code-binary-format-rcbf","title":"Revizor Code Binary Format (RCBF)","text":"<p>RCBF is a structured representation of the complete test case binary, together with its metadata. The structure is as follows:</p> <pre><code>|---------------------------------------|\n| n_actors (8 bytes)                    | HEADER       |\n| n_symbols (8 bytes)                   |\n| ------------------------------------- |\n| actor metadata:                       | ACTOR TABLE  |\n| - id (8 bytes)                        |\n| - mode (8 bytes)                      |\n| - pl (8 bytes)                        |\n| - data_permissions (8 bytes)          |\n| - data_ept_permissions (8 bytes)      |\n| - code_permissions (8 bytes)          |\n| x n_actors                            |\n| ------------------------------------- |\n| symbol entry:                         | SYMBOL TABLE |\n| - owner (8 bytes)                     |\n| - offset (8 bytes)                    |\n| - id (8 bytes)                        |\n| - args (8 bytes)                      |\n| x n_symbols                           |\n| ------------------------------------- |\n| section metadata entry:               | METADATA     |\n| - owner (8 bytes)                     |\n| - size (8 bytes)                      |\n| - reserved (8 bytes)                  |\n| x n_actors                            |\n| ------------------------------------- |\n| code section:                         | DATA         |\n| - code (char *)                       |\n| x n_actors                            |\n| ------------------------------------- |\n</code></pre> <p>The file begins with a header containing the number of actors (it is also the number of sections) and the number of symbols in the test case. The term \"symbol\" in this context refers to any location in the test case that can be referenced. Two common types of symbols are functions (specifically, function entry points) and macros.</p> <p>Next, the file contains the actor table, which is an array of actor metadata entries, one for each actor in the test case. The actor metadata entry contains the actor's ID, execution mode, protection level, data permissions, EPT data permissions, and code permissions.</p> <p>After the actor table, the file contains the symbol table, which is an array of symbol entries, one for each symbol in the test case. The symbol entry contains the ID the section to which the symbol belongs, the offset of the symbol within the section, the symbol's ID, and the number of arguments the symbol takes (if it is a macro).</p> <p>The file continues with the table of metadata for each section in the test case. Each metadata entry contains the ID of the actor that owns the section and the size of the section.</p> <p>Finally, the file contains a sequence of code sections, one for each actor in the test case. These sections contain the actual assembled binary for each of the sections in the test case.</p>"},{"location":"devel/binary-formats/#revizor-data-binary-format-rdbf","title":"Revizor Data Binary Format (RDBF)","text":"<p>RDBF is a structured representation of the data used to initialize sandbox memory and registers before executing the test case.</p> <p>Note that this format combines multiple inputs into a single file. This is done because typically, a single test case program is executed multiple times with different inputs, and so it is more efficient to send a batch of inputs at once.</p> <pre><code>|---------------------------------------|\n| n_actors (8 bytes)                    | HEADER\n| n_inputs (8 bytes)                    |\n| ------------------------------------- |\n| section metadata entry:               | METADATA |\n| - section_size (8 bytes)              |\n| - reserved (8 bytes)                  |\n| x (n_actors * n_inputs)               |\n| ------------------------------------- |\n| input:                                | DATA     |\n| - data section:                       |\n| -- main_area (4096 bytes)             |\n| -- faulty_area (4096 bytes)           |\n| -- reg_init_region (4096 bytes)       |\n| - x n_actors                          |\n| x n_inputs                            |\n| ------------------------------------- |\n</code></pre> <p>The file begins with a section containing the number of actors (equal to the number of sections) and the number of inputs in the batch.</p> <p>Next, the file contains the table of metadata for each data section, which only contains the size of the section.</p> <p>Finally, the file contains a sequence of data sections, one for each actor in the test case and each input in the batch. The data sections are arranged to mirror the data layout in the sandbox memory (see the sandbox memory layout document for more information).</p>"},{"location":"devel/code-structure/","title":"Code Structure","text":"<p>The Revizor codebase is organized into the following main directories:</p> <pre><code>rvzr/                         Main source code directory containing core fuzzing logic\n  \u251c\u2500\u2500 *.py                    Core modules that implement main fuzzing components\n  \u251c\u2500\u2500 tc_components/          Test case representation objects (code and data)\n  \u251c\u2500\u2500 model_unicorn/          Unicorn-based leakage model\n  \u251c\u2500\u2500 model_dynamorio/        DynamoRIO-based leakage model\n  \u251c\u2500\u2500 executor_km/            Kernel module that implements the hardware executor\n  \u251c\u2500\u2500 postprocessing/         Minimization utilities for contract counterexamples\n  \u2514\u2500\u2500 arch/                   Architecture-specific implementations (x86/ and arm64/)\ntests/                        Unit and integration tests\ndocs/                         Documentation files\n</code></pre> <p>The main entry point is <code>rvzr/cli.py</code>, which parses command-line arguments and initializes the <code>Fuzzer</code> object.</p>"},{"location":"devel/guidelines-code-style/","title":"Code Style","text":"<p>Please follow these coding standards when writing code for inclusion in Revizor.</p>"},{"location":"devel/guidelines-code-style/#python","title":"Python","text":"<ul> <li>Unless otherwise specified, follow PEP 8. But remember that PEP 8 is only a guide, so respect the style of the surrounding code as a primary goal.</li> <li>An exception to PEP 8 is our rules on line lengths. Don\u2019t limit lines of code to 79 characters if it means the code looks significantly uglier or is harder to read. We allow up to 100 characters.</li> <li>All files should be formatted using the <code>flake8</code> auto-formatter. Use all default settings except for the line width (<code>--max-line-length 100</code>)</li> <li>The Python and C files use 4 spaces for indentation, and YAML uses 2 spaces.</li> <li>The project repository includes an .editorconfig file. We recommend using a text editor with EditorConfig support to avoid indentation and whitespace issues.</li> <li>Use underscores, not camelCase, for variable, function and method names (i.e. poll.get_unique_voters(), not poll.getUniqueVoters()).</li> <li>Use InitialCaps for class names (or for factory functions that return classes).</li> <li>In docstrings, follow PEP 257.</li> </ul>"},{"location":"devel/guidelines-code-style/#c","title":"C","text":"<ul> <li>All files should be formatted using the <code>clang-format</code>. The settings are included into the <code>.clang-format</code> files in the directories with C files. Just run the formatter with: <code>clang-format -i *.c</code></li> </ul>"},{"location":"devel/guidelines-code-style/#misc","title":"Misc","text":"<ul> <li>Remove import statements that are no longer used when you change code. flake8 will identify these imports for you. If an unused import needs to remain for backwards-compatibility, mark the end of with <code># NOQA</code> to silence the flake8 warning.</li> <li>Systematically remove all trailing whitespaces from your code as those add unnecessary bytes, add visual clutter to the patches and can also occasionally cause unnecessary merge conflicts. Some IDE\u2019s can be configured to automatically remove them and most VCS tools can be set to highlight them in diff outputs.</li> </ul>"},{"location":"devel/guidelines-general/","title":"General Development Guidelines","text":""},{"location":"devel/guidelines-general/#testing","title":"Testing","text":"<p>To run automated tests you will need to install a few more dependencies:</p> <ul> <li>Bash Automated Testing System</li> <li>mypy</li> <li>flake8</li> </ul> <p>With the dependencies installed, you can run the tests with:</p> <pre><code>./tests/runtests.sh\n</code></pre> <p>Note that some of the acceptance tests are microarchitecture-dependent. These tests are labeled \"Detection\" (e.g., <code>\"Detection [spectre-type] Spectre V1; load variant\"</code>), and they may fail if the CPU under test does not have a given vulnerability. Generally, if a few of these tests fail, it is not a problem, but if all of them (or a significant portion) fail, it indicates an issue with the fuzzer.</p>"},{"location":"devel/guidelines-general/#submitting-patches","title":"Submitting Patches","text":"<p>To submit a patch, use the following procedure:</p> <ul> <li> <p>Fork Revizor on github:</p> <p>https://docs.github.com/en/github/getting-started-with-github/fork-a-repo</p> </li> <li> <p>Create a topic branch:</p> </li> </ul> <pre><code>git checkout -b my_branch\n</code></pre> <ul> <li>Make sure all tests pass (see Testing)</li> <li>Make sure your code follows the guidelines in Code Style</li> <li>Push to your branch</li> </ul> <pre><code>git push origin my_branch\n</code></pre> <ul> <li> <p>Initiate a pull request on github:</p> <p>https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request</p> </li> <li> <p>Wait for the PR to get reviewed and merged</p> </li> </ul>"},{"location":"devel/guidelines-general/#contributor-license-agreement-and-code-of-conduct","title":"Contributor License Agreement and Code of Conduct","text":"<p>Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com.</p> <p>When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.</p> <p>This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"devel/guidelines-git/","title":"Git Workflow Guidelines","text":""},{"location":"devel/guidelines-git/#git-messages","title":"Git Messages","text":"<p>We practice the following conventions for commit messages:</p> <pre><code>&lt;scope&gt;: [&lt;type&gt;] &lt;subject&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;scope&gt;</code>: The scope of the change.</li> <li><code>&lt;type&gt;</code>: The type of the change.</li> <li><code>&lt;subject&gt;</code>: A short description of the change.</li> </ul>"},{"location":"devel/guidelines-git/#scopes","title":"Scopes","text":"<p>The following scopes are typical:</p> Scope Description <code>all</code> Changes that affect the entire project (e.g., major refactoring) <code>root</code> Root directory changes (e.g., readme, git, author list) <code>fuzz</code> Changes to the core fuzzer algorithm. <code>cli</code> Changes to the command-line interface. <code>exec</code> Changes to the executor. <code>model</code> Changes to the model. <code>analyser</code> Changes to the analyser. <code>mini</code> Changes to the postprocessor (i.e., minimizer). <code>code_gen</code> Changes to the program generator <code>data_gen</code> Changes to the input generator <code>tests</code> Changes to the tests <code>isa</code> Changes to the ISA loader or to <code>get_spec</code> files <p>If a commit covers several scopes, use the most relevant one.</p> <p>If a commit targets a specific architecture (e.g., x86), add the architecture to the scope (e.g., <code>fuzz/x86</code>).</p>"},{"location":"devel/guidelines-git/#types","title":"Types","text":"<p>Use one of the following types:</p> Type Description <code>feat</code> A new feature. <code>fix</code> A bug fix. <code>docs</code> Documentation changes. <code>chore</code> Changes to the build process or auxiliary tools. <code>ft</code> Fault tolerance changes (e.g., adding error handling or recovery mechanisms). <code>refact</code> Refactoring of the codebase. This includes code style change. <code>perf</code> Performance improvements. <code>revert</code> Reverts a previous commit. <p>If possible, try to use only these types. If you need to use a different type, please discuss it with a maintainer.</p>"},{"location":"devel/guidelines-git/#git-branches","title":"Git Branches","text":"<p>We practice the git workflow, with a few modifications.</p> <p></p> <p>We use the following branches for graduation:</p> <ul> <li><code>main</code>: The latest release. This branch should always be stable, and it is the last branch to receive changes.</li> <li><code>main-fixes</code>: Commits that go in the next maintenance release. This branch is created from the last release branch.</li> <li><code>dev</code>: The development branch. This branch is the first to receive changes.</li> </ul> <p>Commits should be merged upwards:</p> <ul> <li><code>dev</code> -&gt; <code>pre-release</code> -&gt; <code>main</code></li> <li>In case of hot fixes, <code>main-fixes</code> -&gt; <code>main</code> AND <code>main-fixes</code> -&gt; <code>pre-release</code></li> </ul> <p>For working on unstable code (e.g., progress on features or bug fixes), use either forks or feature branches. Use forks if you are the only one working on the feature, and use a pull request to merge the changes back into the main repository. Use a feature branch if multiple people are working on the feature, in which case name the branch <code>feature-&lt;name&gt;</code> or <code>bugfix-&lt;name&gt;</code>, and make sure to branch from the <code>dev</code> branch.</p> <p>The only exception is the <code>gh-pages</code> branch, which is used for the project's website. This branch is used by automated tools and should never be used for development.</p>"},{"location":"devel/macros/","title":"Macros","text":"<p>UNDER CONSTRUCTION</p> <p>If you are interested in this topic, please contact us by opening an issue on GitHub, and we will prioritize this document.</p>"},{"location":"devel/model-dr/","title":"DynamoRIO-based Model Backend","text":"<p>This document describes the DynamoRIO-based model. As any other model, this backend is responsible for collecting contract traces for generated test cases.</p>"},{"location":"devel/model-dr/#design-overview","title":"Design Overview","text":"<p>This backend is composed of several parts:</p> <ul> <li>The Python adapter (<code>rvzr/model_dynamorio/model.py</code>) is responsible for receiving a test case from Revizor, transforming it into a format that can be executed by the backend, triggering the backend to execute the test case, and returning the collected contract traces to Revizor.</li> <li>The Test Case Loader (<code>rvzr/model_dynamorio/adapter.c</code>) is a C program that loads a test case program and a batch of inputs into its memory, and executes the test case program with each input in a sequence.</li> <li>The DynamoRIO components (<code>rvzr/model_dynamorio/backend</code>) are executed together with the test case loader, and they instrument the loader binary to collect contract traces.</li> </ul> <p>These components can be roughly divided into the instrumentation-time components that are responsible for modifying the binary, and execution-time components that implement the model logic (i.e., the contract).</p> <p></p>"},{"location":"devel/model-dr/#python-adapter","title":"Python Adapter","text":"<p>Revizor communicates with the backend through a Python adapter (<code>rvzr/model_dynamorio/model.py:DynamoRIOModel</code>).</p> <p>At the beginning of the fuzzing process, Revizor configures the backend by calling <code>configure_clauses</code> method. This configuration will be later passed down to the backend when the test case is executed.</p> <p>During the fuzzing process, Revizor sends test cases to the backend by calling <code>load_test_case</code> method, and then triggers the backend to execute the test case by calling <code>trace_test_case</code> method. Internally, <code>trace_test_case</code> will call the backend to execute the test case and collect the contract traces. The adapter will then parse the traces and return them back to the caller.</p> <p>The <code>trace_test_case</code> method implements the following algorithm:</p> <ul> <li>Convert test case program and inputs into RCBF and RDBF files, respectively</li> <li>For each input, call the test case loader with the RCBF and RDBF files. Attach the DynamoRIO backend to the call so that the binary instrumentation is performed: <pre><code>~/.local/dynamorio/drrun -c ~/.local/dynamorio/libdr_model.so --tracer &lt;observation-clause&gt; -- ~/.local/dynamorio/adapter &lt;rcbf&gt; &lt;rdbf&gt;\n</code></pre></li> <li>Parse contract traces from the backend and convert them into <code>CTrace</code> objects</li> <li>Return the list of collected <code>CTrace</code> objects to the caller (usually, <code>fuzzer.py</code>)</li> </ul>"},{"location":"devel/model-dr/#test-case-loader","title":"Test Case Loader","text":"<p>Since the test cases produced by Revizor are raw binaries, they cannot be directly executed (e.g., they don't have <code>libc</code> linked). The test case loader (<code>rvzr/model_dynamorio/adapter.c</code>) is a simple C program that fixes this issue by providing a wrapper around the test case binary.</p> <p>The loader implements the following algorithm:</p> <ul> <li>Receive the test case binary and an input from the Python adapter via CLI arguments</li> <li>Load the test case binary and the input into dedicated memory regions</li> <li>Print the addresses of the test case and input memory regions (for trace normalization)</li> <li>Initialize registers based on the input</li> <li>Jump to the test case binary entry point</li> <li>Return</li> </ul>"},{"location":"devel/model-dr/#dynamorio-tool","title":"DynamoRIO Tool","text":"<p>The DynamoRIO tool (<code>rvzr/model_dynamorio/backend</code>) is responsible for instrumenting the test case loader binary and collecting contract traces.</p>"},{"location":"devel/model-dr/#implementation-overview","title":"Implementation Overview","text":"<p>All instrumentation logic is implemented as a DynamoRIO client. In particular, <code>model.cpp</code> contains the event callbacks that are executed at instrumentation time, while <code>dispatcher.cpp</code> contains the body of the callbacks that are inserted by the DR client and are executed before every instruction at runtime. Finally, the <code>Dispatcher</code> object holds the state that is shared between instrumentation-time callbacks and execution-time callbacks.</p> <p>The following figure provides an overview of the implementation.</p> <p></p> <ol> <li><code>dr_client_main()</code> is responsible of installing the initial instrumentation callbacks to hook all relevant DR events (<code>module_load</code>, <code>bb_translation</code>, exceptions and the <code>exit</code> event)</li> <li><code>dr_client_main()</code> also sets the name of the function to instrument (passed by <code>cli.cpp</code>)</li> <li>on <code>module_load</code>, the instrumentation checks for the presence of the target function in the loaded module. If found, the callback adds a <code>drwarp</code> callback (<code>event_instrumentation_start</code>) which will be executed at the start of the target function</li> <li>once a call to the target function is found, the <code>event_instrumentation_start</code> will save the return address in a global object (<code>instrumented_func</code>) and call <code>start()</code> on the dispatcher</li> <li>from that moment on, every translated basic block is instrumented by our client, in particular:<ul> <li>a <code>dispatch_callback()</code> is inserted before every instruction</li> <li>at the function exit point (i.e. the previously saved return addres) an <code>exit_callback</code> is inserted</li> </ul> </li> <li>these callbacks are executed at runtime with the following effects:<ul> <li>the <code>dispatch_callback()</code> implements the observation and execution clauses (see next section)</li> <li>the <code>exit_callback()</code> checks the current speculation state before exiting:<ul> <li>speculative exits cause a rollback</li> <li>architectural exit causes the instrumentation to stop</li> </ul> </li> </ul> </li> </ol> <p>Finally, exceptions and the <code>exit</code> event are also forwarded to the Dispatcher:</p> <ul> <li>Speculative exceptions will cause a rollback, while architectural ones are forwarded to the target program</li> <li>The exit event stops instrumentation and flushes all logs (in case the exit callback has not been executed architecturally)</li> </ul>"},{"location":"devel/model-dr/#instrumentation-components","title":"Instrumentation Components","text":"<p>The instrumentation components modify the binary of the test case loader by adding a call to the function <code>dispatch_callback</code> before every instruction in the binary (or more specifically, every instruction in the <code>test_case_entry</code> function of the loader).</p> <p>The tool interacts with DynamoRIO through the <code>model.cpp</code> module. This module registers an event for entering the <code>test_case_entry</code>, which triggers the flush of the internal DynamoRIO code fragment cache and the start of instrumentation. The module also registers an event for every instruction in the <code>test_case_entry</code>, and the event in turn calls the <code>Dispatch::instrument_instruction()</code>. Finally, exceptions are hooked and passed to the dispatcher through <code>Dispatch::handle_exception()</code>, which can decide to either handle the signal (e.g. on speculative paths) or forward it to the test case (e.g. architectural exceptions).</p> <p>The <code>Dispatch</code> class implements the actual instrumentation logic. When the <code>instrument_instruction()</code> method is called, it inserts a clean call to the <code>dispatch_callback</code> function before the instruction. The call receives the PC and opcode of the instruction as arguments. DynamoRIO also automatically saves the complete register state before the call, thus making it available to <code>dispatch_callback</code>.</p>"},{"location":"devel/model-dr/#execution-time-components","title":"Execution-Time Components","text":"<p>The execution-time components are responsible for implementing the contract logic, and are triggered by the <code>dispatch_callback</code> function. At the current state of the backend, the dispatch callback invokes only two classes, Tracer and Speculator, that implement the observation and execution clauses, respectively. Optionally, each component can log additional events, e.g. speculation rollbacks or the current register state, through a shared <code>Logger</code> component.</p> <p>Subclasses of <code>TracerABC</code> record contract-relevant information via <code>observe_instruction</code> and <code>observe_mem_access</code> methods. E.g., <code>TracerCT</code> implements <code>CT</code> observation clause by recording the PC of instructions upon <code>observe_instruction</code> and the address of memory accesses upon <code>observe_mem_access</code>. Currently, <code>observe_exception</code> simply adds a special entry to the trace to indicate that the program ended due to an (architectural) exception.</p> <p>Subclasses of <code>SpeculatorABC</code> implement the contract speculation logic. E.g., <code>SpeculatorCond</code> implements <code>speculate_instruction</code>. When this method is called with a branch instruction, the class takes a checkpoint of the process state, flips the branch condition (i.e., modified <code>FLAGS</code> register), and continues the execution. During the simulated speculation, each call to <code>speculate_instruction</code> counts the number of executed instructions, and when the number reaches the limit (e.g., 256), the class restores the checkpoint and continues the execution from the original state. (Actually, the algorithm is more complex, but this is the general idea.)</p> <p>When the instrumentation ends (according to <code>model.cpp</code>), the tracer's <code>tracing_finalized</code> method is called, during which any remaining traces are flushed into the trace file, together with an \"End Of Trace\" entry. The Python adapter will then read the trace file, decode it, and return the corresponding CTrace to Revizor.</p>"},{"location":"devel/model-dr/#standalone-usage","title":"Standalone Usage","text":"<p>The DR tool can be used as a standalone tool to collect the runtime trace of any program, independently from the rest of Revizor's infrastructure.</p> <p>A typical usage is for example:</p> <pre><code>~/.local/dynamorio/drrun -c ~/.local/dynamorio/libdr_model.so --tracer &lt;observation-clause&gt; --speculator &lt;speculation-clause&gt; -- ls /dev/null\n</code></pre> <p>By default, this will instrument <code>ls</code> starting from <code>__libc_start_main</code> until the end of the program, run it with <code>/dev/null</code> as an argument, and generate a binary file called <code>rvzr_trace.dat</code> that contains the collected trace. Other flags can be printed using <code>~/.local/dynamorio/drrun -c ~/.local/dynamorio/libdr_model.so -h</code></p> <p>The trace file location can be changed by adding <code>--trace-output &lt;PATH&gt;</code>. Additionally, the tool can also dump the trace in human-readable format to STDOUT using the <code>--print-trace</code> flag.</p> <p>To decode and analyze the trace file, downstream tools should always use the <code>TraceDecoder</code> class provided by <code>trace_decoder.py</code>. For internal usage, this module also provides a simple entrypoint for trace printing:</p> <pre><code>python3 trace_decoder.py rzvr_trace.dat\n</code></pre>"},{"location":"devel/model-dr/#debugging","title":"Debugging","text":"<p>Attaching a debugger like GDB to the DR tool might not always be the best debugging option, as the program has three separate states:</p> <ol> <li>the state of the program being instrumented (e.g. <code>ls</code>)</li> <li>the state of the DR client (<code>libdr_model.so</code>) instrumentation</li> <li>the state of DynamoRIO itself (<code>drrun</code>)</li> </ol> <p>More information about debugging DR clients can be found here.</p> <p>For our instrumentation, other (possibly simpler) options are available:</p> <ol> <li>Inspecting Debug Traces: the DR tool can optionally log extra information, e.g. the complete state of the register file before each instruction, each value being read and written to memory, and speculation events like checkpoints are rollbacks, in a separate debug trace:<ul> <li>This option can be enabled using <code>--log-level &lt;N&gt;</code></li> <li>By default, the tool will dump debug entries to <code>rzvr_dbg_trace.dat</code> in binary format; to change the path of the debug trace file use <code>--debug-output &lt;PATH&gt;</code></li> <li><code>--print-debug-trace</code> can be used to pretty-print debug entries to STDOUT during execution</li> <li><code>trace_decoder.py</code> also provides a decoder for debug entries</li> <li>WARNING: debug traces can become very big, especially for nested speculation</li> </ul> </li> <li>Running DynamoRIO with logging: DynamoRIO can also produce logs (see DR documentation):</li> </ol> <pre><code>~/.local/dynamorio/drrun -debug -loglevel 3 -c ~/.local/dynamorio/libdr_model.so --tracer &lt;observation-clause&gt; --speculator &lt;speculation-clause&gt; -- ls /dev/null\n</code></pre>"},{"location":"devel/model-unicorn/","title":"Unicorn Backend","text":"<p>Unicorn backend architecture:</p> <pre><code>UnicornModel (main orchestrator)\n  \u251c\u2500 UnicornTracer            Records observations (PC, memory addresses, etc.)\n  \u251c\u2500 UnicornSpeculator        Simulates speculative execution\n  \u251c\u2500 UnicornTaintTracker      Tracks data flow for boosted input generation\n  \u251c\u2500 ExtraInterpreter         Handles features Unicorn doesn't support\n  \u2514\u2500 InstructionCoverage      Tracks which instructions were tested\n</code></pre> <p>Key components:</p> <ul> <li><code>UnicornModel</code>:   Manages the emulator and coordinates components through hooks on instruction and memory events.</li> <li><code>UnicornTracer</code>:   Implements the observation clause of the contract. Different tracers record different information (program counters, memory addresses, data values).</li> <li><code>UnicornSpeculator</code>:   Implements the speculation clause using checkpoint-rollback mechanisms. When speculation triggers (branch misprediction, CPU exception), it saves state and executes speculatively up to a window limit (default 250 instructions). It rolls back on serializing instructions or window expiration.</li> <li><code>UnicornTaintTracker</code>:   Performs dynamic taint analysis to identify which input bytes affect the contract trace. Used for boosted input generation.</li> </ul>"},{"location":"devel/registers/","title":"Register Allocation","text":"<p>The test cases are executed in a sandboxed environment, where some of the registers are reserved for internal use, and some are available for use in the test cases. Below is a list of registers and their purpose.</p>"},{"location":"devel/registers/#r15","title":"<code>R15</code>","text":"<p>Contains the base address of the UTILITY area in the sandbox.</p> <p>If the test case does not enter a VM, the register value remains constant during the execution of the test cases. Otherwise, the register value is updated to point to the UTILITY area of the currently active VM when the <code>switch_h2g</code> macro is called, and it is restored to the original value when the <code>switch_g2h</code> macro is called.</p> <p>The register is used by internal functions, such as the implementation of Prime+Probe.</p>"},{"location":"devel/registers/#r14","title":"<code>R14</code>","text":"<p>Contains the base address of the current actor's sandbox (namely, it points to the base of the actor's MAIN area).</p> <p>At the beginning of the test case execution, the register is set to the base address of the MAIN area of the first actor (actor <code>main</code>). The register value is updated to point to the MAIN area of the currently active actor when a macro from the <code>landing_*</code> group of macros is called. It is also updated by the <code>fault_handler</code> macro.</p> <p>The register is used in test cases as a part of the sandboxing mechanism. For example, all generated memory accesses are relative to the value stored in <code>R14</code>, and have the form of <code>[R14 + offset]</code>.</p>"},{"location":"devel/registers/#r13-htrace_register-constant-in-the-kernel-module","title":"<code>R13</code> (<code>HTRACE_REGISTER</code> constant in the kernel module)","text":"<p>Contains either intermediate or final result of the hardware trace measurements.</p> <p>Before entering the test case, the register is set to 0. When a <code>measurement_start</code> macro is executed, the register is (optionally) set to the starting value, such a initial reading of time stamp counter when the <code>TSC</code> mode is used. When a <code>measurement_end</code> macro is executed, the register is updated with the final value of the measurement and contains the resulting hardware trace.</p>"},{"location":"devel/registers/#r12-status_register-constant-in-the-kernel-module","title":"<code>R12</code> (<code>STATUS_REGISTER</code> constant in the kernel module)","text":"<p>Contains a compressed status of the test case execution:</p> <p>Bits[0:7] contain a measurement status. At the beginning of the test case execution, the bits are set to 0. When <code>measurement_start</code> macro is executed, the bits are set to 1. When <code>measurement_end</code> macro is executed, the bits are set to 2. If the measurement status is not 2 at the end of the test case execution, the kernel module will report an error.</p> <p>Bits[8:31] are unused.</p> <p>Bits[32:63] contain a counter of SMI (System Management Interrupt) events. The counter is set automatically before entering the test case (<code>READ_SMI_START</code>), and updated when the test case finishes (<code>READ_SMI_END</code>). If the difference between the readings is not 0, the kernel module will report an error.</p>"},{"location":"devel/registers/#r11","title":"<code>R11</code>","text":"<p>The register is used as a temporary buffer by some of the macros.</p> <p>Before entering the test case, the register is set to 0. When certain macros are executed (e.g., <code>set_k2u_target</code>), the register will contain temporary values. The register should not be used in the test case, as the temporary value may be consumed by latter macros.</p>"},{"location":"devel/registers/#r10-r9-r8","title":"<code>R10, R9, R8</code>","text":"<p>Stores the values of performance counters. <code>R10</code> stores the value of performance counter #1, <code>R9</code> stores the value of performance counter #2, and <code>R8</code> stores the value of performance counter #3.</p> <p>Before entering the test case, the registers are set to 0. When a <code>measurement_start</code> macro is executed, the registers are (optionally) set to the starting values. When a <code>measurement_end</code> macro is executed, the registers are updated with the final values of the measurements.</p>"},{"location":"devel/registers/#other-general-purpose-registers","title":"Other General Purpose Registers","text":"<p>The remaining registers (<code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>rflags</code>) are available for use in the test cases and can be modified freely. A special case are <code>rsp</code> and <code>rbp</code>, which can be used in the test cases, but their values must always remain within the sandbox (see Sandbox).</p>"},{"location":"devel/registers/#vector-registers","title":"Vector Registers","text":"<p>Vector registers (<code>xmm0</code>-<code>xmm15</code>) are also available for use in the test cases. However, only <code>xmm0-xmm7</code> are initialized with input-based values, and the remaining registers are always zero-initialized.</p> <p>Large-size vector registers (<code>ymm</code> and <code>zmm</code>) are not supported.</p>"},{"location":"devel/sandbox/","title":"Test Case Sandbox","text":"<p>This document describes the isolated environment for executing test cases, which is referred to as the sandbox. The sandbox contains the test case code and data, and the test case code is confined to access memory only within the sandbox.</p> <p>The sandbox is implemented by all modules that execute test cases, including the executor (kernel module) and all model backends (Unicorn, DynamoRIO). To ensure that the executions are consistent across all modules, the sandbox is structured in the same way in all the modules.</p> <p>This document describes the memory layout of the sandbox, the initialization of the sandbox memory, and the fault isolation mechanism.</p>"},{"location":"devel/sandbox/#memory-layout","title":"Memory Layout","text":"<p>The sandbox memory is divided into two main areas: the data sandbox and the code sandbox. Each actor in the test case has its own sub-area for its data and code, and the layout of these areas is the same for all actors.</p>"},{"location":"devel/sandbox/#data-layout","title":"Data Layout","text":"<pre><code>|----------|--------------------|\n| ACTOR 0  | MACRO STACK        | 64 B\n|          |--------------------|\n|          | UNDERFLOW PAD      | 4032 B\n|          |--------------------|\n|          | MAIN AREA          | 4096 B\n|          |--------------------|\n|          | FAULTY AREA        | 4096 B\n|          |--------------------|\n|          | GPR AREA           | 64 B\n|          |--------------------|\n|          | SIMD AREA          | 256 B\n|          |--------------------|\n|          | OVERFLOW PAD       | 3776 B\n|----------|--------------------|\n| ... (repeat for all actors in the test case)\n</code></pre> <p>The data area is divided into the following regions: * Main and Faulty Areas: These are the two regions of memory that are accessible by the test case code.   This is enforced by the test case generator, which instruments all memory accesses to ensure that they fall within these regions (see code-generation for more details).   Both areas are initialized with the input data from the RBDF.   The main area always has default permissions (RW), while the faulty area has permissions can be configured to cause a fault when accessed.   This configuration originates from the config file. * GPR and SIMD Areas: These regions store the values that will be used by the modules to initialize the general-purpose registers (GPR) and SIMD registers before executing the test case and when switching between actors.   Both areas are initialized with the input data from the RBDF. * Over- and Underflow Pads: These two zero-initialized regions surround the actors' data areas, and their purpose is to determinize the hardware traces on the executor.   Namely, they are needed for the cases when the CPU speculatively bypasses the sandboxing instrumentation inserted by the test case generator, and the bypass leads to an out-of-bounds memory access.   As the pads are zero-initialized, the bypassed memory accesses will produce deterministic results. * Macro stack: This region is used to implement complex macros (e.g., VMENTER) that need to save and restore data on the stack with a guarantee that this data won't be corrupted by the following (randomly-generated) instructions (see macros for more details.)</p>"},{"location":"devel/sandbox/#code-layout","title":"Code Layout","text":"<pre><code>|----------|--------------------|\n| ACTOR 0  | MAIN CODE AREA     | 8192 B\n|          |--------------------|\n|          | MACRO CODE AREA    | 4096 B\n|----------|--------------------|\n| ... (repeat for all actors in the test case)\n</code></pre> <p>The code area is divided into two regions: * Main Code Area: This region contains the binary of the actor's code.   The code comes from the RCDF file.   The first instruction in the code area of actor 0 is the entry point of the test case, and the last instruction of actor 0 is the exit point of the test case. * Macro Code Area: This region contains code of the expanded macros for each actor.   (see macros for more details on the macro expansion process.)</p>"},{"location":"devel/sandbox/#references","title":"References","text":"<ul> <li>Executor: rvzr/executor_km/include/sandbox_manager.h</li> <li>Unicorn backend: rvzr/sandbox.py</li> </ul>"},{"location":"devel/sandbox/#sandbox-initialization","title":"Sandbox Initialization","text":"<p>The sandbox is initialized based on the test case code (normally in RCBD format) and the input data (normally in RDBF format). The following diagram shows the mapping between the RCBF/RDBF files and the sandbox memory layout:</p> <pre><code>                                        |--------------------|\n                   zero initialized -&gt;  | MACRO STACK        |\n                                        |--------------------|\n                   zero initialized -&gt;  | UNDERFLOW PAD      |\n                                        |--------------------|\n      RDBF.data[actor_id].main_area -&gt;  | MAIN AREA          |\n                                        |--------------------|\n    RDBF.data[actor_id].faulty_area -&gt;  | FAULTY AREA        |\n                                        |--------------------|\nRDBF.data[actor_id].reg_init_region -&gt;  | GPR AREA           |\n                                        |--------------------|\nRDBF.data[actor_id].reg_init_region -&gt;  | SIMD AREA          |\n                                        |--------------------|\n                   zero initialized -&gt;  | OVERFLOW PAD       |\n                                        |--------------------|\n\n\n     RCBF.tc_section[actor_id].code -&gt;  | MAIN CODE AREA     |\n                                        |--------------------|\n     expanded macro code (executor) -&gt;  | MACRO CODE AREA    |\n</code></pre>"},{"location":"devel/sandbox/#fault-isolation","title":"Fault Isolation","text":"<p>UNDER CONSTRUCTION</p>"},{"location":"devel/tc-representation/","title":"Test Case Code Representation","text":"<p>This document describes the internal representation of test case code in Revizor.</p> <p>UNDER CONSTRUCTION</p> <p>If you are interested in this topic, please contact us by opening an issue on GitHub, and we will prioritize this document.</p>"},{"location":"tutorials/fuzzing-campaign/","title":"Tutorial: Designing a Revizor Fuzzing Campaign","text":"<p>A Revizor fuzzing experiment is determined by three components: the configuration file (YAML), command-line arguments, and optionally a template file (ASM). This tutorial outlines the systematic approach to designing a fuzzing campaign.</p>"},{"location":"tutorials/fuzzing-campaign/#1-instruction-set","title":"1. Instruction Set","text":"<p>The first consideration is determining which instruction subset to test. Testing smaller instruction subsets is generally more effective because violations are found faster and root-cause analysis is simplified. For comprehensive ISA coverage, split into multiple targeted campaigns rather than a single large campaign. Each campaign should focus on a specific subset.</p> <p>Control instruction categories using the <code>instruction_categories</code> configuration option:</p> <pre><code>instruction_categories:\n  - BASE-BINARY      # arithmetic instructions\n  - BASE-STRINGOP    # string operations\n  - BASE-LOGIC       # logical operations\n</code></pre> <p>To verify included instructions, add <code>dbg_generator</code> to the <code>logging_modes</code> configuration:</p> <pre><code>logging_modes: ['info', 'stat', 'dbg_generator']\n</code></pre> <p>More configuration options are available for more fine-grained control over the instruction set. See config.md for details.</p>"},{"location":"tutorials/fuzzing-campaign/#2-exceptions","title":"2. Exceptions","text":"<p>Decide if the campaign should cover exceptions. If so, use <code>generator_faults_allowlist</code> config option.</p> <pre><code>generator_faults_allowlist:\n  - div-by-zero              # division by zero exceptions\n</code></pre> <p>Also ensure corresponding instructions are included in the tested pool. For example, <code>div-by-zero</code> will have no effect if division instructions are not in the pool.</p> <p>If you want to test for Meltdown or Foreshadow-like vulnerabilities, you'll need to enable faults. These are controlled through separate actor-specific options, <code>data_properties</code> and <code>data_ept_properties</code> fields, which control permissions on the FAULTY area of the given actor (see Sandbox for details).</p> <pre><code>actors:\n  - main:\n      data_properties:\n        present: false     # trigger page faults\n        writable: false    # trigger write protection faults\n</code></pre> <p>More config options are available for exception handling. See config.md for details.</p>"},{"location":"tutorials/fuzzing-campaign/#3-actors-and-security-domains","title":"3. Actors and Security Domains","text":"<p>For cross-domain leakage testing, configure the <code>actors</code> field and create corresponding templates (see actors.md for details):</p> <pre><code>actors:\n  - main:\n      mode: host\n      privilege_level: kernel\n  - guest:\n      mode: guest\n      privilege_level: kernel\n      observer: true\n</code></pre> <p>Actor configurations define security domains and their interaction patterns. Use templates to specify transition sequences between actors.</p>"},{"location":"tutorials/fuzzing-campaign/#4-contract-selection","title":"4. Contract Selection","text":"<p>Contract selection is critical and depends on two primary factors: whether you're testing cross-actor leakage and whether you need to filter known leaks. Revizor contracts consist of observation and execution clauses.</p> <p>Contract Selection Decision Tree:</p> <ul> <li>For cross-actor leakage testing, use the <code>noninterference</code> contract: <pre><code>contract_observation_clause: ct\ncontract_execution_clause:\n  - noninterference\n</code></pre></li> </ul> <p>The <code>noninterference</code> contract ensures that observer actors cannot learn information about victim actors through microarchitectural channels. This is appropriate for testing isolation between security domains such as kernel/user, host/guest, or different VMs.</p> <p>Note you have to also set the <code>observer</code> flag in the actor configuration to flag the observer (i.e., attacker) actor. If not set, the <code>noninterference</code> contract will not work as expected.</p> <p>Example actor configuration for a cross-domain scenario: <pre><code>actors:\n  - main:\n      mode: host\n      privilege_level: kernel\n  - observer:\n      mode: guest\n      privilege_level: kernel\n      observer: true\n</code></pre></p> <ul> <li>For filtering known instances of leakage while detection unknown leaks, use the corresponding execution clause. E.g., to filter out Spectre V1, use the <code>cond</code> contract: <pre><code>contract_observation_clause: ct\ncontract_execution_clause:\n  - cond\n</code></pre></li> </ul> <p>The <code>cond</code> contract permits conditional branch misprediction, effectively filtering out Spectre V1 violations while detecting other speculative leaks.</p> <p>For complete list of supported execution clauses, see config.md. If the type of speculation you're interested in is not listed, you can try to write a custom speculator for Revizor. Feel free to reach out to the Revizor team for assistance on the discussion page.</p> <ul> <li>Otherwise, if you want to detect all speculative leaks without filtering, use the <code>seq</code> contract: <pre><code>contract_observation_clause: ct\ncontract_execution_clause:\n  - seq\n</code></pre></li> </ul> <p>The <code>seq</code> contract reports all detected speculative leaks, providing the most comprehensive coverage but potentially including known or acceptable leaks.</p>"},{"location":"tutorials/fuzzing-campaign/#5-noise-threshold","title":"5. Noise Threshold","text":"<p>Configure noise tolerance based on system characteristics:</p> <p>High-noise systems: <pre><code>analyser_stat_threshold: 0.5      # conservative threshold\nexecutor_sample_sizes: [50, 100, 500, 1000]\n</code></pre></p> <p>Low-noise systems: <pre><code>analyser_stat_threshold: 0.1      # sensitive threshold\nexecutor_sample_sizes: [10, 50, 100]\n</code></pre></p> <p>Higher thresholds and sample sizes reduces false positives but may miss subtle leaks and also reduce performance. Lower thresholds increase sensitivity but may cause false positives on a noisy system.</p> <p>If unsure about the noise level, start with low-noise settings and adjust if you detect non-reproducible violations.</p>"},{"location":"tutorials/fuzzing-campaign/#6-reproducibility-configuration","title":"6. Reproducibility Configuration","text":"<p>To make the fuzzing campaign reproducible, set deterministic seeds for program and data generation:</p> <pre><code>program_generator_seed: 12345     # deterministic program generation\ndata_generator_seed: 67890        # deterministic input generation\n</code></pre>"},{"location":"tutorials/fuzzing-campaign/#7-test-case-shape-configuration","title":"7. Test Case Shape Configuration","text":"<p>Control the structure of generated test cases:</p> <pre><code>program_size: 64                  # instructions per program\navg_mem_accesses: 32              # average memory accesses\nmin_bb_per_function: 1            # minimum basic blocks per function\nmax_bb_per_function: 2            # maximum basic blocks per function\nmin_successors_per_bb: 1          # minimum successors per basic block\nmax_successors_per_bb: 1          # maximum successors per basic block\n</code></pre> <p>Larger programs may find more complex interactions but require longer analysis time.</p>"},{"location":"tutorials/fuzzing-campaign/#8-template-based-fuzzing","title":"8. Template-Based Fuzzing","text":"<p>If you're interested in a very specific microarchitectural scenario, you can use templates to define fixed assembly structures with random instruction insertion. This allows you to focus on specific patterns while still introducing variability.</p> <p>Example template structure:</p> <pre><code>.section .data.main\n.function_main_0:\n    # Fixed initialization\n    mov rax, 0\n\n    # Random instruction sequence\n    .macro.random_instructions.32.0:\n\n    # Fixed measurement\n    .macro.measurement_start:\n    mov rbx, [r14]\n    .macro.measurement_end:\n\n.test_case_exit:\n</code></pre> <p>See templates.md for more details on template syntax and usage.</p>"},{"location":"tutorials/fuzzing-campaign/#9-example-configuration","title":"9. Example Configuration","text":"<p>Complete configuration for testing arithmetic instructions with exception handling:</p> <pre><code># Instruction selection\ninstruction_categories:\n  - BASE-BINARY\n\n# Exception handling\ngenerator_faults_allowlist:\n  - div-by-zero\n\n# Contract\ncontract_observation_clause: loads+stores+pc\ncontract_execution_clause:\n  - seq\n\n# Noise handling\nanalyser_stat_threshold: 0.2\nexecutor_sample_sizes: [10, 50, 100, 500]\n\n# Reproducibility\nprogram_generator_seed: 12345\ndata_generator_seed: 67890\n\n# Test case shape: 32 instructions with no branches\nprogram_size: 32\navg_mem_accesses: 16\nmin_bb_per_function: 1\nmax_bb_per_function: 1\n\n# Single actor\nactors:\n  - main:\n      mode: host\n      privilege_level: kernel\n      data_properties:  # no page faults\n        present: true\n        writable: true\n\n# Debugging\nlogging_modes: ['info', 'stat', 'dbg_generator']\n</code></pre>"},{"location":"tutorials/fuzzing-campaign/#10-launch-command","title":"10. Launch Command","text":"<p>Execute the fuzzing campaign:</p> <pre><code>rvzr fuzz -s base.json -c config.yaml -n 100000 -i 100 -w ./violations --timeout 3600\n</code></pre> <p>Parameters:</p> <ul> <li><code>-s</code>: ISA specification file</li> <li><code>-c</code>: Configuration file</li> <li><code>-n</code>: Number of test cases</li> <li><code>-i</code>: Inputs per test case</li> <li><code>-w</code>: Working directory for violations</li> <li><code>--timeout</code>: Time limit in seconds</li> </ul>"},{"location":"tutorials/fuzzing-campaign/#key-principles","title":"Key Principles","text":"<ol> <li>Start focused: Test instruction subsets rather than entire ISA</li> <li>Incremental complexity: Begin with simple scenarios, add complexity gradually</li> <li>Noise-aware configuration: Adjust thresholds based on system characteristics</li> <li>Systematic coverage: Use multiple targeted campaigns rather than single broad campaign</li> <li>Reproducible setup: Use deterministic seeds for consistent results</li> </ol> <p>For additional configuration options, consult config.md. For multi-actor scenarios, see actors.md. For template syntax, refer to templates.md.</p>"},{"location":"tutorials/root-causing/","title":"Tutorial: Root-Causing a Violation Detected by Revizor","text":"<p>This tutorial walks you through analysis of a contract violation detected by Revizor. The goal is to simplify the violation artifacts (program and inputs) and identify the root cause of the violation. The tutorial includes practical examples, explanations of commands, and interpretation of outputs.</p> <p>The examples below will show the process of root-causing a violation of the CT-SEQ contract on an x86-64 CPU. The same general procedure can be applied to other contracts and architectures.</p>"},{"location":"tutorials/root-causing/#prerequisites","title":"Prerequisites","text":"<ol> <li>Revizor Installed: Ensure Revizor is installed and functional.</li> <li>Detected Violation: Revizor has already surfaced a violation and stored it in a <code>violation-&lt;timestamp&gt;</code> directory.</li> <li>Configuration Files: You have access to the configuration file (<code>config.yaml</code>) used in the fuzzing campaign.</li> </ol>"},{"location":"tutorials/root-causing/#step-1-locate-the-violation-files","title":"Step 1: Locate the Violation Files","text":"<p>When Revizor detects a violation, it creates a directory (<code>violation-&lt;timestamp&gt;</code>) containing: - <code>program.asm</code>: The test case program that caused the violation. - <code>input_*.bin</code>: A sequence of inputs that triggered the violation. - <code>report.txt</code>: Additional details about the violation, including hardware and contract traces. - <code>org-config.yaml</code>: The original configuration file used in the fuzzing campaign. - <code>reproduce.yaml</code>: A configuration file for reproducing the violation. - <code>minimize.yaml</code>: A configuration file for minimizing the test case.</p>"},{"location":"tutorials/root-causing/#step-2-reproduce-the-violation","title":"Step 2: Reproduce the Violation","text":"<p>To confirm the violation and analyze its context, reproduce it using the following command:</p> <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t ./violation-&lt;timestamp&gt;/program.asm -i ./violation-&lt;timestamp&gt;/input_*.bin\n</code></pre> <p>If the violation is reproducible, Revizor will print \"Violation detected\" in the terminal output. The distribution of hardware traces in the reproduced violation should be roughly similar to the original violation. If the traces are significantly different, this might be a sign of a bug or a misconfiguration in the fuzzer.</p> <p>Note: The cases of non-reproducible violations are expected to be rare, no more than one or two per machine/week of fuzzing. If your fuzzing campaign produces more, consider adjusting the configuration file to increase noise tolerance (see the Configuration File Documentation).</p>"},{"location":"tutorials/root-causing/#step-2a-analyze-reproduction-output","title":"Step 2a: Analyze Reproduction Output","text":"<p>The output of the reproduction command provides valuable insights into the violation. Here is an example output:</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 14907365725669422044 (hash)\nHardware traces:\n  Input group 1: [1, 21]\n  Input group 2: [11]\n  ^.^....^.....^.................^...^............^............... [500    | 10    ]\n  ^.^....^.....^................^^...^............^............... [0      | 490   ]\n\n================================ Statistics ===================================\nTest Cases: 1\nInputs per test case: 30.0\nViolations: 1\nEffectiveness:\n  Total Cls: 30.0\n  Effective Cls: 30.0\nDiscarded Test Cases:\n  Speculation Filter: 0\n  Observation Filter: 0\n  Fast Path: 0\n  Max Nesting Check: 0\n  Tainting Check: 0\n  Early Priming Check: 0\n  Large Sample Check: 0\n  Priming Check: 0\n\nDuration: 8.2\nFinished at 12:00:05\n</code></pre>"},{"location":"tutorials/root-causing/#insights-from-the-output","title":"Insights from the Output","text":"<ul> <li>Violation detected: Indicates that the violation was successfully reproduced.</li> <li>Contract Trace: The value (<code>14907365725669422044</code>) summarizes the contract trace for the inputs that triggered the violation. This value is a hash so it does not provide direct information about the contract trace, but it should match the value from the original violation. If you would like to see the complete contract trace, enable <code>dbg_dump_ctraces</code> in the configuration file.</li> <li>Hardware Traces: The text under the <code>Hardware traces</code> section summarizes the hardware traces that constitute the violation.</li> <li>The text starting with <code>Input group</code> tells us that the violation was triggered by inputs #1, #11, and #21. The inputs #1 and #21 produced the same (or very similar) hardware traces, while input #11 produced a different set of traces - hence they are put into two different groups.</li> <li>The line with <code>^</code> and <code>.</code> characters represents the observed cache changes. Each character encodes the state of the corresponding L1D cache line after the test case has been executed with the given input. Character <code>^</code> indicates that the cache line was accessed (e.g., evicted if P+P mode is used), while <code>.</code> indicates that the cache line was not accessed. The cache sets are numbered left-to-right, starting from zero (TIP: set <code>color: true</code> in config file to improve readability). So, in the above example, the first hardware trace shows the accessed cache sets were 0, 2, 7, 13, 31, 35, and 49: <pre><code>      Set 2 accessed\n      |         Set 13 accessed\n      |          |                    Set 35 accessed\n      |          |                     |\n    ^.^....^.....^.................^...^............^...............\n    |      |                       |                |\n    |      |                       |                Set 49 accessed\n    |      |                       Set 31 accessed\n    |      Set 7 accessed\n    Set 0 accessed\n</code></pre></li> <li>The numbers at the end of the line (<code>[500    | 10    ]</code>) are the numbers of occurrences of the given hardware trace in the sample. Recall that the executor collects each hardware trace multiple times to deal with non-determinism and to filter noise (see <code>executor_sample_sizes</code> configuration option). The first number is the number of occurrences of the trace in the first input group (i.e., inputs #1 and #21), and the second number is the number of occurrences in the second input group (input #11). So, we can tell that the first input group always produced the same hardware trace, while the second input group mainly produced the second hardware trace, but there were a few (10) occurrences of the first trace as well.</li> <li>Statistics: The statistics section can be largely ignored when root-causing the violation. Is it only useful for fine-tuning the fuzzing campaign.</li> </ul>"},{"location":"tutorials/root-causing/#step-3-minimize-the-program","title":"Step 3: Minimize the Program","text":"<p>The violation program (<code>program.asm</code>) is a large, randomly generated sequence of instructions and it often contains many unnecessary instructions.</p> <p>TIP: If the violation is stable and reproducible, you can try to reduce the sample size to speed up the minimization process. To do so, modify the <code>executor_sample_sizes</code> parameter in the configuration file.</p> <p>Use minimization passes to simplify the program while preserving the violation:</p> <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t ./violation-&lt;timestamp&gt;/program.asm -o minimized.asm -i &lt;num_inputs&gt; \\\n    --num-attempts 10 \\\n    --enable-instruction-pass 1 \\\n    --enable-simplification-pass 1 \\\n    --enable-label-pass 1\n</code></pre>"},{"location":"tutorials/root-causing/#explanation-of-passes","title":"Explanation of Passes","text":"<ul> <li>The default pass (no flag required) removes unnecessary instructions.</li> <li><code>--enable-simplification-pass</code> replaces complex instructions with simpler ones.</li> <li><code>--enable-label-pass</code> cleans up unused labels.</li> <li>The sequence of three passes is executed 10 time (<code>--num-attempts 10</code>) to ensure the best possible simplification.</li> </ul> <p>This example is the simplest form of minimization. For more advanced minimization options, consider adding the flags described in the Minimization Passes Documentation.</p>"},{"location":"tutorials/root-causing/#verify-minimization","title":"Verify Minimization","text":"<p>The <code>minimized.asm</code> file contains a reduced version of the original program that still reproduces the violation. Run the <code>reproduce</code> command to ensure the minimizer did not introduce non-determinism. <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t minimized.asm -i &lt;num_inputs&gt;\n</code></pre></p> <p>If the violation is not reproducible, try re-running the minimizer without some some of the passes or decrease the number of attempts.</p>"},{"location":"tutorials/root-causing/#step-4-minimize-inputs","title":"Step 4: Minimize Inputs","text":"<p>A test case input is the data used to initialize memory and register before executing the test case program. Hence, if we minimize the inputs that trigger the violation, we can isolate the exact conditions causing the violation and the data that leaks.</p> <p>Run the following command to minimize the inputs: <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t minimized.asm -o commented.asm -i &lt;num_inputs&gt; \\\n    --input-outdir ./inputs \\\n    --enable-input-diff-pass 1 \\\n    --enable-comment-pass 1\n</code></pre></p> <p>Result: - <code>./inputs/min_input_*.bin</code>: Minimized input sequence that still trigger the violation. - A printed summary of Leaked bytes in the terminal output. Be sure to record these for further analysis.</p>"},{"location":"tutorials/root-causing/#insights-from-the-summary","title":"Insights from the Summary","text":"<p>Below is an example of the printed summary from the differential input minimizer: <pre><code>[PASS 2] Differential Input Minimizer\n  &gt; Minimizing the difference between inputs 1 and 11\n\nAddress    +0x0     +0x40    +0x80    +0xc0    +0x100   +0x140   +0x180   +0x1c0\n0x00000000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000200 ........ =....... ........ ........ ........ ........ ........ ........\n0x00000400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00002000 .....^..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2028']\n</code></pre></p> <p>The minimizer goes through the pair of inputs that trigger the violation - inputs #1 and #11 in this case - and tries to minimize the differences between them: * If both inputs already have identical values at a given address, the minimizer prints <code>=</code> for that address. In this example, this is the case for address <code>0x240</code>. * Next, the pass attempts to zero out one byte at a time in both inputs. If the violation persists, then the minimizer prints <code>.</code> for that address. In this example, most of the addresses are zeroed out. * Next, the pass attempts to copy one byte from input #1 into the same address in input #11. If the violation persists, then the minimizer prints <code>+</code> for that address. This example does not have such cases. * If both attempts fail, the pass restores the original values at the given address, prints <code>^</code>, and moves to the next address. In this example, the minimizer restored the original value at address <code>0x2028</code>.</p> <p>The interpretation of these results is case-specific, but generally, the values with <code>+</code> or <code>=</code> are those that create conditions for leakage, and the values with <code>^</code> are the addresses whose value leaks.</p> <p>In this example, the minimizer found that this test case leaks one byte at address <code>0x2028</code> (used to initialize RDI). The minimizer also found that the address <code>0x240</code> must contain specific non-zero values that must be the same in both inputs. This address in the input is used to initialize the corresponding offset in the sandbox of actor 0. See Sandbox Memory Layout for more details about register and memory initialization.</p> <p>TIP 1: The <code>--enable-comment-pass 1</code> flag adds comments to the minimized input files, which can help you understand which instructions used which addresses.</p> <p>TIP 2: Ideally, the minimizer should be able to reduce the leakage to a single byte. If more then a couple bytes leak, it typically indicates that the violation is non-deterministic, and it might be a good idea to re-run the program minimizer or to change the configuration to increase the number of attempts/increase the noise threshold. If no bytes leak, this is a certain sign that something went wrong; re-run the minimizer.</p>"},{"location":"tutorials/root-causing/#verify-minimization_1","title":"Verify Minimization","text":"<p>Run the minimized program with the reduced inputs to ensure the violation is still reproducible: <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t commented.asm -i ./inputs/min_input*.bin\n</code></pre></p>"},{"location":"tutorials/root-causing/#step-5-insert-speculation-fences","title":"Step 5: Insert Speculation Fences","text":"<p>To isolate speculative behavior, add fences: <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t commented.asm -o fenced.asm -i &lt;num_inputs&gt; \\\n    --enable-fence-pass 1\n</code></pre></p> <p>This pass with attempt to insert an <code>LFENCE</code> after every instruction in the program and check if the violation still occurs.</p> <p>In the resulting file (<code>fenced.asm</code>) the region without fences is the one that causes the violation. The remaining instructions are just setting up the data for the violation, and are likely irrelevant.</p> <p>TIP: If an <code>LFENCE</code> is inserted after every instruction in the test case and the violation still occurs, this is most likely due to a bug in the model or the executor. If you are using a custom model, consider checking the model for correctness. If you haven't made changes to the Revizor source code, please, open an issue in the bug tracker.</p>"},{"location":"tutorials/root-causing/#step-6-map-hardware-traces-to-minimized-program-and-data","title":"Step 6: Map Hardware Traces to Minimized Program and Data","text":"<p>When both program and its inputs are minimized, you should be able to identify which instructions caused the cache accesses in the hardware traces and which data was leaked.</p> <p>When we run the <code>reproduce</code> command with the minimized program and inputs, we will see the following hardware traces:</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 2362171776002334258 (hash)\nHardware traces:\n  Input group 1: [1]\n  Input group 2: [11]\n  ^...............................................^............... [420    | 0     ]\n  ^............................................................... [80     | 0     ]\n  ^..............^................................................ [0      | 500   ]\n</code></pre> <p>TIP: If in your case the input IDs have changed after minimization, you can either exclude some of the inputs from the arguments of the <code>reproduce</code> command, or re-run the minimizer with fewer passes.</p> <p>We see that the hardware traces have been significantly simplified compared to the original violation, and now there are at most two accessed cache sets in each trace: 0 and 48 for input #1, and 0 and 15 for input #11. This is a good sign: the minimization was successful.</p> <p>We can also tell that the only difference between the two traces is the accessed cache set 48 vs 15 . This is the cache set that is causing the violation, and we should be aiming to find the instruction that does the access.</p> <p>To do so, let's look at the contents of the <code>commented.asm</code> file. This file contains the minimized program with comments that show which memory addresses or cache lines are accessed by each instruction.</p> <pre><code>; ... skipped header ...\n1.  and rax, 0b1111111111111 # instrumentation\n2.  lfence\n3.  mov edx, dword ptr [r14 + rax]\n4.  # mem access: [1] 0x0 cl 0:0 | [11] 0x0 cl 0:0\n5.  or cx, 0b1000 # instrumentation\n6.  and cl, 0b11111000 # instrumentation\n7.  and dx, 0b11 #\n8.  and rsi, 0b1111111111111 #\n9.  add cl, 39 #\n10. mov rbx, 0b1111111111111 #\n11. bt si, dx\n12. jbe .bb_0.1\n13. jmp .exit_0\n14. .bb_0.1:\n15. mov ecx, edi\n16. and rcx, 0b1111111111000 # instrumentation\n17. mov byte ptr [r14 + rcx], 88\n; ... skipped footer ...\n</code></pre> <p>TIP: You can find the same information in a different format if you enable <code>dbg_violation</code> in the configuration file and run the <code>reproduce</code> command.</p> <p>This program contains only two memory accesses, at lines 3 and 17.</p> <p>The annotation at line 4 tells us that the <code>mov</code> instruction accesses memory offset <code>0x0</code> when executed with input 1 (<code>[1]</code>) and the same cache set when executed with input 11 (<code>[11]</code>). The notation <code>0:0</code> stands for cache set <code>0</code> and cache line offset <code>0</code>.</p> <p>This information lets us map this instruction to the first access in the hardware trace:</p> <pre><code>    ^...............................................^...............\n    |\n  This eviction maps to `mov edx, dword ptr [r14 + rax]` at line 3\n</code></pre> <p>The second memory access (line 17) does not have an annotation, which implies that the contract model has not executed this instruction with the inputs provided. It does not, however, mean that the CPU has not executed this instruction, as there is a chance that this instruction was executed speculatively. This is a typical scenario in violations detected by Revizor.</p> <p>If we look at the instructions prior to the memory access, we can see <code>jbe</code> instruction at line 12, which is a conditional jump - a common source of speculation, namely branch prediction. This type of speculation is not permitted by the target contract (CT-SEQ), so it could cause a violation. From this, we can make a hypothesis that the memory access at line 17 is speculative and is the one causing the second cache access:</p> <pre><code> Inputs [1]:\n              Hypothesis: This eviction maps to `mov` at line 17\n                                                  |\n  ^...............................................^...............\n\n Inputs [11]:\n  ^..............^................................................\n                 |\n           Hypothesis: This eviction maps to `mov` at line 17\n</code></pre> <p>To check if our hypothesis is correct, let's cross-reference this information with the leaked bytes from the differential input minimizer:</p> <pre><code>; .. skip zero bytes\n0x00002000 .....^..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2028']\n</code></pre> <p>This summary tells us that <code>rdi</code> has a differing value between inputs #1 and 11. At the same time, the first time <code>rdi</code> is used in the program is at line 15, where it is moved to <code>rcx</code>, and then later used as a part of the address in the memory access at line 17. This would make the speculative memory access at line 17 access different addresses with the two inputs, and would explain the difference between the hardware traces.</p> <p>At this point, the hypothesis is more-or-less confirmed, and we can declare that the root cause of the leak was the misprediction of the <code>jbe</code> branch at line 12, which caused the speculative execution of the memory access at line 17, and which in turn leaked the value of <code>rdi</code>.</p> <p>If we want to further increase our confidence, we can manually inspect the contents of the inputs at the address <code>0x2028</code> to see if the values correspond to the cache set ID that we observe in the hardware traces. This can be done by running the <code>hexdump</code> command on the input files:</p> <pre><code>$ hexdump -C ./inputs/min_input_0001.bin | grep 2020\n00002020  00 00 00 00 00 00 00 00  1e 1c 4a 00 1e 1c 4a 00  |..........J...J.|\n$ hexdump -C ./inputs/min_input_0011.bin | grep 2020\n00002020  00 00 00 00 00 00 00 00  c8 13 58 00 c8 13 58 00  |..........X...X.|\n</code></pre> <p>The values are <code>0x4a1c1e004a1c1e</code> for input #1 and <code>0x5813c8005813c8</code> for input #11. These are masked with <code>0b1111111111000</code> by <code>and</code> at line 16 and become <code>7192</code> and <code>5064</code> respectively. If we translate these values to cache set IDs (<code>id = (addr % 0x1000) // 64</code>), we get <code>48</code> and <code>15</code>. These values match the cache set IDs that we observed in the hardware traces, which confirms our hypothesis.</p> <p>If we want even more confidence, we can manually modify the input files (e.g, with <code>hexedit</code> tool) to see if the hardware traces change when we modify the value of <code>rdi</code> in the input files.</p>"},{"location":"tutorials/root-causing/#step-7-modify-the-program","title":"Step 7: Modify the Program","text":"<p>In many cases, the minimization process will not provide a clear result as in the example above and you will not be able to make a specific hypothesis about the root cause of the violation. In such cases, you can try to modify the program in various ways to see if the violation still occurs. There are no strict rules on which modifications to make and you will have to rely on your intuition and knowledge of the target microarchitecture, but here are some general guidelines:</p> <ol> <li>Simplify Instructions: Start by trying to manually replace instructions in <code>minimized.asm</code> with simpler ones. For example, replace complex instructions with memory operands with simple loads or stores.</li> <li>Increase/Decrease Aliasing: Try to change the addresses of memory accesses to match (or not match if they already do) the addresses of other instruction. Such aliasing often triggers speculation (e.g., in Speculative Store Bypass or MDS attacks).</li> <li>Add/Remove Dependent Instructions: If you have a hypothesis about which instruction triggers speculation, try adding or removing data-dependent instructions before it. This will change the size of the speculative window and might change hardware traces, which will give you more insight into the violation.</li> <li>Change Memory Permissions: If the violation is related to memory accesses, try changing the permissions of the memory regions that are accessed by the program. For example, if the memory is read-only, try changing it to read-write. If the violation disappears, it might indicate that the violation is related to the permission checks in the CPU.</li> <li>Change Instruction Operands: Try changing operands to add or remove data dependencies between instructions. For example, if you have a sequence of two moves <code>mov rax, [rax]; mov rbx, [rax]</code>, try changing the second move to <code>mov rbx, [rbx]</code> to see if the violation still occurs if there are no data dependencies between the instructions.</li> </ol> <p>After each modification, run the <code>reproduce</code> command to see if the violation still occurs:</p> <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t modified.asm -i ./inputs/min_input*.bin\n</code></pre> <p>NOTE: If you find any other strategies that work well, please consider sharing them by opening a pull request to this documentation. We would love to hear about your experiences and learn from them.</p>"},{"location":"tutorials/root-causing/#additional-resources","title":"Additional Resources","text":"<ul> <li>Command Line Interface</li> <li>Minimization Passes</li> <li>Configuration File Documentation</li> <li>Sandbox Memory Layout</li> </ul>"},{"location":"tutorials/tsa-sq/","title":"Tutorial: Detecting TSA-SQ with Revizor","text":"<p>This tutorial demonstrates how we used Revizor to detect TSA-SQ (Transient Scheduler Attack - Store Queue), a microarchitectural vulnerability discovered in AMD Zen4 processors. We'll walk through the design rationale behind the fuzzing campaign configuration and template, explaining how each component contributes to successful vulnerability detection.</p> <p>You can reproduce this campaign using the provided configuration and template files, which are available in the Revizor repository under <code>demo/tsa-sq/</code>.</p>"},{"location":"tutorials/tsa-sq/#prerequisites","title":"Prerequisites","text":"<p>To follow this tutorial, you should have:</p> <ul> <li>Non-virtualized access to an AMD Zen4 processor for testing</li> <li>A working installation of Revizor. See quickstart guide for setup instructions.</li> <li>Basic understanding of Revizor's fuzzing framework, in particular the concepts of model-based relational testing, actors, templates, macros.</li> <li>Familiarity with microarchitectural vulnerabilities and side-channel attacks</li> </ul>"},{"location":"tutorials/tsa-sq/#background-understanding-tsa-sq","title":"Background: Understanding TSA-SQ","text":"<p>Before diving into the Revizor configuration, let's briefly understand what TSA-SQ is. According to the AMD security bulletin, TSA-SQ exploits timing variations in the CPU's store queue during \"false completion\" events. When a load instruction matches the address of an older store whose data isn't yet available, it may complete falsely using stale data from a previous store that occupied the same store queue entry. This creates timing differences that an attacker can observe to infer information about previous stores, even from different privilege levels.</p> <p>The key insight is that an unprivileged user process can potentially observe timing variations that depend on data from kernel stores, creating a kernel-to-user information leak channel.</p>"},{"location":"tutorials/tsa-sq/#design-rationale","title":"Design Rationale","text":"<p>When this campaign was designed, we were not yet aware of the TSA-SQ vulnerability (in fact, the vulnerability was discovered as result of this campaign). Therefore, the campaign design is not specifically tailored to detect TSA-SQ, but rather to stress-test the general isolation between kernel and user modes in a way that could reveal microarchitectural vulnerabilities.</p>"},{"location":"tutorials/tsa-sq/#threat-model-and-actor-configuration","title":"Threat Model and Actor Configuration","text":"<p>Our fuzzing campaign targets a common and high-impact threat model: a malicious user process attempting to extract sensitive data from the kernel. This scenario is particularly relevant for privilege escalation attacks where an attacker seeks to leak kernel secrets.</p> <p>The actor section of <code>config.yaml</code> reflects this threat model:</p> <pre><code>actors:\n  - main:\n    - mode: \"host\"\n    - privilege_level: \"kernel\"\n    ...\n  - user:\n    - observer: true\n    - mode: \"host\"\n    - privilege_level: \"user\"\n</code></pre> <p>The <code>main</code> actor represents the victim kernel, while the <code>user</code> actor represents the attacker. The <code>observer: true</code> flag designates the user actor as the attacker attempting to extract information. This configuration, in combination with the noninterference contract, tells Revizor that any information leakage from <code>main</code> to <code>user</code> should be flagged as a violation.</p>"},{"location":"tutorials/tsa-sq/#template-design-simulating-attack-patterns","title":"Template Design: Simulating Attack Patterns","text":"<p>The template structure follows the typical flow of a microarchitectural side-channel attack, specifically implementing a Flush+Reload pattern across privilege transitions.</p> <p></p> <p>Let's examine each phase:</p> <p>Phase 1: Setup and Flush (function_main_0 and function_user_0)</p> <p>The first stage represent the attacker preparing the microarchitectural state for measurements. The first action in the template is in the <code>function_user_0</code>, where the <code>user</code> actor initializes the microarchitectural state by flushing the cache lines that will be used for measurements. This is done using the <code>measurement_start</code> macro, which is translated into a Flush stage of Flush+Reload attack. Revizor does this translation automatically based on the <code>executor_mode: F+R</code> setting in the configuration file.</p> <p>Note that the template does not actually start from the <code>function_user_0</code> actor function. Instead, it starts with the <code>function_main_0</code>, which is a function belonging to the <code>main</code> actor. This is because Revizor requires that the entry point to the test case must be within the <code>main</code> actor's code.</p> <p>Phase 2: Secret Injection (function_main_1)</p> <p>After the initial setup, the attacker transitions to the victim and let's it do some computations on the victim's secret data. The victim actor execute a sequence of random instructions in the <code>function_main_1</code> macro, which simulates the kernel performing operations on sensitive data. Here, \"random instructions\" means a sequence of instructions that is randomly generated in each fuzzing round (i.e., each generated test case will have a different sequence of instructions in <code>function_main_1</code>).</p> <p>This randomness is crucial because it allows us to test a wide range of ways how secret data can impact microarchitectural state, without knowing a priori what specific instruction sequences might trigger a leak. This was one of the key factors that allowed us to discover TSA vulnerabilities without knowing about them beforehand.</p> <p>Phase 3: Secret Extraction (function_user_1)</p> <p>Back in user mode, we first clear the architectural state to eliminate any architectural information flow between actors. This is necessary to prevent any architectural information flows between the actors, which could otherwise lead to false positives in the analysis because Revizor is unable to distinguish between architectural and microarchitectural information flows (to be precise, Revizor would be able to distinguish them with a more subtle contract, but re-initializing the registers is a simpler solution).</p> <pre><code>xor rax, rax  # noremove\nmov rax, qword ptr [r14 + 0x2000] # noremove\nmov rbx, qword ptr [r14 + 0x2008] # noremove\n# ... more register initialization\n</code></pre> <p>After that, the attacker execute another sequence of random instructions, which simulates the user process attempting to access the sensitive data that was just processed by the kernel. Note that this sequence may include an attempt to access kernel memory from the user mode (see the <code>user-to-kernel-access</code> fault allowlist in the configuration). As we found out post-factum, this is not strictly necessary for TSA-SQ, but it helps to create complex microarchitectural conditions that can trigger the leak.</p> <p>Depending on whether random instruction sequence triggers the fault, the user actor will either switch to the kernel mode explicitly (using the <code>switch_u2k.main.user_1</code> macro) or the CPU will transfer control to the fault handler (<code>fault_handler</code> macro in the <code>function_main_2</code>). In this experiment, we were not particularly interested in fault handling, so both paths lead to the same point in the template.</p> <p>Phase 4: State Measurement (function_user_2)</p> <p>Finally, the \"Reload\" stage in <code>function_user_2</code> measures which cache lines were accessed by the random code in the previous stage. If the accessed cache lines were somehow influenced by the kernel's secret data, this will lead to a discrepancy in the \"Reload\" measurements, leading to diverging hardware traces for different inputs, and ultimately to Revizor detecting a violation.</p>"},{"location":"tutorials/tsa-sq/#configuration-overview","title":"Configuration Overview","text":"<p>Beyond the actor configuration, <code>config.yaml</code> contains several other important settings that guide the fuzzing campaign, as described next:</p> <ul> <li>Contract: The contract configuration specifies what information leakage we consider acceptable</li> </ul> <pre><code>contract_observation_clause: ct\ncontract_execution_clause:\n  - noninterference\n</code></pre> <p>The <code>noninterference</code> execution clause implements the security property that observer actors cannot learn information about non-observer actors through microarchitectural channels. Combined with the <code>ct</code> (constant-time) observation clause, this allows the observer to see memory access patterns and control flow but prohibits leakage of raw data values.</p> <ul> <li>Exceptions: The configuration includes <code>user-to-kernel-access</code> in the fault allowlist, which enables testing for Meltdown-type vulnerabilities. This was part of our original experimental design when we didn't yet know about TSA's existence. Revizor's program generator will randomly select memory accesses in the user actor and modify them to target kernel memory, triggering page faults.</li> </ul> <p>Interestingly, this exception-based approach helped discover TSA-SQ because the false completion events in the store queue can lead to timing differences in subsequent instructions, and the faults provide a constant-time reference point for the timing differences to get transformed into persistent cache state. Namely, when a variable-latency instruction is executed concurrently with a faulting instruction, it creates a race condition, where the cache impact of the variable-latency instruction can be influenced by whether the faulting instruction completes before or after it.</p> <p>Note the fault configuration quirk: we enable <code>user-to-kernel-access</code> globally but block it specifically for the main actor using <code>fault_blocklist</code>. This is the only way to enable a fault for a specific actor, because Revizor does not allow faults to be allow-listed for a specific actor.</p> <ul> <li>Statistical Analysis: The statistical analysis parameters balance sensitivity with noise tolerance:</li> </ul> <pre><code>analyser_stat_threshold: 0.05\nexecutor_sample_sizes: [15, 40, 160, 320]\n</code></pre> <p>The low threshold of 0.05 makes the analysis sensitive to subtle timing differences, while the adaptive sample sizes allow Revizor to start with quick tests and increase precision when potential violations are detected.</p> <ul> <li>Instruction Set: The instruction set is defined as <code>x86-64</code> because we are targeting AMD CPUs, and the instruction categories include all base instructions, which allows for a wide range of microarchitectural interactions in the randomly generated code. Ideally, we would include even more categories, such as SIMD extensions and other advanced instructions, but Revizor does not yet support them (coming up soon, though!).</li> </ul>"},{"location":"tutorials/tsa-sq/#running-the-campaign","title":"Running the Campaign","text":"<p>With the configuration and template in place, we can run the detection campaign using Revizor's <code>tfuzz</code> command. This command generates test cases based on the provided template and configuration, executes them, and analyzes the results for violations.</p> <pre><code>./revizor.py tfuzz -s base.json --save-violations t -w ./results/ \\\n    -c config.yaml -t template.asm -n 100000 -i 25\n</code></pre> <p>This runs 100,000 test cases with 25 inputs each. The <code>--save-violations</code> flag preserves any detected violations for later analysis. When TSA-SQ is present, you'll eventually see output similar to:</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 14140085380608124960 (hash)\nHardware traces:\n  Input group 1: [11]\n  Input group 2: [36]\n  ^^^.........^.................................^^................ [287    | 36    ]\n  ^^^.........^.................................^................. [31     | 284   ]\n</code></pre> <p>The different hardware trace patterns for inputs 11 and 36, despite having the same contract trace hash, indicate that the CPU is leaking information not predicted by the noninterference contract.</p> <p>On our machine, the campaign typically takes about 5 hours to detect a leak, but your mileage may vary depending on the CPU model and due to the inherent randomness of the process.</p>"},{"location":"tutorials/tsa-sq/#verifying-genuine-violations","title":"Verifying Genuine Violations","text":"<p>To confirm that a detected violation is genuine, reproduce it using:</p> <pre><code>./revizor.py reproduce -s base.json -c ./results/violation-*/reproduce.yaml \\\n    -t ./results/violation-*/program.asm -i ./results/violation-*/input_*.bin\n</code></pre> <p>A genuine violation will reproduce consistently across multiple runs with the same statistical pattern, confirming that the timing differences represent a real microarchitectural information leak.</p> <p>The next step is to do root-cause analysis of the violation, which is beyond the scope of this tutorial. See Root-Causing a Violation Detected by Revizor for details on this process.</p>"},{"location":"user/actors/","title":"Actors","text":"<p>Actors in Revizor are a concept that allows to test for information leaks across different security domains, such as leakage from OS kernel to user space, or from one virtual machine to another. They represent distinct execution contexts with specific isolation properties, enabling the detection of microarchitectural vulnerabilities across these boundaries.</p> <p>Despite the relative complexity of their usage, actors have proven to be the most powerful feature of Revizor, as they allowed us to discover a number of critical vulnerabilities in real-world CPUs, most notably the Transient Scheduler Attacks (TSA) in AMD CPUs. This concept also allows to test mitigations against such high-profile vulnerabilities like Meltdown, Foreshadow, and MDS.</p>"},{"location":"user/actors/#what-is-an-actor","title":"What is an Actor?","text":"<p>An actor is an abstraction that encompasses:</p> <ul> <li>Code region: A part of the test case program that is associated with a specific execution context</li> <li>Data region: Private data memory with configurable permissions and properties</li> <li>Execution context: CPU mode (host/guest), privilege level (kernel/user), and system configuration</li> </ul> <p>In other words, a test case can be split into multiple isolated sections with associated data and CPU configurations, and each such section is called an actor.</p> <p>Every test case in Revizor always contains one actor by default, called <code>main</code>, which is executed in the host kernel mode and contains the entry and exit points of the test case. Any additional actors are optional, and can be reached only through special macros that handle transitions between different execution contexts.</p>"},{"location":"user/actors/#actor-configuration","title":"Actor Configuration","text":"<p>Actors are defined in the configuration file under the <code>actors</code> section:</p> <pre><code>actors:\n  - main:                      # Default main actor\n    - mode: \"host\"              # Always host for main;\n                                # changing to \"guest\" will produce an error\n    - privilege_level: \"kernel\" # Always kernel for main;\n                                # changing to \"user\" will produce an error\n\n  - user:                      # Example user-mode actor\n    - mode: \"host\"\n    - privilege_level: \"user\"\n    - data_properties:        # Custom page table properties of the faulty page\n      - writable: false       # Faulty page of the user actor is read-only\n</code></pre> <p>Available properties for each actor include:</p> <ul> <li><code>mode</code>: Virtualization mode of the actor<ul> <li><code>host</code>: Normal, non-virtualized execution</li> <li><code>guest</code>: Runs in a virtual machine (each guest actor is another VM)</li> </ul> </li> <li><code>privilege_level</code>: CPL of the actor<ul> <li><code>kernel</code>: Ring 0 execution (CPL=0)</li> <li><code>user</code>: Ring 3 execution (CPL=3)</li> </ul> </li> <li><code>data_properties</code>: A list of properties that define the permissions and attributes of the actor's faulty data area (see sandbox for an explanation of the faulty area).<ul> <li><code>present</code>: Page present bit (true for present, false for not present)</li> <li><code>writable</code>: Page writable bit (true for writable, false for read-only)</li> <li><code>user</code>: User/Supervisor bit (true for user-accessible, false for supervisor-only)</li> <li><code>accessed</code>: A-bit value of the page table entry (true if 1, false if 0)</li> <li><code>dirty</code>: D-bit value of the page table entry (true if 1, false if 0)</li> <li><code>reserved_bit</code>: Reserved bit (true if 1, false if 0)</li> <li><code>executable</code>: Execute bit (true if executable, false if not)</li> <li><code>randomized</code>: If true, the properties are randomized per test case execution (use <code>false</code> for deterministic testing)</li> </ul> </li> <li><code>data_ept_properties</code>: A list of properties that define the Extended Page Table (EPT) attributes for guest actors. The list of properties is similar to <code>data_properties</code>, but applies to the EPT entries instead of the page table entries.</li> <li><code>observer</code>: A boolean flag indicating whether the actor is an observer. Used to determine the threat model when testing Non-Interference contracts.<ul> <li><code>true</code>: Actor is an attacker that can observe data leaks</li> <li><code>false</code>: Actor is a victim or neutral party that does not observe leaks</li> </ul> </li> </ul>"},{"location":"user/actors/#actor-templates","title":"Actor Templates","text":"<p>Multi-actor execution is supported only in the template-based mode, where actors are defined in the test case template. Each actor can have its own code and data sections, and transitions between actors are handled by macros.</p> <p>For example, a template with two actors (kernel and user) might look like this:</p> <pre><code>.intel_syntax noprefix\n\n# ---------------- Main (Kernel) Actor ---------\n.section .data.main\n.function_main_0:\n    # Set up user transition\n    .macro.set_k2u_target.user.function_user_0:\n    .macro.set_u2k_target.main.function_main_1:\n\n    # Generate random kernel code\n    .macro.random_instructions.32.0:\n\n    # Transition to user mode\n    .macro.switch_k2u.user.0:\n\n.function_main_1:\n    .macro.landing_u2k.main_1:\n    # Back in kernel, clean up and exit\n    nop\n\n.test_case_exit:\n\n# ---------------- User Actor -----------------\n.section .data.user\n.function_user_0:\n    .macro.landing_k2u.user_0:\n\n    # Start measurement in user mode\n    .macro.measurement_start:\n\n    # Generate random user code\n    .macro.random_instructions.16.1:\n\n    # End measurement\n    .macro.measurement_end:\n\n    # Return to kernel\n    .macro.switch_u2k.main.0:\n</code></pre>"},{"location":"user/actors/#transition-macros","title":"Transition Macros","text":"<p>The following macros are available for performing transitions between actors.</p> <p>Kernel-User transitions:</p> <p><code>.set_k2u_target</code>: Set the target for the user entry point; must be executed in a kernel actor</p> <ul> <li>argument 1: Name of the user actor</li> <li>argument 2: Name of the user function to jump to</li> </ul> <p><code>.set_u2k_target</code>: Set the target for the kernel return point; must be executed in a kernel actor</p> <ul> <li>argument 1: Name of the kernel actor</li> <li>argument 2: Name of the kernel function to jump to</li> </ul> <p><code>.switch_k2u</code>: Perform the transition from kernel to user mode; must be executed in a kernel actor</p> <ul> <li>argument 1: Name of the user actor</li> </ul> <p><code>.switch_u2k</code>: Perform the transition from user to kernel mode; must be executed in a user actor</p> <ul> <li>argument 1: Name of the kernel actor</li> </ul> <p><code>.landing_k2u</code>: Define the landing point in user mode</p> <ul> <li>no arguments</li> </ul> <p><code>.landing_u2k</code>: Define the landing point in kernel mode</p> <ul> <li>no arguments</li> </ul> <p>Host-Guest transitions:</p> <p><code>.set_h2g_target</code>: Set the target for the guest VM entry point; must be executed in a host actor</p> <ul> <li>argument 1: Name of the guest actor</li> <li>argument 2: Name of the guest function to enter</li> </ul> <p><code>.set_g2h_target</code>: Set the target for the host VM exit point; must be executed in a guest actor</p> <ul> <li>argument 1: Name of the host actor</li> <li>argument 2: Name of the host function to return to</li> </ul> <p><code>.switch_h2g</code>: Perform the transition from host to guest mode; must be executed in a host actor</p> <ul> <li>argument 1: Name of the guest actor</li> </ul> <p><code>.switch_g2h</code>: Perform the transition from guest to host mode; must be executed in a guest actor</p> <ul> <li>argument 1: Name of the host actor</li> </ul> <p><code>.landing_h2g</code>: Define the landing point in guest mode</p> <ul> <li>no arguments</li> </ul> <p><code>.landing_g2h</code>: Define the landing point in host mode</p> <ul> <li>no arguments</li> </ul>"},{"location":"user/actors/#actor-non-interference-contract","title":"Actor Non-Interference Contract","text":"<p>The typical scenario for actors is to test isolation between different security domains. For this purpose, Revizor provides a special contract called Actor Non-Interference.</p> <p>Actor Non-Interference contract assumes that (at least one) actor is an observer, and the contract states that the traces collected by the observer actor do not contain any information from the non-observer actors. Or in simpler terms, the observer's execution should not depend on the execution of non-observer actors. And conversely, if Revizor finds a test case where the observer's traces depend on some data from a non-observer actor, it will report a violation.</p> <p>In practice, we use a slightly modified version of the contract which permits leakage of the non-observer actor's memory accesses and control flow, but not of the raw data values. Essentially, it means that the non-observer actors follow the classical <code>ct-seq</code> contract while the observer actor expose all their data. This is done to filter out cases of cross-domain leakage through the cache state, which are typically assumed benign in current software systems. You can read more about the contract and the motivation behind it our paper Enter, Exit, Page Fault, Leak: Testing Isolation Boundaries for Microarchitectural Leaks.</p>"},{"location":"user/cli/","title":"Command-Line Interface","text":"<p>Revizor is controlled via two interfaces: command line and configuration file. Command line arguments specify the mode of operation and set high-level parameters (e.g., file paths, number of fuzzing rounds). Configuration files specify details of the fuzzing campaign (e.g., the target contract, generation parameters, etc).</p> <p>This document describes the command-line interface. For information on configuration files, see the configuration documentation.</p>"},{"location":"user/cli/#modes","title":"Modes","text":"<p>The command line options depend on the selected mode of operation (see modes page for their descriptions). To select a mode on the command-line, begin your command with:</p> <pre><code>rvzr MODE # ... arguments go here\n\n# Where MODE can be:\n#   fuzz            fuzzing mode\n#   tfuzz           template fuzzing mode\n#   reproduce       reproduce mode\n#   minimize        test case minimization mode\n#   analyse         stand-alone trace analysis mode\n#   generate        stand-alone generation mode\n#   download_spec   call the script that downloads the instruction set specification\n</code></pre>"},{"location":"user/cli/#fuzzing-mode","title":"Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>fuzz</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  -t TESTCASE, --testcase TESTCASE\n                        Use an existing test case [DEPRECATED - see reproduce]\n  --timeout TIMEOUT     Run fuzzing with a time limit [seconds]. No timeout when set to zero.\n  --nonstop             Don't stop after detecting an unexpected result\n  --save-violations SAVE_VIOLATIONS\n                        If set, store all detected violations in working directory.\n</code></pre>"},{"location":"user/cli/#template-fuzzing-mode","title":"Template Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>analyse</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  -t TEMPLATE, --template TEMPLATE\n                        The template to use for generating test cases\n  --timeout TIMEOUT     Run fuzzing with a time limit [seconds]. No timeout when set to zero.\n  --nonstop             Don't stop after detecting an unexpected result\n  --save-violations SAVE_VIOLATIONS\n                        If set, store all detected violations in working directory.\n</code></pre>"},{"location":"user/cli/#reproduce-mode","title":"Reproduce Mode","text":"<p>The following command-line arguments are supported in <code>reproduce</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -t TESTCASE, --testcase TESTCASE\n                        Path to the test case\n  -i [INPUTS ...], --inputs [INPUTS ...]\n                        Path to the directory with inputs\n  -n NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case. [IGNORED if --input-dir is set]\n</code></pre>"},{"location":"user/cli/#minimize-mode","title":"Minimize Mode","text":"<p>The following command-line arguments are supported in <code>minimize</code> mode. See also the minimization documentation for a list of available minimization passes.</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  --testcase TESTCASE, -t TESTCASE\n                        Path to the test case program that needs to be minimized.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs to the program that will be used during minimization.\n  --testcase-outfile TESTCASE_OUTFILE, -o TESTCASE_OUTFILE\n                        Output path for the minimized test case program.\n  --input-outdir INPUT_OUTDIR\n                        Output directory for storing minimized inputs.\n  --num-attempts NUM_ATTEMPTS\n                        Number of attempts to minimize the test case.\n  --enable-&lt;pass&gt;       Enable a specific pass during minimization.\n</code></pre>"},{"location":"user/cli/#stand-alone-trace-analysis-mode","title":"Stand-alone Trace Analysis Mode","text":"<p>The following command-line arguments are supported in <code>analyse</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  --ctraces CTRACES\n  --htraces HTRACES\n</code></pre>"},{"location":"user/cli/#stand-alone-generation-mode","title":"Stand-alone Generation Mode","text":"<p>The following command-line arguments are supported in <code>generate</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -r SEED, --seed SEED  Add seed to generate test case.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  --permit-overwrite    Permit overwriting existing files.\n</code></pre>"},{"location":"user/cli/#download-instruction-set-specification","title":"Download Instruction Set Specification","text":"<p>The following command-line arguments are supported in <code>download_spec</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -a ARCHITECTURE, --architecture ARCHITECTURE   The ISA to download the specification for (e.g., x86-64)\n  --outfile OUTFILE, -o OUTFILE   The destination file to save the downloaded specification.\n  --extensions [EXTENSIONS ...]   List of ISA extensions to include in the specification (e.g., SSE, VTX)\n</code></pre>"},{"location":"user/config/","title":"Configuration File","text":"<p>Below is a list of the available configuration options for Revizor, which are passed down to Revizor via a config file. For an example of how to write the config file, see rvzr/tests/big-fuzz.yaml.</p>"},{"location":"user/config/#fuzzing-configuration","title":"Fuzzing Configuration","text":"<pre><code>Name: fuzzer\nDefault: 'basic'\nOptions: 'basic' | 'architectural' | 'archdiff'\n</code></pre> <p>This option selects the fuzzing mode. The available options are:</p> <ul> <li><code>basic</code> - normal model-based fuzzing. A violation in this mode indicates that the CPU exposes more information than predicted by the contract. This option should be used in most testing campaigns.</li> <li><code>architectural</code> - self-fuzzing for architectural mismatches between the model and the executor. This option should be used for testing the fuzzer itself, i.e., a violation in this mode indicates a bug in the fuzzer rather then a bug in the CPU. This is useful when running the fuzzer with a previously-untested instruction set, or when a new contract is implemented.</li> <li><code>archdiff</code> - fuzzing for architectural invariants. This is a special mode targeted for for semi-microarchitectural violations, similar to ZenBleed. This mode is experimental and should be used with caution.</li> </ul> <pre><code>Name: enable_priming\nDefault: True\n</code></pre> <p>This option enables or disables priming. This options should be set to True in most cases, as priming is crucial for eliminating false positives.</p> <p>Priming solves the following problem: Revizor collects hardware traces for inputs in a sequence, and the microarchitectural state is not reset between the inputs. This means that the microarchitectural state for the input at, for example, position 100 is different from the state for the input at position 200. Accordingly, the hardware traces for these inputs may differ because the measurements are taken in different microarchitectural contexts.</p> <p>To address this issue, we uses priming, which swaps the inputs in the sequence and re-runs the tests. For example, if the original sequence is (i1 . . . i99,i100,i101 . . . i199,i200), the priming sequence will be (i1 . . . i99,i200,i101 . . . i199,i100). If the violation persists in this sequence, it is a true positive. If the violation disappears, it is a false positive, and it will be discarded.</p> <pre><code>Name: enable_speculation_filter\nDefault: False\n</code></pre> <p>If enabled, Revizor will discard test cases that do not trigger speculation.</p> <p>This option is useful for improving the throughput of the fuzzer, but it can discard potential violations if the leakage is not caused by speculation.</p> <pre><code>Name: enable_observation_filter\nDefault: False\n</code></pre> <p>If enabled, Revizor will discard test cases that do not leave speculative traces. The filtering is performed by adding an <code>LFENCE</code> after each instruction in the test case, and comparing the resulting hardware traces with the original. If the traces are identical, the test case is discarded.</p> <p>This option is useful for improving the throughput of the fuzzer, but it can discard potential violations if the leakage is not caused by speculation.</p> <pre><code>Name: enable_fast_path_model\nDefault: True\n</code></pre> <p>If enabled, the same contract trace will be used for all inputs in the same taint-based input class.</p> <pre><code>Name: color\nDefault: False\n</code></pre> <p>If enabled, the output will be colored. This option is helps a lot with readability, but may produce corrupted output when redirected to a file.</p> <pre><code>Name: logging_modes\nDefault: ['info', 'stat']\nOptions: 'info' | 'stat' | 'dbg_timestamp' | 'dbg_violation' | 'dbg_dump_htraces' | 'dbg_dump_ctraces' | 'dbg_dump_traces_unlimited' | 'dbg_executor_raw' | 'dbg_model' | 'dbg_coverage' | 'dbg_generator' | 'dbg_priming' | 'dbg_isa_filter'\n</code></pre> <p>This option controls the output:</p> <ul> <li><code>info</code> - general information about the progress of fuzzing;</li> <li><code>stat</code> - statistics the end of the fuzzing campaign;</li> <li><code>dbg_timestamp</code> - every 1000 test cases print the timestamp during the fuzzing process;</li> <li><code>dbg_violation</code> - upon detecting a violation, print detailed information about it;</li> <li><code>dbg_dump_htraces</code> - print the first 100 hardware traces for every test case;</li> <li><code>dbg_dump_ctraces</code> - print the first 100 contract traces for every test case;</li> <li><code>dbg_dump_traces_unlimited</code> - print ALL traces (use carefully, produces LOTS of text);</li> <li><code>dbg_executor_raw</code> - prints hardware traces for every stage of the fuzzing process;   this differs from <code>dbg_dump_htraces</code> in that it prints the traces collected by   speculation/observation filters as well as at every iteration of multi-sample collection;</li> <li><code>dbg_model</code> - print a detailed info about EVERY instruction executed on the model (use carefully, produces LOTS of text);</li> <li><code>dbg_coverage</code> - stores instruction coverage information;</li> <li><code>dbg_generator</code> - prints a list of instructions used to generate test cases;</li> <li><code>dbg_priming</code> - prints information about the priming process; only useful for debugging the priming mechanism itself.</li> <li><code>dbg_isa_filter</code> - when rvzr loads information about the instruction set (normally, from <code>base.json</code>), it filters out some of the instructions, either because of the config options provided by the user, or because some instructions are known to cause issues in the model or executor. This debug option prints the list of instructions that were filtered out, along with the reason for filtering them out.</li> </ul> <pre><code>Name: multiline_output\nDefault: False\n</code></pre> <p>If enabled, each output message will be printed on a separate line. Otherwise, the fuzzing progress will be continuously overwriting the same line (works only in the terminal).</p>"},{"location":"user/config/#program-generator-configuration","title":"Program Generator Configuration","text":"<pre><code>Name: instruction_set\nDefault: (architecture-dependent)\nOptions: 'x86-64' | 'arm64'\n</code></pre> <p>The instruction set under test. Currently, only x86-64 is supported.</p> <pre><code>Name: instruction_categories\nDefault: (architecture-dependent; see rvzr/arch/&lt;isa&gt;/config.py for details)\nOptions: (depends on model backend; see &lt;isa&gt;_config.py for details)\n</code></pre> <p>Select a list of instruction categories to be used when generating programs. This list effectively filters out instructions from the ISA descriptor file (e.g., <code>base.json</code>) passed via the command line (<code>-s</code>).</p> <pre><code>Name: instruction_blocklist\nDefault: (architecture-dependent; see rvzr/arch/&lt;isa&gt;/config.py for details)\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions that will NOT be used for generating programs. This list filters out instructions from <code>instruction_categories</code>, but not from <code>instruction_allowlist</code>.</p> <p>The resulting instruction pool is:      (instructions from instruction_categories - instruction_blocklist) + instruction_allowlist</p> <p>The instructions that are blocked by default are known to cause issues in the model or executor, and hence should generally be avoided when fuzzing.</p> <pre><code>Name: instruction_blocklist_append\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions that will be appended to the default instruction blocklist. This option is identical to <code>instruction_blocklist</code>, but the list is added to the previous blocklist instead of replacing it. This is useful when you want to block some instructions in addition to the default blocklist.</p> <pre><code>Name: instruction_allowlist\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions to use for generating programs. This list has priority over <code>instruction_categories</code> and over <code>instruction_blocklist</code>, thus adding instructions on top of the categories.</p> <p>The resulting instruction pool is:      (instructions from instruction_categories - instruction_blocklist) + instruction_allowlist</p> <pre><code>Name: program_generator_seed\nDefault: 0\n</code></pre> <p>Seed of the program generator. If set to zero, a random seed will be used for each run.</p> <pre><code>Name: program_size\nDefault: 24\n</code></pre> <p>Number of instructions per program. The actual size might be larger because of the instrumentation.</p> <pre><code>Name: avg_mem_accesses\nDefault: 12\n</code></pre> <p>Average number of memory accesses in generated programs. The actual number will be random, but the average over all programs will be close to this value.</p> <pre><code>Name: min_bb_per_function\nDefault: 1\n</code></pre> <p>Minimal number of basic blocks per function in generated programs.</p> <pre><code>Name: max_bb_per_function\nDefault: 2\n</code></pre> <p>Maximal number of basic blocks per function in generated programs.</p> <pre><code>Name: min_successors_per_bb\nDefault: 1\n</code></pre> <p>Minimal number of successors for each basic block in generated programs.</p> <p>Note 1: this config option is a hint; it could be ignored if the instruction set does not have the necessary instructions to satisfy it, or if a certain number of successor is required for correctness</p> <p>Note 2: If min_successors_per_bb &gt; max_successors_per_bb, the value is overwritten with max_successors_per_bb</p> <pre><code>Name: max_successors_per_bb\nDefault: 1\n</code></pre> <p>Maximal number of successors for each basic block in generated programs.</p> <p>Note: this config option is a hint; it could be ignored if the instruction set does not have the necessary instructions to satisfy it, or if a certain number of successor is required for correctness</p> <pre><code>Name: register_allowlist\nDefault: []\nOptions: (any register names)\n</code></pre> <p>A list of registers that CAN be used for generating programs.</p> <p>This list has higher priority than <code>register_blocklist</code>. The resulting list is: (all registers - <code>register_blocklist</code>) + <code>register_allowlist</code>.</p> <pre><code>Name: register_blocklist\nDefault: (all but RAX, RBX, RCX, RDX, RDI, RSI, XMM0-XMM7)\nOptions: (any register names)\n</code></pre> <p>A list of registers that will NOT be used for generating programs.</p> <p>This list has lower priority than <code>register_allowlist</code>. The resulting list is: (all registers - <code>register_blocklist</code>) + <code>register_allowlist</code>.</p> <p>The default blocked registers are used by the executor internally, and thus should be avoided.</p> <pre><code>Name: generator_faults_allowlist\nDefault: []\nOptions: 'div-by-zero' | 'div-overflow' | 'opcode-undefined' | 'bounds-range-exceeded' | 'breakpoint' | 'debug-register' | 'non-canonical-access' | 'user-to-kernel-access'\n</code></pre> <p>By default, the generator will produce programs that never trigger exceptions. This option modifies this behavior by permitting the generator to produce 'unsafe' instruction sequences that could potentially trigger an exception. The model and executor will also be configured to handle these exceptions gracefully.</p> <p>The available options are:</p> <ul> <li><code>div-by-zero</code> - generate divisions with unmasked divisor, which can cause a division by zero exception.</li> <li><code>div-overflow</code> - generate divisions with unmasked dividend, which can cause an overflow exception.</li> <li><code>opcode-undefined</code> - generate undefined opcodes, which can cause an undefined opcode exception.</li> <li><code>bounds-range-exceeded</code> - apply MPX instructions for random bounds checks.   This is possible only if MPX is included in the tested instruction set.</li> <li><code>breakpoint</code> - generate breakpoints, which can cause INT3 exceptions.</li> <li><code>debug-register</code> - generate instructions that cause INT1 exceptions.</li> <li><code>non-canonical-access</code> - randomly select a memory access in a generated program and instrument it to access a non-canonical address.</li> <li><code>user-to-kernel-access</code> - randomly select memory access instructions in user-privilege actors and instrument them to access the kernel actor's (actor 0) memory. This creates cross-privilege-level memory access patterns useful for detecting CPU vulnerabilities like Meltdown. Requires at least one actor with <code>privilege_level: user</code>. The instrumentation modifies both the memory operands and the sandboxing masks to ensure accesses target the kernel's FAULTY data area.</li> </ul>"},{"location":"user/config/#actor-configuration","title":"Actor Configuration","text":"<p>All actors are defined in the <code>actors</code> list, with the following syntax:</p> <pre><code>actors:\n  - &lt;actor1_name&gt;\n    - &lt;actor_option&gt;: &lt;value&gt;\n    - &lt;actor_option&gt;:\n       - &lt;sub_option1&gt;: &lt;value1&gt;\n       - &lt;sub_option2&gt;: &lt;value2&gt;\n    ...\n  - &lt;actor2_name&gt;\n      ...\n  ...\n</code></pre> <p>The following options are available for each actor:</p> <pre><code>Actor Option: mode\nDefault: 'host'\nOptions: 'host' | 'guest'\n</code></pre> <p>The execution mode of the actor. The available options are:</p> <ul> <li><code>host</code> - the actor runs in the normal, non-virtualized mode.</li> <li><code>guest</code> - the actor runs in a VM (one VM per actor).</li> </ul> <pre><code>Actor Option: privilege_level\nDefault: 'kernel'\nOptions: 'user' | 'kernel'\n</code></pre> <p>The privilege level of the actor. The available options are:</p> <ul> <li><code>user</code> - the actor runs in user mode (CPL=3).</li> <li><code>kernel</code> - the actor runs in kernel mode (CPL=0).</li> </ul> <pre><code>Actor Option: data_properties\nDefault: (see below)\nOptions: 'present' | 'writable' | 'user' | 'accessed'\n         | 'dirty' | 'executable' | 'reserved_bit' | 'randomized'\n</code></pre> <p>The properties of the data memory used by the actor. These properties are applied only to the second page (FAULTY_AREA) of the actor's data region.</p> <p>The available options are:</p> <ul> <li><code>present</code> [default: True] - the value of the Present bit in the page table entry.</li> <li><code>writable</code> [default: True] - the value of the Writable bit in the page table entry.</li> <li><code>user</code> [default: False] - the value of the User/Supervisor bit in the page table entry.</li> <li><code>accessed</code> [default: True] - the value of the Accessed bit in the page table entry.</li> <li><code>dirty</code> [default: True] - the value of the Dirty bit in the page table entry.</li> <li><code>executable</code> [default: False] - the value of the Executable bit in the page table entry.</li> <li><code>reserved_bit</code> [default: False] - the value of the Reserved bit in the page table entry.</li> <li><code>randomized</code> [default: False] - if true, the values of the above properties will be randomized for each test case.</li> </ul> <p>Note that the above properties are set in the host page tables for actors with <code>mode: host</code>, and in the guest page tables for actors with <code>mode: guest</code>.</p> <pre><code>Actor Option: data_ept_properties\nDefault: (see below)\nOptions: 'present' | 'writable' | 'executable' | 'accessed' | 'dirty' | 'user'\n        | 'reserved_bit' | 'randomized'\n</code></pre> <p>The properties of the EPT entry used by the actor (on Intel) or the NPT entry (on AMD). The properties are applied only to the second page (FAULTY_AREA) of the actor's data region.</p> <p>This property has no effect on actors with <code>mode: host</code>.</p> <p>The available options are:</p> <ul> <li><code>present</code> [default: True] - the value of the Present bit in the EPT/NPT entry.</li> <li><code>writable</code> [default: True] - the value of the Writable bit in the EPT/NPT entry.</li> <li><code>executable</code> [default: False] - the value of the Executable bit in the EPT/NPT entry.</li> <li><code>accessed</code> [default: True] - the value of the Accessed bit in the EPT/NPT entry.</li> <li><code>dirty</code> [default: True] - the value of the Dirty bit in the EPT/NPT entry.</li> <li><code>user</code> [default: False] - the value of the User/Supervisor bit in the EPT/NPT entry.</li> <li><code>reserved_bit</code> [default: False] - the value of the Reserved bit in the EPT/NPT entry.</li> <li><code>randomized</code> [default: False] - if true, the values of the above properties will be randomized for each test case.</li> </ul> <pre><code>Actor Option: observer\nDefault: False\n</code></pre> <p>If enabled, the actor will be an observer actor, hence modelling an attacker. This option is only used if the contract is <code>noninterference</code>, and it is ignored otherwise.</p> <pre><code>Actor Option: instruction_blocklist\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>Actor-specific instruction blocklist. This list has priority over the global <code>instruction_blocklist</code>.</p> <pre><code>Actor Option: fault_blocklist\nDefault: []\nOptions: (any fault names from generator_faults_allowlist)\n</code></pre> <p>Actor-specific fault blocklist. This list has priority over the global <code>generator_faults_allowlist</code> and prevents specific actors from having certain fault-inducing instrumentation applied to their code.</p> <p>For example, when using <code>user-to-kernel-access</code>, you typically want to add it to the kernel actor's <code>fault_blocklist</code> to prevent the kernel from accessing its own memory (which would not be a cross-privilege access).</p>"},{"location":"user/config/#input-generator-configuration","title":"Input Generator Configuration","text":"<pre><code>Name: data_generator\nDefault: 'random'\nOptions: 'random'\n</code></pre> <p>The input generator type. Currently, only random input generation is supported.</p> <pre><code>Name: data_generator_seed\nDefault: 10\n</code></pre> <p>Seed of the input generator. If set to zero, a random seed will be used for each run.</p> <pre><code>Name: data_generator_entropy_bits\nDefault: 16\n</code></pre> <p>Entropy of the random values created by the input generator. The maximum value is 31.</p> <pre><code>Name: input_gen_probability_of_special_value\nDefault: 0.05\n</code></pre> <p>If non-zero, the input generator will generate not only random values for the input data, but also, with a given probability, special values, such as zero or the maximum integer value (MAX INT). This is used to test fast paths in the microarchitecture.</p> <pre><code>Name: inputs_per_class\nDefault: 2\n</code></pre> <p>Number of inputs generated for each input class by the Contract-Driven Input Generator. For the explanation of the input classes and the generation algorithm, see (this paper)[https://arxiv.org/pdf/2301.07642], Section 4.D. Contract-driven Input Generator.</p>"},{"location":"user/config/#contract-configuration","title":"Contract Configuration","text":"<pre><code>Name: contract_execution_clause\nDefault: ['seq']\nOptions: 'seq' | 'no_speculation' | 'seq-assist' | 'cond' | 'conditional_br_misprediction' | 'bpas' | 'nullinj-fault' | 'nullinj-assist' | 'delayed-exception-handling' | 'div-zero' | 'div-overflow' | 'meltdown' | 'fault-skip' | 'noncanonical' | 'vspec-ops-div' | 'vspec-ops-memory-faults' | 'vspec-ops-memory-assists' | 'vspec-ops-gp' | 'vspec-all-div' | 'vspec-all-memory-faults' | 'vspec-all-memory-assists'\n</code></pre> <p>The execution clause of the contract.</p> <ul> <li><code>seq</code> - sequential execution.</li> <li><code>no_speculation</code> - sequential execution. Synonym for <code>seq</code>.</li> <li><code>seq-assist</code> - sequential execution with possible microcode assists.</li> <li><code>cond</code> - permitted misprediction of conditional branches.</li> <li><code>conditional_br_misprediction</code> - permitted misprediction of conditional branches. Synonym for <code>cond</code>.</li> <li><code>bpas</code> - permitted speculative store bypass</li> <li><code>nullinj-fault</code> - page faults are permitted to speculatively return zero.</li> <li><code>nullinj-assist</code> - microcode assists are permitted to speculatively return zero.</li> <li><code>delayed-exception-handling</code> - upon an exception or a fault, data-independent instructions that follow the exception are allowed to execute speculatively.</li> <li><code>meltdown</code> - permission-based page faults are permitted to speculatively return the value in the memory.</li> <li><code>fault-skip</code> - upon a fault, the faulting instruction is speculatively skipped.</li> <li><code>noncanonical</code> - permitted speculative non-canonical memory accesses.</li> <li><code>vspec*</code> - experimental contracts for value speculation. See (this paper)[https://www.usenix.org/system/files/usenixsecurity23-hofmann.pdf] for details.</li> <li><code>div-zero</code> - experimental contract; do not use.</li> <li><code>div-overflow</code> - experimental contract; do not use.</li> </ul> <pre><code>Name: contract_observation_clause\nDefault: 'ct'\nOptions: 'none' | 'l1d' | 'memory' | 'pc' | 'ct' | 'loads+stores+pc' | 'ct-nonspecstore' | 'ctr' | 'arch' | 'tct' | 'tcto' | 'ct-ni'\n</code></pre> <p>The observation clause of the contract. In most cases, the default value should be used.</p> <p>For single-actor experiments, the following options are available:</p> <ul> <li><code>none</code> - the model observes nothing. Useful for testing the fuzzer.</li> <li><code>l1d</code> - the model observes the addresses of data accesses, adjusted to imitate the L1D cache trace.   Has very few real applications, and should be generally avoided.</li> <li><code>memory</code> - the model observes the addresses of data accesses.</li> <li><code>ct</code> (constant time tracer) - the model observes the addresses of data accesses and the control flow.</li> <li><code>loads+stores+pc</code> - the model observes the addresses of data accesses and the control flow. Synonym for <code>ct</code>.</li> <li><code>ct-nonspecstore</code> - the model observes the addresses of data accesses and the control flow, but does not observe the addresses of stores during speculation.</li> <li><code>ctr</code> - the model observes the addresses of data accesses and the control flow, as well as the values of the general-purpose registers.</li> <li><code>arch</code> - the model observes the addresses of data accesses and the control flow, as well as the values loaded from memory.   This clause imitates the security guarantees provided by secure speculation mechanisms like STT.</li> <li><code>tct</code> (truncated constant time tracer) - the model observes address of the memory access and of the program counter at cache line granularity.</li> <li><code>tcto</code> (truncated constant time tracer with overflows) - the model address of the memory access and of the program counter at cache line granularity + observe cache line overflows.</li> </ul> <p>In multi-actor context, only one option is available:</p> <ul> <li><code>ct-ni</code> - when executing actors with <code>observer: false</code>, the model observes the same data as as with <code>ct</code>. When executing actors with <code>observer: true</code>, the model observes complete memory of the actor as well as their register values.</li> </ul> <pre><code>Name: model_backend\nDefault: 'unicorn'\nOptions: 'dummy' | 'unicorn' | 'dynamorio'\n</code></pre> <p>The backend used to implement the contract model. The available options are: * <code>unicorn</code> - use the Unicorn emulator. This is the default option and it is recommended for most cases. * <code>dynamorio</code> - use the DynamoRIO dynamic binary instrumentation framework. This option is newly added and experimental. Avoid using it unless you are doing development work on Revizor. * <code>dummy</code> - use a dummy model. This model always returns the same (empty) contract trace, and as such will not produce meaningful results. This option is useful, however, when root-causing violations, because it allows to collect hardware traces without running the model, hence allowing to trace instructions that are not supported by any of the backends.</p> <pre><code>Name: model_min_nesting\nDefault: 1\n</code></pre> <p>Minimum number of nested mispredictions in the model. This value is used to generate the contract traces on the fast path of the fuzzer.</p> <pre><code>Name: model_max_nesting\nDefault: 30\n</code></pre> <p>Maximum number of nested mispredictions in the model. This value is used to generate the contract traces on the slow path of the fuzzer, i.e., when a potential violation is detected and the fuzzer tries to check if it is a true positive.</p> <pre><code>Name: model_max_spec_window\nDefault: 250\n</code></pre> <p>Size of the speculation window in the model.</p>"},{"location":"user/config/#executor-configuration","title":"Executor Configuration","text":"<pre><code>Name: executor\nDefault: (auto-detected)\nOptions: 'x86-64-intel' | 'x86-64-amd' | 'arm64'\n</code></pre> <p>The executor type. The default value is auto-detected based on the <code>cpuinfo</code>. Should be changed only if the auto-detection fails.</p> <pre><code>Name: executor_mode\nDefault: 'P+P'\nOptions: 'P+P' | 'F+R' | 'E+R' | 'PP+P' | 'TSC'\n</code></pre> <p>Hardware trace collection mode. The available options are:</p> <ul> <li><code>P+P</code> - prime and probe.</li> <li><code>F+R</code> - flush and reload.</li> <li><code>E+R</code> - evict and reload.</li> <li><code>PP+P</code> - partial prime and probe (i.e., leave a subset of cache lines unprimed).</li> <li><code>TSC</code> - use RDTSCP instruction to measure the time of the execution.</li> </ul> <pre><code>Name: executor_warmups\nDefault: 5\n</code></pre> <p>Number of warmup rounds executed before starting to collect hardware traces.</p> <pre><code>Name: executor_sample_sizes\nDefault: [10, 50, 100, 500]\n</code></pre> <p>A list of sample sizes to be used during the measurements. The executor will first collect the hardware traces with the first sample size in the list, and if a violation is detected, it will try to reproduce it with all the following sample sizes.</p> <pre><code>Name: executor_filtering_repetitions\nDefault: 10\n</code></pre> <p>The sample size to be used by the speculation and observation filters.</p> <pre><code>Name: executor_taskset\nDefault: 0\n</code></pre> <p>The ID of the CPU core on which the executor is running test cases.</p> <pre><code>Name: enable_pre_run_flush\nDefault: True\n</code></pre> <p>If enabled, the executor will do its best to flush the microarchitectural state before running test cases.</p> <pre><code>Name: x86_executor_enable_ssbp_patch\nDefault: True\n</code></pre> <p>Enable a microcode patch against Speculative Store Bypass, if available.</p> <pre><code>Name: x86_executor_enable_prefetcher\nDefault: False\n</code></pre> <p>Enable all prefetchers, if the software controls are available.</p> <pre><code>Name: x86_disable_div64\nDefault: True\n</code></pre> <p>Do not generate 64-bit division instructions. Useful for avoiding certain types of speculation that are specific to 64-bit division.</p> <pre><code>Name: x86_enable_hpa_gpa_collisions\nDefault: False\n</code></pre> <p>When a test case contains at least one guest actor, allocate its memory in the guest physical address space to match the corresponding host physical addresses of the main actor. Useful for testing Foreshadow-like leaks.</p> <pre><code>Name: x86_generator_align_locks\nDefault: True\n</code></pre> <p>When generating memory accesses with locks, apply instrumentation to align the locks to 8 bytes. Useful for avoiding faults on unaligned accesses.</p>"},{"location":"user/config/#analyser-configuration","title":"Analyser Configuration","text":"<pre><code>Name: analyser\nDefault: 'chi2'\nOptions: 'chi2' | 'mwu' | 'sets' | 'bitmaps'\n</code></pre> <p>The type of the analyser that is used to compare the hardware traces and contract traces.</p> <p>The available options are:</p> <ul> <li><code>sets</code> - combine the hardware traces for each input into a set. A violation is reported if two inputs in the same contract-equivalence class have different sets of hardware traces.</li> <li><code>bitmaps</code> - combine the hardware traces for each input into a bitmap. A violation is reported if two inputs in the same contract-equivalence class have different bitmaps of hardware traces.</li> <li><code>chi2</code> - use the chi-squared homogeneity test to compare the hardware traces of inputs in the same contract-equivalence class. This test effectively checks if the hardware traces from two different inputs come from the same distribution. A violation is reported if the test fails.</li> <li><code>mwu</code> - [experimental; both false positives and negatives are possible]   use the Mann-Whitney U test to compare the hardware traces of inputs in the same contract-equivalence class. This test effectively checks if the hardware traces from two different inputs come from the same distribution. A violation is reported if the test fails.</li> </ul> <pre><code>Name: analyser_subsets_is_violation\nDefault: False\n</code></pre> <p>This option is relevant only for the <code>sets</code> and <code>bitmaps</code> analysers.</p> <p>If enabled, the analyser will not label hardware traces as mismatching if they form a subset relation.</p> <pre><code>Name: analyser_outliers_threshold\nDefault: 0.1\n</code></pre> <p>This option is relevant only for the <code>sets</code> and <code>bitmaps</code> analysers.</p> <p>The analyser will ignore the hardware traces that appear in less than this percentage of the repetitions.</p> <pre><code>Name: analyser_stat_threshold\nDefault: 0.5\n</code></pre> <p>This option is relevant only for the <code>chi2</code> and <code>mwu</code> analysers.</p> <p>The threshold for the statistical tests. If a pair of hardware traces has the (normalized) statistics below the threshold, then the traces are considered equivalent.</p> <p>For the chi2 test, the threshold is applied to the <code>statistics / (len(htrace1) + len(htrace2))</code>.</p> <p>For the mwu test, the threshold is applied to the p-value.</p>"},{"location":"user/config/#miscellaneous-configuration","title":"Miscellaneous Configuration","text":"<pre><code>Name: coverage_type\nDefault: 'none'\nOptions: 'none' | 'model_instructions'\n</code></pre> <p>The type of coverage tracking. The available options are:</p> <ul> <li><code>none</code> - disable coverage tracking.</li> <li><code>model_instructions</code> - track how many times the model executed each instruction.</li> </ul> <pre><code>Name: minimizer_retries\nDefault: 1\n</code></pre> <p>Number of minimization retries. When the minimizer performs a check to reduce a test case, each check is attempted this number of times and it succeeds if at least one check is successful.</p>"},{"location":"user/macros/","title":"Macros","text":"<p>This document explains the concept of macros in Revizor and describes how to create test cases that use macros.</p> <p>Note that macros are especially useful in the template-based mode of Revizor, so if you are not familiar, check out the Template-Based Mode documentation as well.</p>"},{"location":"user/macros/#what-is-a-macro","title":"What is a macro?","text":"<p>Macros in Revizor are special pseudo-instructions that provide a flexible way to insert complex operations into test cases. They appear as labels of a special format in the assembly code but are dynamically expanded into actual implementations during execution by the model and the executor.</p> <p>Macros solve two key challenges, especially in the context of multi-domain testing:</p> <ul> <li>Structuring: Enable insertion of pre-defined instruction sequences (like domain transitions or microarchitectural isolation primitives) within randomized test contexts</li> <li>Unification: Allow the same test case template to be instantiated differently across executor and model stages, accommodating differences in ISA support.</li> </ul>"},{"location":"user/macros/#macro-definition-and-usage","title":"Macro Definition and Usage","text":""},{"location":"user/macros/#assembly-syntax","title":"Assembly Syntax","text":"<p>Macros use standard assembly syntax of a label with the <code>.macro</code> prefix:</p> <pre><code>.macro.macro_name.argument1.argument2.argument3.argument4:\n</code></pre> <p>A macro can take at most four arguments. The arguments are strictly static; Revizor does not support dynamic arguments in macros, such as registers or memory addresses.</p>"},{"location":"user/macros/#example-usage","title":"Example Usage","text":"<p>A user can create a test case program where only a subset of instruction is measured by using <code>measurement_start</code> and <code>measurement_end</code> macros:</p> <pre><code>.intel_syntax noprefix\n.section .data.main\n\n... ; non-measured code here\n\n.macro.measurement_start:\n\n... ; measured code here\n\n.macro.measurement_end:\n\n... ; non-measured code here\n\n.test_case_exit:\n</code></pre> <p>Revizor will automatically replace the macros with no-op operations of an ISA-dependent size, and record the location and the arguments of the macros in the test case metadata. When the executor and the model run the test case, they will recognize these macros and execute the corresponding logic. Note that the logic can be configurable, e.g., when the user has set <code>executor_mode: P+P</code> (prime+probe), the <code>measurement_start</code> macro will correspond the Prime stage of the measurement, and <code>measurement_end</code> will correspond to the Probe stage.</p> <p>See Implementation Overview for details on how macros are implemented in the executor and model.</p>"},{"location":"user/macros/#available-macro-types","title":"Available Macro Types","text":"<p>Measurement Macros:</p> <ul> <li><code>measurement_start</code>: Begin hardware/contract trace collection</li> <li><code>measurement_end</code>: End hardware/contract trace collection</li> </ul> <p>Fault Handling Macros:</p> <ul> <li><code>fault_handler</code>: Label the location where control flow should be redirected upon an exception or interrupt</li> </ul> <p>Example usage: <pre><code>mov rdx, 0\nmov rax, 0\nmov rbx, 0\ndiv rbx  ; This will cause a division by zero exception\n\n.fault_handler:\n    ; Execute some code after the fault\n    mov rax, 1\n</code></pre></p> <p>Note that if <code>fault_handler</code> is not defined, the executor will use a default handler that jumps to the exit point of the test case.</p> <p>Generation Macros:</p> <ul> <li><code>random_instructions.N</code>: Generate N random instructions. This macro is intended to be used in the template-based mode.</li> </ul> <p>Example usage: <pre><code>mov rax, 0\nmov rbx, 0\n.random_instructions.10:  ; Generate 10 random instructions\nmul rax, rcx\n</code></pre></p> <p>Actor Transition Macros:</p> <ul> <li>Host-guest transitions:<ul> <li><code>set_h2g_target</code>: Set VM entry point</li> <li><code>set_g2h_target</code>: Set VM exit point</li> <li><code>switch_h2g</code>: Host to guest transition</li> <li><code>landing_h2g</code>: Label guest landing point</li> <li><code>switch_g2h</code>: Guest to host transition</li> <li><code>landing_g2h</code>: Label host landing point</li> </ul> </li> <li>Kernel-user transitions:<ul> <li><code>set_k2u_target</code>: Set user mode entry point</li> <li><code>set_u2k_target</code>: Set kernel mode entry point</li> <li><code>switch_k2u</code>: Kernel to user transition</li> <li><code>switch_u2k</code>: User to kernel transition</li> <li><code>landing_k2u</code>: Kernel to user landing point</li> <li><code>landing_u2k</code>: User to kernel landing point</li> </ul> </li> </ul> <p>See Actors for more details and examples of how to use these macros.</p>"},{"location":"user/macros/#implementation-overview","title":"Implementation Overview","text":""},{"location":"user/macros/#internal-representation-of-macros","title":"Internal Representation of Macros","text":"<p>Revizor internally replaces all macros with a no-op placeholder of a fixed size (8 bytes for x86-64, 12 bytes for ARM64). This placeholder is used to maintain the original instruction flow while allowing the executor and model to recognize and handle macros dynamically. The macro location, type, and arguments are stored in the test case metadata, namely in the <code>SYMBOL TABLE</code> section of the RCBF File Format, where <code>owner</code> is set to the actor ID of the actor that contains the macro, <code>offset</code> is the offset of the macro placeholder in the code section of the actor, <code>id</code> is the macro type (defined in executor_km/include/macro_expansion.h), and <code>args</code> is a compressed representation of the macro arguments.</p>"},{"location":"user/macros/#macros-in-executor","title":"Macros in Executor","text":"<p>Each actor's code section contains a dedicated memory region for macros, and the implementation is copied there during test case initialization. The executor copies the implementations of all macros into this section, and it replaces the macro placeholders with direct jumps to the corresponding implementations. The executor also inserts a return jump at the end of each macro implementation to return control flow back to the original instruction sequence.</p> <p>For example, if we have a simple test case like this:</p> <pre><code>.macro.measurement_start:\n... ; some code here\n.macro.measurement_end:\n.test_case_exit:\n</code></pre> <p>The executor with expand it as follows:</p> <pre><code>jump measurement_start_impl\nlfence\n.l1:\n... ; some code here\njump measurement_end_impl\nlfence\n.l2:\n.test_case_exit:\n\n.macro_code_section:\nmeasurement_start_impl:\n... ; sequence of instructions that implements the macro\njump .l1  ; jump to the end of the macro section\n\nmeasurement_end_impl:\n... ; sequence of instructions that implements the macro\njump .l2  ; jump to the end of the macro section\n</code></pre> <p>Note that the executor also inserts LFENCE barriers after each macro jump. This is to ensure that the macro execution does not trigger straight-line speculation, which could interfere with the measurement process.</p>"},{"location":"user/macros/#macros-in-model","title":"Macros in Model","text":"<p>In the model, macros are implemented as dynamic callbacks. The model executes a hook function on every instruction execution, checking if the current instruction matches an entry in the symbol table. If a match is found, the model invokes the corresponding callback function to emulate the macro behavior.</p>"},{"location":"user/minimization/","title":"Minimization of Violation Artifacts","text":"<p><code>minimize</code> mode of Revizor performs post-processing of the violation artifacts produced as a result of testing a CPU in the <code>fuzz</code> mode. This mode takes a violating program and its sequence of inputs, and it performs a series of transformation passes to simplify the program and the inputs while preserving the violation. The goal is to produce a minimal artifact that would be easier to understand and analyze by a human.</p>"},{"location":"user/minimization/#usage","title":"Usage","text":"<p>To run the minimization mode, you need a program that violates the contract (e.g., <code>program.asm</code>), a configuration file that was used to detect the violation (e.g., <code>config.yaml</code>), a specification of the instruction set (e.g., <code>base.json</code>). The config file must set the input generation seed (<code>data_generator_seed</code>) to the value that matches the seed used in the <code>fuzz</code> mode to generate the violating inputs.</p> <p>The syntax of the command is as follows:</p> <pre><code>rvzr minimize -s &lt;spec_file&gt; -c &lt;config_file&gt; -t &lt;program_file&gt; -o &lt;output_file&gt; -i &lt;num_inputs&gt; --input-outdir &lt;input_outdir&gt; --num-attempts &lt;num_attempts&gt; &lt;pass_list&gt;\n</code></pre> <p>A typical example of the command is:</p> <pre><code>rvzr minimize -s base.json -c config.yaml -i 25 -t program.asm -o min.asm --input-outdir ./inputs --num-attempts 10 --enable-instruction-pass 1\n</code></pre> <p>This example command will take the program <code>program.asm</code>, generate an input sequence of length 25 based on the seed in <code>config.yaml</code>, and then apply a series of transformation passes (see the list of supported passes below) to simplify the program and the inputs. The passes will be applied 10 times. The resulting simplified program will be written to <code>min.asm</code>, and the simplified input sequence will be written to the directory <code>&lt;dir&gt;</code>.</p>"},{"location":"user/minimization/#supported-passes","title":"Supported Passes","text":"<p><code>minimize</code> mode supports three types of passes: program passes modify the program, input passes modify the input sequence, and analysis passes provide additional information about the violation, usually by adding comments to the program.</p>"},{"location":"user/minimization/#program-passes","title":"Program Passes","text":"<pre><code>--enable-instruction-pass\n</code></pre> <p>Enables the instruction minimization pass that iteratively removes instructions from the program while preserving the violation.</p> <pre><code>--enable-simplification-pass\n</code></pre> <p>Enables the instruction simplification pass that replaces complex instructions with simpler ones while preserving the violation.</p> <pre><code>--enable-nop-pass\n</code></pre> <p>Enables the NOP replacement pass that iteratively replaces instructions with NOPs of the same size while preserving the violation.</p> <pre><code>--enable-constant-pass\n</code></pre> <p>Enables the constant simplification pass that replaces immediate arguments of instructions with 0s while preserving the violation.</p> <pre><code>--enable-mask-pass\n</code></pre> <p>Enables the mask simplification pass that reduces the size of the instrumentation masks while preserving the violation.</p> <pre><code>--enable-label-pass\n</code></pre> <p>Enables the label removal pass that removes unused labels from the assembly file.</p> <pre><code>--enable-fence-pass\n</code></pre> <p>Enables the fence insertion pass that adds LFENCEs after instructions while preserving the violation.</p>"},{"location":"user/minimization/#input-passes","title":"Input Passes","text":"<pre><code>--enable-input-seq-pass\n</code></pre> <p>Enables the input sequence minimization pass that removes inputs from the original generated sequence while preserving the violation.</p> <pre><code>--enable-input-diff-pass\n</code></pre> <p>Enables the violating input difference minimization pass that operates on the pair of (contract-equivalent) inputs that triggered the violation and attempts to minimize the difference between the two inputs. It does so by iterating over all bytes in the inputs, and (1) attempting to replace each byte with zero, and if it fails, (2) copying the byte from the first input to the second input.</p>"},{"location":"user/minimization/#analysis-passes","title":"Analysis Passes","text":"<pre><code>--enable-source-analysis\n</code></pre> <p>Enables the speculation source identification pass that analyzes the program to identify suspected sources of speculation, and adds the corresponding comments to the assembly file. Note that the analysis is not guaranteed to be correct, and it may produce false results.</p> <pre><code>--enable-comment-pass\n</code></pre> <p>Enables the violation comment pass that adds comments to the assembly file with details about the violation. Namely, it adds comments to every memory access in the following format:</p> <p><code># mem access: [input1_id] [load_addr]-[store_addr] CL [cache_set_id]:[cache_line_offset] | [input2_id] [load_addr]-[store_addr] CL [cache_set_id]:[cache_line_offset]</code></p> <p>The comment indicates the addresses (<code>load_addr</code> and <code>store_addr</code>) of the given memory operation when executed with the two inputs that triggered the violation (<code>input1_id</code> and <code>input2_id</code>). For convenience, it also provides the L1D cache set ID and line offset that correspond to the addresses of the memory operation.</p> <p>For example, this comment</p> <p><code># mem access: [1] 0x800-0x800 CL 32:0 | [11] 0x710-0x710 CL 28:10</code></p> <p>indicates that the memory operation preceded by this comment was executed with two inputs, <code>1</code> and <code>11</code>, and the memory operation accessed the addresses <code>0x800</code> and <code>0x710</code> in the two inputs, respectively. The address <code>0x800</code> corresponded to cache set <code>32</code> and line offset <code>0</code>, while the address <code>0x710</code> corresponded to cache set <code>28</code> and line offset <code>10</code>.</p>"},{"location":"user/minimization/#interpreting-the-output","title":"Interpreting the Output","text":"<p>When a pass executes, it prints out the progress into the console.</p>"},{"location":"user/minimization/#output-of-program-passes","title":"Output of Program Passes","text":"<p>Most of the passes print out one character per instruction, with <code>.</code> indicating that the pass succeeded, and <code>-</code> indicating that the pass failed on the given instruction. For example, if <code>--enable-instruction-pass</code> is enabled, the output may look like this:</p> <p><pre><code>[Pass 2] Instruction Removal Pass\n\n.............-.....--.-------..----\n</code></pre> This means that the pass successfully removed the last 13 instructions, failed to remove the 14th instruction, succeeded on the 15th instruction, and so on. Note that the pass iterates from bottom to top, hence the output is printed in reverse order.</p>"},{"location":"user/minimization/#output-of-input-passes","title":"Output of Input Passes","text":"<p>The <code>input-diff</code> pass has a slightly different output format. It prints out a compact representation of the input difference, with each character representing a byte in the input sequence: * <code>.</code> indicates that zeroing the byte succeeded * <code>+</code> indicates that copying the byte succeeded * <code>=</code> indicates that the byte was already the same in both inputs * <code>^</code> indicates that the pass failed to minimize the byte, and it remained different in the two inputs</p> <p>For example, the output of the <code>input-diff</code> pass may look like this:</p> <pre><code>Address    +0x0     +0x40    +0x80    +0xc0    +0x100   +0x140   +0x180   +0x1c0\n0x00000000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00002000 ====^=..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2020']\n</code></pre> <p>This output indicates that the pass successfully minimized the input difference for all bytes except for the byte at address <code>0x2020</code>, which remained different in the two inputs, and the bytes at addresses <code>0x2000-0x2018</code> and <code>0x2028</code> were already the same in both inputs.</p>"},{"location":"user/minimization/#usage-example","title":"Usage Example","text":"<p>The following example demonstrates a typical workflow of using the <code>minimize</code> mode to simplify a violating program and its input sequence.</p> <p>Let's assume that a violation artifact was produces as a result of a fuzzing campaign like this:</p> <pre><code>rvzr fuzz -s base.json -c config.yaml -n 1000 -i 25 -w .\n</code></pre> <p>The first step is to minimize the violating program by enabling all program passes:</p> <pre><code>rvzr minimize -s base.json -c ./violation-000000-000000/minimize.yaml \\\n     -t ./violation/violation-000000-000000/program.asm \\\n     -o min.asm -i 25 --num-attempts 3 \\\n     --enable-instruction-pass 1 \\\n     --enable-simplification-pass 1 \\\n     --enable-nop-pass 1 \\\n     --enable-constant-pass 1 \\\n     --enable-mask-pass 1 \\\n     --enable-label-pass 1\n</code></pre> <p>Then verify the violation is preserved by reproducing it with the minimized program and the original input sequence:</p> <pre><code>rvzr fuzz -s base.json -c minimize.yaml -t min.asm -i 25\n</code></pre> <p>If the violation is detected, move to the next step. Otherwise, re-run the first command with a lower number of <code>--num-attempts</code> or try to disable some of the passes.</p> <p>The next step is to minimize the inputs by enabling all input passes, and to add analysis comments:</p> <pre><code>rvzr minimize -s base.json -c ./violation/violation-240712-132351/minimize.yaml \\\n    -t min.asm \\\n    -o commented.asm -i 25  \\\n    --input-outdir ./inputs \\\n    --enable-input-diff-pass 1 \\\n    --enable-input-seq-pass 1 \\\n    --enable-source-analysis 1 \\\n    --enable-comment-pass 1\n</code></pre> <p>The final step is to try to reproduce the violation with the minimized program and inputs to verify that the violation is preserved:</p> <pre><code>rvzr reproduce -s base.json -c ./violation/violation-240712-132351/reproduce.yaml \\\n    -t commented.asm -i ./inputs/min_input*.bin\n</code></pre> <p>If the violation is detected, the minimized program and inputs can be used for further analysis.</p>"},{"location":"user/modes/","title":"Modes of Operation","text":"<p>Revizor supports several modes of operation, each targeting a different use cases. The selection of the mode is described in the CLI documentation. Below is a brief description of each mode.</p> Mode CLI Key Use Case Description Fuzzing fuzz General Testing Test a CPU against a contract model. Test cases generated randomly Template Fuzzing tfuzz Targeted Testing Test a CPU against a contract model. Test cases generated based on a template Reproduce reproduce Reproducing a Violation Reproduce a violation found by fuzzing OR run a manually-written test case Minimization minimize Violation Simplification Simplify a test case by applying a series of simplification passes to the test case program and its inputs Trace Analysis analyse Stand-alone Analysis Analyze pre-recorded traces for violations Generation generate Stand-alone Generation Only generate test cases, without testing them ISA Spec Install download_spec Tool Installation Call a script that downloads the instruction set specification"},{"location":"user/modes/#fuzzing-and-template-fuzzing-modes","title":"Fuzzing and Template Fuzzing Modes","text":"<p>Two main modes of operation in revizor are fuzzing and template fuzzing. These modes are used to test a CPU against a contract model. In both modes, revizor generates test cases and executes them on the target CPU and the model, records the corresponding traces, and checks if the hardware traces contain the same (or less) information as the contract traces.</p> <p>In the fuzzing mode, test cases are generated randomly, with the instruction set and size of test cases defined by the config file. This mode is used for broad testing of the CPU.</p> <p>In the template fuzzing mode, test cases are generated based on a template: The generator takes an assembly template as an input, and produces a test case by expanding the <code>random_instructions</code> macro in the template. This mode is used to narrow down the fuzzing space and focus on specific scenarios, such as testing microarchitectural patches or certain interactions between actors.</p>"},{"location":"user/modes/#reproduce","title":"Reproduce","text":"<p>In this mode, Revizor loads a test case from a set of files and runs a single round of the fuzzer with this test case. The test case is usually a violation previously found in the (template) fuzzing mode, but it can also be written manually.</p> <p>There are three main use cases for this mode:</p> <ol> <li>Analysis of the violation: to understand the root cause of the violation, the user may manually modify the test case and re-run it in the reproduce mode to see if the violation is still present.</li> <li>Reproducibility check: to check if a violation is reproducible on different CPUs, or on different configurations of the same CPU (e.g., after a microcode patch has been applied).</li> <li>Manual testing: to test a manually-written test case.</li> </ol>"},{"location":"user/modes/#minimization","title":"Minimization","text":"<p>In this mode, Revizor takes a test case that causes a violation and applies a series of simplification passes to the test case program and its inputs. The goal is to reduce the test case to its minimal form to simplify the root cause analysis of the violation. Revizor supports an extensive list of passes, described in the minimization documentation.</p>"},{"location":"user/modes/#stand-alone-interfaces","title":"Stand-alone Interfaces","text":"<p>The <code>analyse</code> and <code>generate</code> modes are used to perform stand-alone access to modules of Revizor. In the <code>analyse</code> mode, the user can analyze pre-recorded traces for violations. In the <code>generate</code> mode, the user can generate test cases without testing them.</p>"},{"location":"user/modes/#isa-spec-install","title":"ISA Spec Install","text":"<p>The <code>download_spec</code> mode isn't used for testing, but rather for tool installation. It provides an interface to download, parse, and store the instruction specifications for the tested ISA in the JSON format.</p>"},{"location":"user/templates/","title":"Template-Based Mode in Revizor","text":"<p>Template-based mode (<code>tfuzz</code>) enables targeted testing of specific CPU scenarios by using predefined assembly templates that get expanded with random instructions. This mode narrows down the fuzzing space to focus on particular interaction patterns while maintaining randomization within those patterns.</p>"},{"location":"user/templates/#overview","title":"Overview","text":"<p>Template-based mode generates test cases from assembly templates containing macros that get dynamically expanded during generation. Templates define the structure and flow of test cases while allowing specific sections to be populated with random instructions based on configuration.</p>"},{"location":"user/templates/#command-line-usage","title":"Command Line Usage","text":"<p>Template-based mode is invoked using the <code>rvzr tfuzz</code> command. The invocation is almost identical to the normal <code>rvzr fuzz</code> mode, but it takes an additional <code>-t</code> or <code>--template</code> parameter to specify the assembly template file.</p> <p>Invocation example:</p> <pre><code>rvzr tfuzz -t template.asm -c config.yaml -s base.json -n 10 -i 100\n</code></pre> <p>where <code>template.asm</code> is the template file.</p>"},{"location":"user/templates/#template-structure","title":"Template Structure","text":"<p>Templates are assembly files that combine:</p> <ul> <li>Regular assembly instructions</li> <li>Macros (special pseudo-instructions as described in Macros)</li> </ul> <p>Example template:</p> <pre><code>.intel_syntax noprefix\n.section .data.main\n\n.macro.random_instructions.10.0:  ; Replaced with 10 random instructions\ndiv rax, rbx                      ; rax and rbx may be set by random instructions\njmp .test_case_exit               ; Jump to exit point if no exception occurs\n\n.fault_handler:\n    .macro.random_instructions.10.1:  ; Generate 10 random instructions executed when a fault occurs\n\n.test_case_exit:\n</code></pre> <p>Revizor will take this template and replace the <code>.macro.random_instructions.N</code> with N random instructions from the instruction pool defined in the configuration file. A new test case will be generated this way in each fuzzing round, allowing for a wide variety of test cases while still adhering to the structure defined in the template. For example, if <code>-n 10</code> is specified, the generator will produce 10 test cases based on the template, each with different random instruction sequences.</p>"}]}