{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Revizor","text":"<p>Welcome to Revizor.</p>"},{"location":"contracts/","title":"Primer: Speculation Contracts and Model-Based Relational Testing","text":"<p>Author: Oleksii Oleksenko | Last Updated: 2025-04-02</p> <p>Below is a brief primer on the theoretical foundations of speculation contracts and model-based relational testing\u2014concepts that underlie the Revizor tool. This primer provides a high-level overview of the topic, introducing the concepts of noninterference, speculation contracts, and model compliance.</p> <p>This document is intended for those new to the topic, particularly people without a background in information-flow analysis. For a more detailed and technical explanation, refer to the original contracts paper.</p>"},{"location":"contracts/#information-flow-properties","title":"Information-Flow Properties","text":"<p>We will start with the basics: the concepts of confidentiality and noninterference, which are fundamental to understanding how speculation contracts work.</p> <p>Traditionally, security mechanisms like access control and encryption have focused on protecting data at rest or in transit. However, these mechanisms do not address the problem of information flow within a system. For example, consider a program that reads a secret input and then writes it to a public output, such as a web server that logs failed login attempts along with the username and masked password entered. Even if the program is secure in the sense that it does not allow unauthorized access to the secret data, it may still leak the secret through its public output, such as logging \"User admin failed login with password starting with 'P@ss'\" \u2014 revealing partial information about the secret password. This is where information-flow security comes into play.</p> <p>Information-flow security is concerned with how data moves through a computation and how it can be observed by an attacker. The goal is to ensure that secret information does not leak to observers who are unauthorized to access it. An end-to-end confidentiality policy might be stated as: \u201cNo secret input data can be inferred by an attacker through observations of system output.\u201d In other words, even if an adversary can see all public outputs of a computation, they should learn nothing about the secret inputs.</p> <p>Information-flow properties generally classify program variables or inputs/outputs into security levels (e.g., <code>Secret</code> and <code>Public</code>). The key property for confidentiality is that no information flows from Secret to Public. But how can information flow? There are two primary routes:</p> <ul> <li> <p>Explicit flows: These occur when confidential data is directly assigned or passed into a public variable or output. For example, in code, writing <code>public = secret</code> is an explicit flow from a secret variable to a public variable (an obvious violation of confidentiality). Any mechanism that directly transfers the bits of a secret into a publicly observable sink is an explicit flow. Such flows are usually straightforward to detect.</p> </li> <li> <p>Implicit flows: These occur indirectly, through the control structure of the program. An implicit flow arises when the control path taken by a program (e.g., which branch of an <code>if</code> or how many loop iterations) depends on a secret, thereby implicitly leaking information.</p> </li> </ul> <p>Example 1 (Implicit Flow)</p> <p>Consider this pseudocode example:</p> <pre><code>if (Sec == 0) {\n    Pub = 0;\n} else {\n    Pub = 1;\n}\n</code></pre> <p>Here <code>Sec</code> is a secret input and <code>Pub</code> is a public output. There is no direct assignment of <code>Sec</code> to <code>Pub</code>. However, an observer of <code>Pub</code> can deduce information about <code>Sec</code>. In fact, this program sets <code>Pub</code> to 0 if <code>Sec</code> was 0; otherwise, it sets <code>Pub</code> to 1\u2014effectively copying the one-bit information \u201cis Sec zero?\u201d into <code>Pub</code>. This is an implicit flow of information from <code>Sec</code> to <code>Pub</code> through the control structure (the <code>if</code> condition on <code>Sec</code>).</p>"},{"location":"contracts/#noninterference-definition-and-examples","title":"Noninterference: Definition and Examples","text":"<p>Noninterference is a formal property that captures the idea of perfect confidentiality: changes in secret data have no observable effect on public outputs. This property can be formalized as: \"a system is noninterferent if variations in Secret inputs cause no differences in Public outputs\". Equivalently, confidential inputs do not interfere with the publicly visible state of the system.</p> <p>To make this more concrete, imagine we run a program twice with two different secret inputs but the same public inputs. If no attacker can distinguish the two runs by observing anything public, then the program satisfies the noninterference property. The \u201cattacker\u201d here is assumed to have complete access to all public outputs, which are formalized as a function <code>PublicOut</code>:</p> <pre><code>output = PublicOut(Sec, Pub)\n</code></pre> <p>Noninterference essentially demands that for any two secrets <code>Sec1</code> and <code>Sec2</code> and any public input <code>Pub</code>, the program\u2019s behavior from an attacker\u2019s perspective is identical when run on <code>(Sec1, Pub)</code> versus <code>(Sec2, Pub)</code>:</p> <p> Definition 1 (Noninterference): A program <code>P</code> is noninterferent if, for all public inputs <code>Pub</code> and all secret inputs <code>Sec1</code>, <code>Sec2</code>, if <code>Sec1 = Sec2</code>, then <code>PublicOut(P, Sec1, Pub) = PublicOut(P, Sec2, Pub)</code>. </p> <p>Here are some examples to illustrate this principle:</p> <p>Example 2 (Interfering program)</p> <p>Suppose our program simply copies a secret to output:</p> <pre><code>void copy(int* sec, int* output) {\n    *output = *sec;\n}\n</code></pre> <p>Running it with two different secrets clearly yields different public outputs (e.g., <code>output</code> becomes 5 in one run and 7 in another). An attacker would distinguish these runs, so the program is not noninterferent\u2014it blatantly leaks information.</p> <p>Example 3 (Noninterfering program)</p> <p>A trivial example of a noninterferent program is one that produces no output dependent on the secret. For instance:</p> <pre><code>void assign_zero(int* sec, int* output) {\n    *output = 0;\n}\n</code></pre> <p>This program ignores secret <code>sec</code> entirely and always sets the public output <code>output</code> to 0. No matter what the secret input is, the public output is constant (0), so an attacker gains no information about <code>sec</code>. Indeed, any two runs are indistinguishable (both runs output 0). This satisfies noninterference (albeit by doing nothing useful with the secret).</p> <p>Example 4 (Allowed benign dependency)</p> <p>It is possible for a program to use secret data internally yet still be noninterferent as long as the final public outputs don\u2019t reveal those secrets. For instance:</p> <pre><code>void mask_secret(int* sec, int* output) {\n    int temp = *sec;\n    temp = temp * 0;   // multiply secret by 0\n    *output  = temp;\n}\n</code></pre> <p>Here the program did read the secret (<code>sec</code>) and even manipulated it, but it \u201cwashed out\u201d the secret by multiplying by 0. The value assigned to <code>output</code> is always 0. From an external view, this is just like the previous example\u2014no dependence of <code>output</code> on <code>sec</code>. Noninterference is concerned only with what can be observed by the attacker, not with whether the program internally used the secret. As long as any use of the secret eventually has no effect on outputs, the policy holds.</p> <p>Naturally, this example is not useful either, as it does nothing with the secret. In practice, however, there are techniques to ensure noninterference while still making use of secret data for useful computations. We won't go into these techniques here as they are beyond the scope of this primer.</p> <p>One important insight is that noninterference is relative to a given specification of what is \u201cobservable.\u201d If you consider only the functional outputs as observable, a program might be noninterferent in that model. But if in reality the attacker can observe more (e.g., the execution time of a program), then the program that was secure in theory might be insecure in practice. This leads us to examine how side channels break the assumptions of basic noninterference.</p>"},{"location":"contracts/#beyond-direct-outputs-side-channels","title":"Beyond Direct Outputs: Side Channels","text":"<p>The original works on information-flow properties focused on direct outputs of a program (e.g., writing to a file or a network socket). However, in practice, attackers can extract information from more than just the \u201cofficial\u201d outputs of a program. For example, the attacker might observe how long a computation takes or measure the power consumption of a device. These additional sources of information are called side channels. Side channels are unintended channels through which secret data can be inferred by observing the system\u2019s behavior, even if the direct outputs are secure.</p> <p>These side channels can reveal information about the secret inputs, and so we must include them in the definition of noninterference. Similarly to how we defined <code>PublicOut(Sec, Pub)</code> as the observable output, we can define <code>Trace</code> as the observable side-channel information for a given program <code>P</code>.</p> <pre><code>trace = Trace(P, Sec, Pub)\n</code></pre> <p>For example, a trace might be the execution time of the program or its cache access pattern.</p> <p>Noninterference then requires that the traces of two runs with different secrets - <code>(Sec1, Pub)</code> versus <code>(Sec2, Pub)</code> - are indistinguishable to an attacker. This is a stronger requirement than just looking at the functional outputs.</p> <p> Definition 2 (Side-Channel Noninterference): Given a side channel that produces a trace <code>Trace</code>, a program <code>P</code> is noninterferent with respect to this side channel if, for all public inputs\u00a0<code>Pub</code> and all secret inputs <code>Sec1</code>, <code>Sec2</code>, if <code>Sec1 = Sec2</code>,then <code>Trace(P, Sec1, Pub) = Trace(P, Sec2, Pub)</code>. </p> <p>Here are some examples of side channels and how they can violate noninterference:</p> <p>Example 5 (Timing side channel)</p> <p>Consider a program that reads a compares a password with a user\u2019s input:</p> <pre><code>bool check_password(const char *attempt, const char *pswd) {\n    for (int i = 0; i &lt; length(pswd); i++) {\n        if (attempt[i] != pswd[i]) {\n            return false;  // mismatch found, return early\n        }\n    }\n    return true; // all characters matched\n}\n</code></pre> <p>If the attacker can measure how long the function takes to reject a guess, they can infer the password one character at a time. This leakage surfaces as a violation of the noninterference property with respect to timing observations.</p> <p>A counterexample to Definition 2 could be as follows: Let's say we have two inputs with the same secret value but different public values:</p> <ul> <li><code>input1={attempt=\"abc\", pswd=\"aaa\"}</code></li> <li><code>input2={attempt=\"aab\", pswd=\"aaa\"}</code></li> </ul> <p>The traces of these inputs will be:</p> <ul> <li><code>trace1 = Trace(check_password, input1) = 1</code></li> <li><code>trace2 = Trace(check_password, input2) = 2</code></li> </ul> <p>These inputs constitute a violation of Definition 2, as <code>trace1 != trace2</code> even though the two inputs have the same secret value.</p> <p>Example 6 (Cache side channel)</p> <p>Consider a program that uses a secret value to index into an array, as in the following code:</p> <pre><code>int multiply(const char *array, int pub, int sec) {\n    char x = array[sec];\n    return x * pub;\n}\n</code></pre> <p>A co-located attacker could observe the cache access pattern of the program by using Prime+Probe or Flush+Reload attack. Such traces can reveal the addresses accessed by the program and thus leak the secret value. This leakage would violate the noninterference property with respect to cache observations.</p> <p>A violation could be surfaced by two inputs:</p> <ul> <li><code>input1={array=0x10000, pub=1, sec=0x40}</code></li> <li><code>input2={array=0x10000, pub=1, sec=0x80}</code></li> </ul> <p>Let's assume that the cache line size is 64 bytes, and the cache is direct-mapped, meaning that the cache line ID is based on the memory access address <code>addr</code> as <code>line_id = (addr % 0x1000) // 0x40</code>. Since the array access in the first line of <code>multiply</code> will access two different addresses for the two inputs, they will also produce two different traces:</p> <ul> <li><code>trace1 = Trace(multiply, input1) = ((0x10000 + 0x40) % 0x1000) // 0x40 = 1</code></li> <li><code>trace2 = Trace(multiply, input2) = ((0x10000 + 0x80) % 0x1000) // 0x40 = 2</code></li> </ul> <p>Since we have two inputs that match on the secret value <code>sec</code> but differ on the cache trace, this constitutes a violation of Definition 2.</p>"},{"location":"contracts/#challenges-of-side-channel-noninterference","title":"Challenges of Side-Channel Noninterference","text":"<p>Despite its completeness, the above formalization of side-channel noninterference is too simplistic to faithfully capture the side effects of program execution on modern, highly optimized hardware, especially CPUs. There are two key challenges:</p> <ul> <li> <p>Challenge 1 - Noisy and Non-Deterministic Traces: The traces observed by the attacker over a side channel are typically noisy, non-deterministic, and depend on the microarchitectural state of the CPU. For example, cache access patterns can be influenced by other programs running on the machine, the operating system and its interrupts, and can depend on microarchitectural buffers like store buffers or branch history tables. This means that the <code>Trace</code> function is not a simple deterministic function of the program inputs, but a complex function of many factors, some of which affect the result concurrently and in a non-deterministic fashion.</p> </li> <li> <p>Challenge 2 - Unknown Side Channels: Modern CPUs have a plethora of side channels, including cache timing, branch prediction, and many others. To ensure complete confidentiality, we need to check that the program does not leak information over any of them. This is a challenging task, as we do not know the full set of possible side channels when it comes to commercial hardware with proprietary microarchitectures. For example, a CPU might have an obscure microarchitectural optimization that vastly expands possibilities for information leaks, as was the case with Spectre and Meltdown vulnerabilities. Not including this optimization will undermine the noninterference analysis. Therefore, to test for noninterference comprehensively, we need a way to discover and reason about all possible side channels that could leak information.</p> </li> </ul> <p>The next two sections discuss how speculation contracts address these challenges.</p>"},{"location":"contracts/#speculation-contracts-dealing-with-the-complexity-of-modern-hardware","title":"Speculation Contracts: Dealing with the Complexity of Modern Hardware","text":"<p>As a solution to the first challenge, Guarnieri et al. (2021) introduced the concept of speculation contracts. A speculation contract is a simplified and deterministic model of the hardware, designed to capture the information that a given program could leak over side channels when executed with the given inputs. The key term here is \"could\"\u2014the contract is not meant to exactly predict the side-channel traces, but instead, it errs on the side of caution, overestimating the possible leaks to achieve deterministic and noise-free traces.</p> <p>A speculation contract works by defining two key aspects for every instruction in the CPU's ISA:</p> <ol> <li> <p>Observation Clause: For each instruction that may have an observable side effect, the contract declares an observation clause. It describes the data exposed by the instruction.</p> </li> <li> <p>Execution Clause: For each instruction whose semantics may be affected by hardware optimizations (e.g., speculative execution), the contract declares an execution clause. It describes the effect of such optimizations, but without specifying the exact mechanism of the optimization.</p> </li> </ol> <p>At a high level, a contract implements a function <code>ContractTrace</code> that maps a program <code>P</code> and its inputs <code>Sec, Pub</code> to a contract trace <code>ctrace</code>. It is essentially a conservative approximation of the <code>Trace</code> function.</p> <pre><code>ctrace = ContractTrace(P, Sec, Pub)\n</code></pre> <p>The contract trace is a sequence of all data that is exposed when a program is executed according to a contract. It captures the side-channel observations that could be visible if the CPU followed the speculation contract\u2019s rules for a given program execution.</p> <p>Accordingly, the noninterference property is redefined in terms of the contract trace:</p> <p> Definition 3 (Contract Noninterference): Given a contract that produces a contract trace\u00a0<code>ContractTrace</code>, a program <code>P</code> is noninterferent with respect to this contract if,for all public inputs\u00a0<code>Pub</code> and all secret inputs <code>Sec1</code>, <code>Sec2</code>, if <code>Sec1 = Sec2</code>,then <code>ContractTrace(P, Sec1, Pub) = ContractTrace(P, Sec2, Pub)</code>. </p> <p>The following examples illustrate how a contract can be used to model side-channel leaks on a CPU.</p> <p>Example 7: Memory Observation Contract, MEM-SEQ</p> <p>Let's imagine a CPU with a shared data cache and no other optimizations (i.e., no speculation). A co-located attacker can recover the addresses of loads/stores by observing which of the cache sets changed their state via a cache timing side-channel attack (e.g., Prime+Probe). We can encode these expectations in an observation clause for loads and stores by specifying that they expose their address. Since the CPU does not speculate, the execution clause for all instructions is empty. We call this contract MEM-SEQ (memory leakage with sequential execution), and it can be summarized as a table:</p> Observation Clause Execution Clause Load Expose Address - Store Expose Address - Other - - <p>Note that MEM-SEQ intentionally overestimates the leaks by assuming that the attacker observes complete addresses loads/stores (in contrast to a subset of bits that are actually leaked in practice) and that all loads/stores are observable (in reality, they might be masked by noise or other factors). This overestimation is intentional to ensure that the contract is conservative and captures all possible corner cases.</p> <p>Let's now consider how we can produce a contract trace using MEM-SEQ. We will use a slightly modified version of the <code>multiply</code> function from Example 6:</p> <pre><code>int multiply(const char *array, int pub, int sec) {\n    char x = array[sec];   // MEM-SEQ exposes: &amp;array[sec]\n    char y = array[pub];   // MEM-SEQ exposes: &amp;array[pub]\n    return x * y;\n}\n</code></pre> <p>The inputs are:</p> <ul> <li><code>input1 = {array=0x10000, pub=1, sec=2}</code></li> <li><code>input2 = {array=0x10000, pub=1, sec=3}</code></li> </ul> <p>The model collects a trace by executing the program line-by-line according to the rules in the table above (in practice, this is usually done using a modified CPU emulator). The first line has a load from memory, so the model records the address <code>&amp;array[sec]</code> as exposed. The second line has another load, so the model records the address <code>&amp;array[pub]</code> as exposed. The contract traces for this program would be:</p> <ul> <li><code>ctrace1 = ContractTrace(multiply, input1) = [0x10002, 0x10001]</code></li> <li><code>ctrace2 = ContractTrace(multiply, input2) = [0x10003, 0x10001]</code></li> </ul> <p>Finally, this model can be used to check for noninterference by comparing contract traces according to Definition 3. In this case, we have two inputs with matching public values and different secrets, and they produced different contract traces, <code>ctrace1 != ctrace2</code>. This constitutes a violation and means that the <code>multiply</code> function is not noninterferent with respect to MEM-SEQ.</p> <p>Example 8: Branch Prediction Contract, MEM-COND</p> <p>Now let's consider a more complex scenario, with a CPU that implements branch prediction\u2014a common form of speculative execution. In this case, the CPU may incorrectly predict branch targets and execute instructions that are not part of the correct control flow. We can model this behavior in a contract by introducing an execution clause for conditional jumps that specifies the mispredicted target. To make the example useful, we will assume that the CPU also has a data cache, so the observation clause for loads and stores remains the same as in MEM-SEQ. We call this contract MEM-COND (memory leakage with conditional branch misprediction).</p> Observation Clause Execution Clause Load Expose Address - Store Expose Address - Cond. Jump - Mispredict Target Other - - <p>As a target program we will use the following function:</p> <pre><code>int conditional_multiply(char *array, int pub, int sec) {\n    int z = array[pub];   // MEM-COND exposes: &amp;array[pub]\n    if (z &lt; 10) {         // MEM-COND mispredicts (assume z = 10)\n        z *= array[sec];  // MEM-COND exposes: &amp;array[sec]\n    }\n    return z;\n}\n</code></pre> <p>and a pair of inputs with the same public value but different secrets:</p> <ul> <li><code>input1 = {array=0x10000, pub=1, secret=2}</code></li> <li><code>input2 = {array=0x10000, pub=1, secret=3}</code></li> </ul> <p>The first line of <code>conditional_multiply</code> has a load, so it exposes its address, <code>&amp;array[pub]</code>. For the sake of this example, let's assume this load returns <code>10</code>, so the next branch is not supposed to be taken. However, according to MEM-COND, branches take the wrong target, so the model executes the third line anyway. This line is a load, so it exposes the address <code>&amp;array[sec]</code>. After this, the program terminates, and the resulting traces are:</p> <ul> <li><code>ctrace1 = ContractTrace(conditional_multiply, input1) = [0x10002, 0x10001]</code></li> <li><code>ctrace2 = ContractTrace(conditional_multiply, input2) = [0x10003, 0x10001]</code></li> </ul> <p>Again, the traces are different, so the program violates noninterference with respect to MEM-COND. Notably, however, these two inputs would not violate noninterference with respect to MEM-SEQ, as the branch at line 2 would not be mispredicted, and the traces would be identical:</p> <p><code>ctrace_mem_seq1 = ctrace_mem_seq2 = [0x10001]</code></p>"},{"location":"contracts/#building-and-testing-speculation-contracts","title":"Building and Testing Speculation Contracts","text":"<p>Speculation contracts are typically built by hand, with the initial versions based on public knowledge of the CPU's microarchitecture and its side-channel vulnerabilities. However, in the case of commercial CPUs, the exact details of the microarchitecture are often proprietary and not publicly disclosed. In these cases, the contract could\u2014and often will\u2014be incomplete. This is where the testing of speculation contracts becomes crucial: the initial \"draft\" of a contract is tested against the real hardware to ensure that it captures all side-channel leaks that the CPU exhibits. If the contract misses something, it is refined based on the results of the testing, and the process is repeated until the contract is deemed safe to use.</p> <p>But how do we test a speculation contract? A naive approach might be to directly compare the traces produced by the model with the traces collected from the real CPU for the same program and inputs. However, this approach is generally not feasible because the contract traces intentionally overestimate the hardware traces, so mismatches are expected. Moreover, the model might expose information differently than the real hardware (e.g., the model might expose load/store addresses, while the hardware exposes cache set indexes), meaning direct comparison is often impossible.</p> <p>Instead, a more precise approach is to compare the information contained in the traces. The idea is to check that the information exposed by the model is a strict superset of the information exposed by the real hardware. This is done by verifying that all inputs producing identical contract traces for a given program also produce identical hardware traces. If this property holds for all possible programs and inputs (ignore the complexity question for now), then any program that would be noninterferent with respect to the real hardware is guaranteed to be noninterferent with respect to the speculation contract. At this point, the model is safe to use as a proxy for real hardware when analyzing side-channel leaks.</p> <p>To formalize this idea, let's introduce a new function <code>HardwareTrace</code> to denote the trace collected from the real hardware, and it will take an extra argument <code>Ctx</code> to capture the fact that real-world hardware traces depend on the microarchitectural state (e.g., on the state of branch predictors or caches).</p> <p> Definition 4: Contract Compliance. A CPU complies with a speculation contract if, for all programs <code>P</code>, all input pairs <code>(Sec1, Pub), (Sec2, Pub)</code>, and all initial microarchitectural states\u00a0<code>Ctx</code>, if <code>ContractTrace(P, Sec1, Pub) = ContractTrace(P, Sec2, Pub)</code>, then <code>HardwareTrace(P, Sec1, Pub, Ctx) = HardwareTrace(P, Sec2, Pub, Ctx)</code>. </p> <p>and conversely</p> <p> Definition 5: Contract Violation. A CPU violates a speculation contract if there exists a program\u00a0<code>P</code>, a microarchitectural state\u00a0<code>Ctx</code>, and two inputs <code>(Sec1, Pub), (Sec2, Pub)</code> such that <code>ContractTrace(P, Sec1, Pub) = ContractTrace(P, Sec2, Pub)</code> and <code>HardwareTrace(P, Sec1, Pub, Ctx) != HardwareTrace(P, Sec2, Pub, Ctx)</code>. </p> <p>We call the tuple <code>(P, Ctx, Sec1, Sec2)</code> a contract counterexample. The counterexample demonstrates that an adversary can learn more information from hardware traces than what the contract specifies. A counterexample indicates a potential microarchitectural leakage that was not accounted for by the contract. The goal of Revizor is to find such counterexamples.</p>"},{"location":"contracts/#model-based-relational-testing-and-revizor","title":"Model-Based Relational Testing and Revizor","text":"<p>Revizor applies the principles above, and provides a framework for building executable speculation contracts together with a mechanism to test real hardware (currently only CPUs) against these contracts by searching for contract counterexamples, as in Definition 5. However, there are certain issues that appear when the theory from the previous section is applied in practice, which we had to address in Revizor.</p> <p>The first issue is the search space: testing all possible programs and inputs is literally impossible. We mitigate this issue by relying on a sampling-based approach, similar to fuzzing, where we approximate the complete search space via random sampling. Specifically, Revizor generates small (50-100 instructions long) programs, creates random inputs for them, collects both the contract and hardware traces for these inputs, and checks whether any of the traces constitute a contract counterexample. This process is called Model-based Relational Testing, and it is detailed further in the Architecture Overview.</p> <p>This approach works well in practice because any given hardware optimization can typically be triggered by many different programs, and we need to find only one instance to detect a violation. Evidence of this is the list of trophies that Revizor has already amassed.</p> <p>The second issue we encountered is nondeterminism. As mentioned earlier, hardware traces can be non-deterministic due to various factors like interrupts or other programs running on the machine. To handle this, we use statistical methods: Revizor collects hardware traces for each program-input pair multiple times and then compares their distributions. If the distributions of the traces are statistically similar, Revizor considers the traces to be equivalent. This approach helps us account for noise in the hardware traces while still making reliable decisions about contract compliance.</p>"},{"location":"contracts/#conclusion","title":"Conclusion","text":"<p>In this primer, we have introduced the concepts of noninterference, side channels, and speculation contracts, which all underlie the design of Revizor:</p> <ul> <li>The hardware fuzzer in Revizor uses speculation contracts and the concepts of noninterference (1) to detect unexpected side channels and dangerous microarchitectural optimizations in commercial CPUs, and (2) to aid in building sound leakage models for those CPUs.</li> <li>The software fuzzer in Revizor (NOTE: currently under construction) uses the leakage models produced by the hardware fuzzer, and applies the principles of noninterference testing to detect side-channel vulnerabilities in real-world software.</li> </ul> <p>With these two components, we aim to provide a comprehensive tool for discovering and mitigating side-channel vulnerabilities software that can handle even the most obscure and complex microarchitectural optimizations in modern hardware.</p>"},{"location":"contracts/#sources-and-further-reading","title":"Sources and Further Reading","text":"<ul> <li>A. Sabelfeld and A. C. Myers. Language-Based Information-Flow Security. IEEE Journal on Selected Areas in Communications, 21(1), 2003. (Survey of information-flow security, implicit/explicit flows, covert channels, etc.)</li> <li>J. A. Goguen and J. Meseguer. Security Policies and Security Models. IEEE Symposium on Security and Privacy, 1982. (Origin of noninterference as a security policy formalism.)</li> <li>J. B. Almeida et al. Verifying Constant-Time Implementations. USENIX Security Symposium, 2016. (Constant-time programming principles and the ct-verif tool for automated verification.)</li> <li>M. Guarnieri, B. K\u00f6pf, J. Reineke, P. Vila. Hardware-Software Contracts for Secure Speculation. IEEE Symposium on Security and Privacy, 2021. (Original paper on speculation contracts.)</li> <li>O. Oleksenko, C. Fetzer, B. K\u00f6pf, M. Silberstein. Revizor: Testing Black-box CPUs against Speculation Contracts. ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), 2022. (Paper describing Model-based Relational Testing and Revizor.)</li> </ul>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#installation","title":"Installation","text":"<p>Warning: Revizor runs randomly-generated code in kernel space. This means that a misconfiguration (or a bug) can crash the system and potentially lead to data loss. Make sure you're not running Revizor on a production machine, and that you have a backup of your data.</p>"},{"location":"quick-start/#1-requirements","title":"1. Requirements","text":"<ul> <li> <p>Architecture: Revizor supports Intel and AMD x86-64 CPUs. We have experimental support for ARM CPUs (see <code>arm-port</code> branch) but it is at very early stages, so use it on your own peril.</p> </li> <li> <p>No virtualization: You will need a bare-metal OS installation. Testing from inside a VM is not supported.</p> </li> <li> <p>OS: The target machine has to be running Linux v4.15 or later.</p> </li> </ul>"},{"location":"quick-start/#2-python-package","title":"2. Python Package","text":"<p>The preferred installation method is using <code>pip</code> within a virtual environment. The python version must be 3.9 or later.</p> <pre><code>sudo apt install python3.9 python3.9-venv\n/usr/bin/python3.9 -m pip install virtualenv\n/usr/bin/python3.9 -m virtualenv ~/venv-revizor\nsource ~/venv-revizor/bin/activate\npip install revizor-fuzzer\n</code></pre>"},{"location":"quick-start/#3-executor","title":"3. Executor","text":"<p>In addition to the Python package, you will need to build and install the executor, which is a kernel module.</p> <pre><code># building a kernel module require kernel headers\nsudo apt-get install linux-headers-$(uname -r) linux-headers-generic\n\n# get the source code\ngit clone https://github.com/microsoft/sca-fuzzer.git\n\n# build executor\ncd sca-fuzzer/src/x86/executor\nmake uninstall  # the command will give an error message, but it's ok!\nmake clean\nmake\nmake install\n</code></pre>"},{"location":"quick-start/#4-optional-dynamorio-backend","title":"4. (Optional) DynamoRIO Backend","text":"<p>If you want to use the DynamoRIO-based model, it has to be installed separately:</p> <pre><code># install dependencies\nsudo apt-get install cmake g++ g++-multilib doxygen git zlib1g-dev libunwind-dev libsnappy-dev liblz4-dev\n\n# install DynamoRIO and the model\nmake -C src/model_dynamorio\n\n# check installation\n~/.local/dynamorio/drrun -c ~/.local/dynamorio/libdr_model.so --list-obs-clauses -- ls\n# expected output:\n#   ct\n#   ...\n#   /dev/null\n</code></pre>"},{"location":"quick-start/#5-download-isa-spec","title":"5. Download ISA spec","text":"<pre><code>rvzr download_spec -a x86-64 --extensions ALL_SUPPORTED --outfile base.json\n\n# Alternatively, use the following command to include system instructions;\n# however, mind that testing these instructions may crash the system if misconfigured!\n# rvzr download_spec -a x86-64 --extensions ALL_AND_UNSAFE --outfile base.json\n</code></pre>"},{"location":"quick-start/#6-test-the-installation","title":"6. Test the Installation","text":"<p>To make sure that the installation was successful, run the following command:</p> <pre><code>./tests/quick-test.sh\n\n# The expected output is:\nDetection: OK\nFiltering: OK\n</code></pre> <p>If you see any other output, check if the previous steps were executed correctly. If you still have issues, please open an issue.</p>"},{"location":"quick-start/#7-optional-system-configuration","title":"7. (Optional) System Configuration","text":"<p>External processes can interfere with Revizor's measurements. To minimize this interference, we recommend the following system configuration:</p> <ul> <li>Disable Hyperthreading (BIOS option);</li> <li>Disable Turbo Boost (BIOS option);</li> <li>Boot the kernel on a single core (add <code>-maxcpus=1</code> to Linux boot parameters).</li> </ul> <p>If you skip these steps, Revizor may produce false positives, especially if you use a low value for <code>executor_sample_sizes</code> for measurements. However, a large sample size (&gt; 300-400) usually mitigates this issue.</p>"},{"location":"quick-start/#quick-start","title":"Quick Start","text":"<p>The following is an example of a simple fuzzing session with Revizor that will detect Spectre V1-like violations.</p> <p>Create a configuration file <code>config.yaml</code> with the following content: <pre><code># config.yaml\ninstruction_categories:\n  - BASE-BINARY  # arithmetic instructions\n  - BASE-COND_BR  # conditional branches\nmax_bb_per_function: 5  # up to 5 branches per test case\nmin_bb_per_function: 1\nmax_successors_per_bb: 2  # enable basic blocks with conditional branches\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n  - no_speculation  # aka SEQ\n</code></pre></p> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 1000 -c config.yaml -w .\n</code></pre></p> <p>You will likely see a violation within a few minutes, as most modern CPUs implement branch prediction, which is a prerequisite for Spectre-like attacks, and so the contract <code>CT-SEQ</code> is likely to be violated.</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 18422470923634754929 (hash)\nHardware traces:\n  Input group 1: [7]\n  Input group 2: [57]\n  ^..........................................^.............^^..^^. [500    | 0     ]\n  ^....^...................................................^^..^^. [0      | 500   ]\n</code></pre> <p>You can find the violating test case as well as the violation report in the directory named <code>./violation-*/</code>. It will contain an assembly file <code>program.asm</code> that surfaced a violation, a sequence of inputs <code>input_*.bin</code> to this program, and some details about the violation in <code>report.txt</code>.</p>"},{"location":"quick-start/#command-line-interface","title":"Command Line Interface","text":"<p>The fuzzer is controlled via a single command line interface <code>rvzr</code> (or <code>revizor.py</code> if you're running directly from the source tree).</p> <p>It accepts the following arguments:</p> <ul> <li><code>-s, --instruction-set PATH</code> - path to the ISA description file</li> <li><code>-c, --config PATH</code> - path to the fuzzing configuration file</li> <li><code>-n , --num-test-cases N</code> - number of test cases to be tested</li> <li><code>-i , --num-inputs N</code> - number of input classes per test case. The number of actual inputs = input classes * inputs_per_class, which is a configuration option</li> <li><code>-t , --testcase PATH</code> - use an existing test case instead of generating random test cases</li> <li><code>--timeout TIMEOUT</code> - run fuzzing with a time limit [seconds]</li> <li><code>-w</code> - working directory where the detected violations will be stored</li> </ul> <p>For example, this command <pre><code>rvzr fuzz -s base.json -n 100 -i 10  -c config.yaml -w ./violations\n</code></pre> will run the fuzzer for 100 iterations (i.e., 100 test cases), with 10 inputs per test case. The fuzzer will use the ISA spec stored in the <code>base.json</code> file, and will read the configuration from <code>config.yaml</code>. If the fuzzer finds a violation, it will be stored in the <code>./violations</code> directory.</p> <p>See docs for more details.</p>"},{"location":"quick-start/#how-to-fuzz-with-revizor","title":"How To Fuzz With Revizor","text":"<p>The fuzzing process is controlled by a configuration file in the YAML format, passed via <code>--config</code> option. At the very minimum, this file should contain the following fields:</p> <ul> <li><code>contract_observation_clause</code> and <code>contract_execution_clause</code> describe the contract that the CPU-under-test is tested against. See this page for a list of available contracts. If you don't know what a contract is, Sec. 3 of this paper will give you a high-level introduction to contracts, and this paper will provide a deep dive into contracts.</li> <li><code>instruction_categories</code> is a list of instruction types that will be tested. Effectively, Revizor uses this list to filter out instructions from <code>base.json</code> (the file you downloaded via <code>rvzr download_spec</code>).</li> </ul> <p>For a full list of configuration options, see docs.</p>"},{"location":"quick-start/#baseline-experiment","title":"Baseline Experiment","text":"<p>After a fresh installation, it is normally a good idea to do a quick test run to check that everything works ok.</p> <p>For example, we can create a configuration file <code>config.yaml</code> with only simple arithmetic instructions. As this instruction set does not include any instructions that would trigger speculation on Intel or AMD CPUs (at least that we know of), the expected contract would be <code>CT-SEQ</code>:</p> <pre><code># config.yaml\ninstruction_categories:\n  - BASE-BINARY  # arithmetic instructions\nmax_bb_per_function: 1  # no branches!\nmin_bb_per_function: 1\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n  - no_speculation  # aka SEQ\n</code></pre> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 100 -c config.yaml  -w .\n</code></pre></p> <p>This command should terminate with no violations.</p>"},{"location":"quick-start/#full-scale-fuzzing-campaign","title":"Full-Scale Fuzzing Campaign","text":"<p>To start a full-scale test, write your own configuration file (see description here and an example config here), and launch the fuzzer.</p> <p>Below is a example launch command, which will start a 24-hour fuzzing session, with 100 input classes per test case, and which uses big-fuzz.yaml configuration: <pre><code>rvzr fuzz -s base.json -c demo/big-fuzz.yaml -i 100 -n 100000000 --timeout 86400 -w `pwd` --nonstop\n</code></pre></p> <p>If there is a violation, you can try to reproduce it with the following command:</p> <pre><code>rvzr reproduce -s base.json -c violation-&lt;timestamp&gt;/reproduce.yaml -t violation-&lt;timestamp&gt;/program.asm -i violation-&lt;timestamp&gt;/input_*.bin\n</code></pre> <p>If the violation is reproducible, it is useful to minimize it, so that it is easier to understand the root cause (note that minimization uses a different config file):</p> <pre><code>rvzr minimize -s base.json -c violation-&lt;timestamp&gt;/minimize.yaml -g violation-&lt;timestamp&gt;/program.asm -o violation-&lt;timestamp&gt;/minimized.asm -i 100 --num-attempts 10 --enable-simplification-pass\n</code></pre> <p>The result of minimization will be stored in <code>violation-&lt;timestamp&gt;/minimized.asm</code>. If the result is still too complicated, try other minimization passes.</p> <p>The further analysis is manual; you can find an example in this guide.</p>"},{"location":"quick-start/#need-help-with-revizor","title":"Need Help with Revizor?","text":"<p>If you find a bug in Revizor, don't hesitate to open an issue.</p> <p>If something is confusing or you need help in using Revizor, we have a discussion page.</p>"},{"location":"quick-start/#documentation","title":"Documentation","text":"<p>For more details, see the website.</p>"},{"location":"devel/binary-formats/","title":"Binary Formats in Revizor","text":"<p>This document describes the structure of the custom binary formats used by Revizor to transfer test cases and their data between different components. For example, these formats are used to pass generated test cases from the executor (python) class to the executor kernel module.</p> <p>Such custom formats are necessary because the components are implemented in different programming languages and different technologies, so passing objects directly is not possible. Using one of the standard formats (e.g., ELF) is also not an option because test cases in Revizor have special structure (e.g., multiple actors in different execution modes, some instructions are macros, etc.) and this structure is not supported by the standard formats.</p> <p>The formats are designed to as simple as possible to minimize the overhead of serialization and deserialization.</p>"},{"location":"devel/binary-formats/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Binary Formats in Revizor</li> <li>Table of Contents</li> <li>Revizor Code Binary Format (RCBF)</li> <li>Revizor Data Binary Format (RDBF)</li> </ul>"},{"location":"devel/binary-formats/#revizor-code-binary-format-rcbf","title":"Revizor Code Binary Format (RCBF)","text":"<p>RCBF is a structured representation of the complete test case binary, together with its metadata. The structure is as follows:</p> <pre><code>|---------------------------------------|\n| n_actors (8 bytes)                    | HEADER       |\n| n_symbols (8 bytes)                   |\n| ------------------------------------- |\n| actor metadata:                       | ACTOR TABLE  |\n| - id (8 bytes)                        |\n| - mode (8 bytes)                      |\n| - pl (8 bytes)                        |\n| - data_permissions (8 bytes)          |\n| - data_ept_permissions (8 bytes)      |\n| - code_permissions (8 bytes)          |\n| x n_actors                            |\n| ------------------------------------- |\n| symbol entry:                         | SYMBOL TABLE |\n| - owner (8 bytes)                     |\n| - offset (8 bytes)                    |\n| - id (8 bytes)                        |\n| - args (8 bytes)                      |\n| x n_symbols                           |\n| ------------------------------------- |\n| section metadata entry:               | METADATA     |\n| - owner (8 bytes)                     |\n| - size (8 bytes)                      |\n| - reserved (8 bytes)                  |\n| x n_actors                            |\n| ------------------------------------- |\n| code section:                         | DATA         |\n| - code (char *)                       |\n| x n_actors                            |\n| ------------------------------------- |\n</code></pre> <p>The file begins with a header containing the number of actors (it is also the number of sections) and the number of symbols in the test case. The term \"symbol\" in this context refers to any location in the test case that can be referenced. Two common types of symbols are functions (specifically, function entry points) and macros.</p> <p>Next, the file contains the actor table, which is an array of actor metadata entries, one for each actor in the test case. The actor metadata entry contains the actor's ID, execution mode, protection level, data permissions, EPT data permissions, and code permissions.</p> <p>After the actor table, the file contains the symbol table, which is an array of symbol entries, one for each symbol in the test case. The symbol entry contains the ID the section to which the symbol belongs, the offset of the symbol within the section, the symbol's ID, and the number of arguments the symbol takes (if it is a macro).</p> <p>The file continues with the table of metadata for each section in the test case. Each metadata entry contains the ID of the actor that owns the section and the size of the section.</p> <p>Finally, the file contains a sequence of code sections, one for each actor in the test case. These sections contain the actual assembled binary for each of the sections in the test case.</p>"},{"location":"devel/binary-formats/#revizor-data-binary-format-rdbf","title":"Revizor Data Binary Format (RDBF)","text":"<p>RDBF is a structured representation of the data used to initialize sandbox memory and registers before executing the test case.</p> <p>Note that this format combines multiple inputs into a single file. This is done because typically, a single test case program is executed multiple times with different inputs, and so it is more efficient to send a batch of inputs at once.</p> <pre><code>|---------------------------------------|\n| n_actors (8 bytes)                    | HEADER\n| n_inputs (8 bytes)                    |\n| ------------------------------------- |\n| section metadata entry:               | METADATA |\n| - section_size (8 bytes)              |\n| - reserved (8 bytes)                  |\n| x (n_actors * n_inputs)               |\n| ------------------------------------- |\n| input:                                | DATA     |\n| - data section:                       |\n| -- main_area (4096 bytes)             |\n| -- faulty_area (4096 bytes)           |\n| -- reg_init_region (4096 bytes)       |\n| - x n_actors                          |\n| x n_inputs                            |\n| ------------------------------------- |\n</code></pre> <p>The file begins with a section containing the number of actors (equal to the number of sections) and the number of inputs in the batch.</p> <p>Next, the file contains the table of metadata for each data section, which only contains the size of the section.</p> <p>Finally, the file contains a sequence of data sections, one for each actor in the test case and each input in the batch. The data sections are arranged to mirror the data layout in the sandbox memory (see the sandbox memory layout document for more information).</p>"},{"location":"devel/code-generation/","title":"Code Generation Algorithm","text":"<p>UNDER CONSTRUCTION</p> <p>If you are interested in this topic, please contact us by opening an issue on GitHub, and we will prioritize this document.</p>"},{"location":"devel/development/","title":"Development","text":"<p>This page contains various bits of information helpful when developing and expanding Revizor.</p>"},{"location":"devel/development/#tests","title":"Tests","text":"<p>To run automated tests you will need to install a few more dependencies:</p> <ul> <li>Bash Automated Testing System</li> <li>mypy</li> <li>flake8</li> </ul> <p>With the dependencies installed, you can run the tests with:</p> <pre><code>./tests/runtests.sh\n</code></pre> <p>Note that some of the acceptance tests are microarchitecture-dependent. These tests are labeled \"Detection\" (e.g., \"Detection [spectre-type] Spectre V1; load variant\"), and they may fail if the CPU under test does not have a given vulnerability. Generally, if a few of these tests fail, it is not a problem, but if all of them (or a significant portion) fail, it indicates an issue with the fuzzer.</p>"},{"location":"devel/development/#code-style","title":"Code Style","text":"<p>Please follow these coding standards when writing code for inclusion in Revizor.</p> <p>Python:</p> <ul> <li>Unless otherwise specified, follow PEP 8. But remember that PEP 8 is only a guide, so respect the style of the surrounding code as a primary goal.</li> <li>An exception to PEP 8 is our rules on line lengths. Don\u2019t limit lines of code to 79 characters if it means the code looks significantly uglier or is harder to read. We allow up to 100 characters.</li> <li>All files should be formatted using the <code>flake8</code> auto-formatter. Use all default settings except for the line width (<code>--max-line-length 100</code>)</li> <li>The Python and C files use 4 spaces for indentation, and YAML uses 2 spaces.</li> <li>The project repository includes an .editorconfig file. We recommend using a text editor with EditorConfig support to avoid indentation and whitespace issues.</li> <li>Use underscores, not camelCase, for variable, function and method names (i.e. poll.get_unique_voters(), not poll.getUniqueVoters()).</li> <li>Use InitialCaps for class names (or for factory functions that return classes).</li> <li>In docstrings, follow PEP 257.</li> </ul> <p>C:</p> <ul> <li>All files should be formatted using the <code>clang-format</code>. The settings are included into the <code>.clang-format</code> files in the directories with C files. Just run the formatter with: <code>clang-format -i *.c</code></li> </ul> <p>Misc:</p> <ul> <li>Remove import statements that are no longer used when you change code. flake8 will identify these imports for you. If an unused import needs to remain for backwards-compatibility, mark the end of with # NOQA to silence the flake8 warning.</li> <li>Systematically remove all trailing whitespaces from your code as those add unnecessary bytes, add visual clutter to the patches and can also occasionally cause unnecessary merge conflicts. Some IDE\u2019s can be configured to automatically remove them and most VCS tools can be set to highlight them in diff outputs.</li> </ul>"},{"location":"devel/development/#git-messages","title":"Git Messages","text":"<p>We practice the following conventions for commit messages:</p> <pre><code>&lt;scope&gt;: [&lt;type&gt;] &lt;subject&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;scope&gt;</code>: The scope of the change.</li> <li><code>&lt;type&gt;</code>: The type of the change.</li> <li><code>&lt;subject&gt;</code>: A short description of the change.</li> </ul>"},{"location":"devel/development/#scopes","title":"Scopes","text":"<p>The following scopes are typical:</p> Scope Description <code>all</code> Changes that affect the entire project (e.g., major refactoring) <code>root</code> Root directory changes (e.g., readme, git, author list) <code>fuzz</code> Changes to the core fuzzer algorithm. <code>cli</code> Changes to the command-line interface. <code>exec</code> Changes to the executor. <code>model</code> Changes to the model. <code>analyser</code> Changes to the analyser. <code>mini</code> Changes to the postprocessor (i.e., minimizer). <code>code_gen</code> Changes to the program generator <code>data_gen</code> Changes to the input generator <code>tests</code> Changes to the tests <code>isa</code> Changes to the ISA loader or to <code>get_spec</code> files <p>If a commit covers several scopes, use the most relevant one.</p> <p>If a commit targets a specific architecture (e.g., x86), add the architecture to the scope (e.g., <code>fuzz/x86</code>).</p>"},{"location":"devel/development/#types","title":"Types","text":"<p>Use one of the following types:</p> Type Description <code>feat</code> A new feature. <code>fix</code> A bug fix. <code>docs</code> Documentation changes. <code>chore</code> Changes to the build process or auxiliary tools. <code>ft</code> Fault tolerance changes (e.g., adding error handling or recovery mechanisms). <code>refact</code> Refactoring of the codebase. This includes code style change. <code>perf</code> Performance improvements. <code>revert</code> Reverts a previous commit. <p>If possible, try to use only these types. If you need to use a different type, please discuss it with a maintainer.</p>"},{"location":"devel/development/#git-branches","title":"Git Branches","text":"<p>We practice the git workflow, with a few modifications.</p> <p></p> <p>We use the following branches for graduation:</p> <ul> <li><code>main</code>: The latest release. This branch should always be stable, and it is the last branch to receive changes.</li> <li><code>main-fixes</code>: Commits that go in the next maintenance release. This branch is created from the last release branch.</li> <li><code>pre-release</code>: Stable commits that go in the next release.</li> <li><code>dev</code>: The development branch. This branch is the first to receive changes.</li> </ul> <p>Commits should be merged upwards:</p> <ul> <li><code>dev</code> -&gt; <code>pre-release</code> -&gt; <code>main</code></li> <li>In case of hot fixes, <code>main-fixes</code> -&gt; <code>main</code> AND <code>main-fixes</code> -&gt; <code>pre-release</code></li> </ul> <p>For working on unstable code (e.g., progress on features or bug fixes), use either forks or feature branches. Use forks if you are the only one working on the feature, and use a pull request to merge the changes back into the main repository. Use a feature branch if multiple people are working on the feature, in which case name the branch <code>feature-&lt;name&gt;</code> or <code>bugfix-&lt;name&gt;</code>, and make sure to branch from the <code>dev</code> branch.</p> <p>The only exception is the <code>gh-pages</code> branch, which is used for the project's website. This branch is used by automated tools and should never be used for development.</p>"},{"location":"devel/dr-model/","title":"DynamoRIO-based Model Backend","text":"<p>This document describes the DynamoRIO-based model. As any other model, this backend is responsible for collecting contract traces for generated test cases.</p>"},{"location":"devel/dr-model/#design-overview","title":"Design Overview","text":"<p>This backend is composed of several parts:</p> <ul> <li>The Python adapter (<code>src/model_dynamorio/model.py</code>) is responsible for receiving a test case from Revizor, transforming it into a format that can be executed by the backend, triggering the backend to execute the test case, and returning the collected contract traces to Revizor.</li> <li>The Test Case Loader (<code>src/model_dynamorio/adapter.c</code>) is a C program that loads a test case program and a batch of inputs into its memory, and executes the test case program with each input in a sequence.</li> <li>The DynamoRIO components (<code>src/model_dynamorio/backend</code>) are executed together with the test case loader, and they instrument the loader binary to collect contract traces.</li> </ul> <p>These components can be roughly divided into the instrumentation-time components that are responsible for modifying the binary, and execution-time components that implement the model logic (i.e., the contract).</p> <p></p>"},{"location":"devel/dr-model/#python-adapter","title":"Python Adapter","text":"<p>Revizor communicates with the backend through a Python adapter (<code>src/model_dynamorio/model.py:DynamoRIOModel</code>).</p> <p>At the beginning of the fuzzing process, Revizor configures the backend by calling <code>configure_clauses</code> method. This configuration will be later passed down to the backend when the test case is executed.</p> <p>During the fuzzing process, Revizor sends test cases to the backend by calling <code>load_test_case</code> method, and then triggers the backend to execute the test case by calling <code>trace_test_case</code> method. Internally, <code>trace_test_case</code> will call the backend to execute the test case and collect the contract traces. The adapter will then parse the traces and return them back to the caller.</p> <p>The <code>trace_test_case</code> method implements the following algorithm:</p> <ul> <li>Convert test case program and inputs into RCBF and RDBF files, respectively</li> <li>For each input, call the test case loader with the RCBF and RDBF files. Attach the DynamoRIO backend to the call so that the binary instrumentation is performed: <pre><code>~/.local/dynamorio/drrun -c ~/.local/dynamorio/libdr_model.so --tracer &lt;observation-clause&gt; -- ~/.local/dynamorio/adapter &lt;rcbf&gt; &lt;rdbf&gt;\n</code></pre></li> <li>Receive contract traces from the backend and convert them into <code>CTrace</code> objects</li> <li>Return the list of collected <code>CTrace</code> objects to the caller (usually, <code>fuzzer.py</code>)</li> </ul>"},{"location":"devel/dr-model/#test-case-loader","title":"Test Case Loader","text":"<p>Since the test cases produced by Revizor are raw binaries, they cannot be directly executed (e.g., they don't have <code>libc</code> linked). The test case loader (<code>src/model_dynamorio/adapter.c</code>) is a simple C program that fixes this issue by providing a wrapper around the test case binary.</p> <p>The loader implements the following algorithm:</p> <ul> <li>Receive the test case binary and an input from the Python adapter via CLI arguments</li> <li>Load the test case binary and the input into dedicated memory regions</li> <li>Print the addresses of the test case and input memory regions (for trace normalization)</li> <li>Initialize registers based on the input</li> <li>Jump to the test case binary entry point</li> <li>Return</li> </ul>"},{"location":"devel/dr-model/#dynamorio-tool","title":"DynamoRIO Tool","text":"<p>The DynamoRIO tool (<code>src/model_dynamorio/backend</code>) is responsible for instrumenting the test case loader binary and collecting contract traces.</p>"},{"location":"devel/dr-model/#instrumentation-components","title":"Instrumentation Components","text":"<p>The instrumentation components modify the binary of the test case loader by adding a call to the function <code>dispatch_callback</code> before every instruction in the binary (or more specifically, every instruction in the <code>test_case_entry</code> function of the loader).</p> <p>The tool interacts with DynamoRIO through the <code>model.cpp</code> module. This module registers an event for entering the <code>test_case_entry</code>, which triggers the start of instrumentation. The module also registers an event for every instruction in the <code>test_case_entry</code>, and the event in turn calls the <code>Dispatch::instrument_instruction()</code>.</p> <p>The <code>Dispatch</code> class implements the actual instrumentation logic. When the <code>instrument_instruction()</code> method is called, it inserts a clean call to the <code>dispatch_callback</code> function before the instruction. The call receives the PC and opcode of the instruction as arguments. DynamoRIO also automatically saves the complete register state before the call, thus making it available to <code>dispatch_callback</code>.</p>"},{"location":"devel/dr-model/#execution-time-components","title":"Execution-Time Components","text":"<p>The execution-time components are responsible for implementing the contract logic, and are triggered by the <code>dispatch_callback</code> function. At the current state of the backend, the dispatch callback invokes only two classes, Tracer and Speculator, that implement the observation and execution clauses, respectively.</p> <p>Subclasses of <code>TracerABC</code> record contract-relevant information via <code>observe_instruction</code> and <code>observe_mem_access</code> methods. E.g., <code>TracerCT</code> implements <code>CT</code> observation clause by recording the PC of instructions upon <code>observe_instruction</code> and the address of memory accesses upon <code>observe_mem_access</code>.</p> <p>Subclasses of <code>SpeculatorABC</code> implement the contract speculation logic. E.g., <code>SpeculatorCond</code> implements <code>speculate_instruction</code>. When this method is called with a branch instruction, the class takes a checkpoint of the process state, flips the branch condition (i.e., modified <code>FLAGS</code> register), and continues the execution. During the simulated speculation, each call to <code>speculate_instruction</code> counts the number of executed instructions, and when the number reaches the limit (e.g., 256), the class restores the checkpoint and continues the execution from the original state. (Actually, the algorithm is more complex, but this is the general idea.)</p> <p>When the instrumentation ends (according to <code>model.cpp</code>), the tracer's <code>tracing_finalized</code> method is called, and the tracer prints the collected traces to <code>stdout</code> in a compressed binary format. The Python adapter picks up this output, decodes, and returns it to Revizor.</p>"},{"location":"devel/macros/","title":"Macros","text":"<p>UNDER CONSTRUCTION</p> <p>If you are interested in this topic, please contact us by opening an issue on GitHub, and we will prioritize this document.</p>"},{"location":"devel/overview/","title":"Architecture Overview","text":"<p>This document provides an overview of Revizor's architecture and its key components.</p>"},{"location":"devel/overview/#how-revizor-works","title":"How Revizor works","text":"<p>Revizor detects contract violations via a method called Model-based Relational Testing (MRT). This method relies on a leakage model that encodes known microarchitectural vulnerabilities to predict the information leaked when executing some code, which  allows it to distinguish between expected and unexpected  leaks. The approach generates random code that is executed both in the CPU-under-test and in the model. It then measures the microarchitectural state changes caused by the code and compares it to the leakage predicted by the model. If the observed leakage matches the model\u2019s prediction, this indicates that the CPU is behaving as expected, and  the test case is discarded. Otherwise, if the random code exposed unexpected information, this indicates a potential security vulnerability, and the generated code can be used as a starting point for further (manual) analysis of the new leak.</p> <p>Revizor works by executing the following loop for a number of rounds, or until a model violation is detected, as summarized by the diagram:</p> <p></p>"},{"location":"devel/overview/#1-initialization","title":"1. Initialization","text":"<p>The first step (executed only once) is to receive fuzzing configuration from the user. The configuration specifies the target CPU, its ISA specification, the instruction pool to be tested, the side-channel to be tested, and other fuzzing parameters.</p> <p>Details: All interactions with a user are handled by the <code>cli.py</code> module, which parses the command-line arguments. Based on the arguments it creates an <code>InstructionSet</code> object (defined in <code>isa_spec.py</code>) and a <code>Config</code> object (defined in <code>config.py</code>). It also initializes the <code>Fuzzer</code> object (defined in <code>fuzzer.py</code>), which will handle the fuzzing process from now on.</p>"},{"location":"devel/overview/#2-code-generation","title":"2. Code Generation","text":"<p>A testing round starts by generating a test case program. The program is essentially a random sequence of assembly instructions with a semi-random control flow, generated from a predefined instruction pool. The code generator create such a program based on the ISA specification provided by the user.</p> <p>The generator can be configured to constrain the shape of the program\u2019s control-flow graph, control the pool of instructions, and configure the instruction frequencies. It also (optionally) instruments the program to prevent undesired faults, such as division by zero.</p> <p>Details: <code>Fuzzer</code> invokes code generation by calling <code>CodeGenerator::create_test_case</code> (defined in <code>code_generator.py</code>). This method uses the <code>InstructionSet</code> and <code>Config</code> objects as the basis for the generation process. The created test case is returned as a <code>TestCaseProgram</code> object (defined in <code>tc_components/test_case_code.py</code>).</p>"},{"location":"devel/overview/#3-data-generation","title":"3. Data Generation","text":"<p>The next step is to generate a set of program inputs. Each input is a binary blob, used by the model and the executor to initialize the program\u2019s memory and registers before it is executed. The data generator creates random (but seeded) values to populate the binary blob according to a predefined format.</p> <p>Details: Data generator is implemented by the <code>data_generator.py</code> module. The main interface to the generator is the <code>DataGenerator</code> class, with its <code>generate</code> method being the main entry point. The generated data is returned as a list of <code>InputData</code> objects (defined in <code>tc_components/test_case_data.py</code>).</p>"},{"location":"devel/overview/#4-model-execution","title":"4. Model Execution","text":"<p>The model takes the generated program and executes it with each of the generated inputs. The model records the data that we expect to be leaked on the given CPU, and to emulate the expected speculative behavior. For mode details on leakage models, see Speculation Contracts.</p> <p>Details: The model is implemented by the <code>model.py</code> module. The main interface to the model is the <code>Model</code> class, with its <code>load_test_case</code> and <code>trace_test_case</code> methods being the main entry points. <code>load_test_case</code> takes a <code>TestCaseProgram</code> object and loads its binary into the model. <code>trace_test_case</code> takes a list of <code>InputData</code> objects, loads their data into the model's memory one at a time and executes the loaded program with each. The resulting contract traces are returned as a list of <code>CTrace</code> objects (defined in <code>traces.py</code>).</p> <p>Note that Revizor supports multiple modelling backends, which are implemented as subclasses of the <code>Model</code> class. The current backends are based on Unicorn and DynamoRIO.</p>"},{"location":"devel/overview/#5-hardware-execution","title":"5. Hardware Execution","text":"<p>The executor takes a program, executes it on the target CPU with each of the inputs, and collects hardware traces for each execution. The traces are typically (though not strictly necessarily) collected via a side-channel attack, such as Prime+Probe, in which case a trace is a set of cache lines evicted by the program. In addition to collecting traces, the executor also ensures a low-noise and reproducible execution environment, for example, by disabling interrupts and flushing caches before starting a measurement.</p> <p>Details: The executor is implemented by the <code>executor.py</code> module. The main interface to the executor is the <code>Executor</code> class, with its <code>load_test_case</code> and <code>trace_test_case</code> methods being the main entry points. <code>load_test_case</code> takes a <code>TestCaseProgram</code> object and loads its binary into the executor. <code>trace_test_case</code> takes a list of <code>InputData</code> objects, loads their data into the executor's memory one at a time and executes the loaded program with each. The resulting hardware traces are returned as a list of <code>HTrace</code> objects (defined in <code>traces.py</code>).</p> <p>The architecture of Revizor can potentially support many types of executors, but currently, we support only one. It is implemented as a kernel module (<code>x86/executor</code>), to which the <code>Executor</code> class acts as an adapter.</p>"},{"location":"devel/overview/#6-trace-analysis","title":"6. Trace Analysis","text":"<p>The trace analyzer uses the leakage predicted by the model to filter out instances of expected leaks from the set of collected hardware traces, thus leaving only the unexpected leaks. The analyzer performs the filtering by checking the noninterference property w.r.t. the model.</p> <p>The key aspect of this approach is that MRT never directly compares the hardware traces to the model\u2019s prediction; instead, it compares the exposed information. This allows a complex modern CPU to be tested against a simple model, and still effectively filter out expected leaks while detecting unexpected leaks.</p> <p>Details: The analyzer is implemented by the <code>analyser.py</code> module. The main interface to the analyzer is the <code>Analyser</code> class, with its <code>filter_violation</code> method being the main entry point. It takes a list of <code>CTrace</code> and a list of <code>HTrace</code> objects, and returns a <code>Violation</code> object (defined in <code>traces.py</code>) if a contract violation is detected.</p>"},{"location":"devel/overview/#7-post-violation-analysis","title":"7. Post-violation Analysis","text":"<p>If a violation is detected, the fuzzer performs a sequence of post-violation tests to filter out various types of false positives. If the violation survives all these tests, it is reported to the user. The user can then utilize the postprocessing features of Revizor to identify the root cause of leakage.</p> <p>Details: The post-violation analysis is implemented largely in the <code>Fuzzer::fuzzing_round</code> method. The reporting of the violation is done by the <code>logs.py:FuzzLogger</code> class, which is accessed via the <code>report_violation</code> method. The post-processing is implemented by various classes in the <code>postprocessing</code> module.</p>"},{"location":"devel/overview/#revizor-modules-and-interfaces","title":"Revizor Modules and Interfaces","text":"<p>UNDER CONSTRUCTION: If you are interested in this topic, please contact us by opening an issue on GitHub, and we will prioritize this document.</p>"},{"location":"devel/post-violation/","title":"Post-Violation Checks","text":"<p>This document describes a series of test that the fuzzer performs to distinguish between false positives (e.g., due to noise) and genuine violations.</p> <p>UNDER CONSTRUCTION: If you are interested in this topic, please contact us by opening an issue on GitHub, and we will prioritize this document.</p>"},{"location":"devel/registers/","title":"Register Allocation","text":"<p>The test cases are executed in a sandboxed environment, where some of the registers are reserved for internal use, and some are available for use in the test cases. Below is a list of registers and their purpose.</p>"},{"location":"devel/registers/#r15","title":"<code>R15</code>","text":"<p>Contains the base address of the UTILITY area in the sandbox.</p> <p>If the test case does not enter a VM, the register value remains constant during the execution of the test cases. Otherwise, the register value is updated to point to the UTILITY area of the currently active VM when the <code>switch_h2g</code> macro is called, and it is restored to the original value when the <code>switch_g2h</code> macro is called.</p> <p>The register is used by internal functions, such as the implementation of Prime+Probe.</p>"},{"location":"devel/registers/#r14","title":"<code>R14</code>","text":"<p>Contains the base address of the current actor's sandbox (namely, it points to the base of the actor's MAIN area).</p> <p>At the beginning of the test case execution, the register is set to the base address of the MAIN area of the first actor (actor <code>main</code>). The register value is updated to point to the MAIN area of the currently active actor when a macro from the <code>landing_*</code> group of macros is called. It is also updated by the <code>fault_handler</code> macro.</p> <p>The register is used in test cases as a part of the sandboxing mechanism. For example, all generated memory accesses are relative to the value stored in <code>R14</code>, and have the form of <code>[R14 + offset]</code>.</p>"},{"location":"devel/registers/#r13-htrace_register-constant-in-the-kernel-module","title":"<code>R13</code> (<code>HTRACE_REGISTER</code> constant in the kernel module)","text":"<p>Contains either intermediate or final result of the hardware trace measurements.</p> <p>Before entering the test case, the register is set to 0. When a <code>measurement_start</code> macro is executed, the register is (optionally) set to the starting value, such a initial reading of time stamp counter when the <code>TSC</code> mode is used. When a <code>measurement_end</code> macro is executed, the register is updated with the final value of the measurement and contains the resulting hardware trace.</p>"},{"location":"devel/registers/#r12-status_register-constant-in-the-kernel-module","title":"<code>R12</code> (<code>STATUS_REGISTER</code> constant in the kernel module)","text":"<p>Contains a compressed status of the test case execution:</p> <p>Bits[0:7] contain a measurement status. At the beginning of the test case execution, the bits are set to 0. When <code>measurement_start</code> macro is executed, the bits are set to 1. When <code>measurement_end</code> macro is executed, the bits are set to 2. If the measurement status is not 2 at the end of the test case execution, the kernel module will report an error.</p> <p>Bits[8:31] are unused.</p> <p>Bits[32:63] contain a counter of SMI (System Management Interrupt) events. The counter is set automatically before entering the test case (<code>READ_SMI_START</code>), and updated when the test case finishes (<code>READ_SMI_END</code>). If the difference between the readings is not 0, the kernel module will report an error.</p>"},{"location":"devel/registers/#r11","title":"<code>R11</code>","text":"<p>The register is used as a temporary buffer by some of the macros.</p> <p>Before entering the test case, the register is set to 0. When certain macros are executed (e.g., <code>set_k2u_target</code>), the register will contain temporary values. The register should not be used in the test case, as the temporary value may be consumed by latter macros.</p>"},{"location":"devel/registers/#r10-r9-r8","title":"<code>R10, R9, R8</code>","text":"<p>Stores the values of performance counters. <code>R10</code> stores the value of performance counter #1, <code>R9</code> stores the value of performance counter #2, and <code>R8</code> stores the value of performance counter #3.</p> <p>Before entering the test case, the registers are set to 0. When a <code>measurement_start</code> macro is executed, the registers are (optionally) set to the starting values. When a <code>measurement_end</code> macro is executed, the registers are updated with the final values of the measurements.</p>"},{"location":"devel/registers/#other-general-purpose-registers","title":"Other General Purpose Registers","text":"<p>The remaining registers (<code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>rflags</code>) are available for use in the test cases and can be modified freely. A special case are <code>rsp</code> and <code>rbp</code>, which can be used in the test cases, but their values must always remain within the sandbox (see Sandbox).</p>"},{"location":"devel/registers/#vector-registers","title":"Vector Registers","text":"<p>Vector registers (<code>xmm0</code>-<code>xmm15</code>) are also available for use in the test cases. However, only <code>xmm0-xmm7</code> are initialized with input-based values, and the remaining registers are always zero-initialized.</p> <p>Large-size vector registers (<code>ymm</code> and <code>zmm</code>) are not supported.</p>"},{"location":"devel/sandbox/","title":"Test Case Sandbox","text":"<p>This document describes the isolated environment for executing test cases, which is referred to as the sandbox. The sandbox contains the test case code and data, and the test case code is confined to access memory only within the sandbox.</p> <p>The sandbox is implemented by all modules that execute test cases, including the executor (kernel module) and all model backends (Unicorn, DynamoRIO). To ensure that the executions are consistent across all modules, the sandbox is structured in the same way in all the modules.</p> <p>This document describes the memory layout of the sandbox, the initialization of the sandbox memory, and the fault isolation mechanism.</p>"},{"location":"devel/sandbox/#memory-layout","title":"Memory Layout","text":"<p>The sandbox memory is divided into two main areas: the data sandbox and the code sandbox. Each actor in the test case has its own sub-area for its data and code, and the layout of these areas is the same for all actors.</p>"},{"location":"devel/sandbox/#data-layout","title":"Data Layout","text":"<pre><code>|----------|--------------------|\n| ACTOR 0  | MACRO STACK        | 64 B\n|          |--------------------|\n|          | UNDERFLOW PAD      | 4032 B\n|          |--------------------|\n|          | MAIN AREA          | 4096 B\n|          |--------------------|\n|          | FAULTY AREA        | 4096 B\n|          |--------------------|\n|          | GPR AREA           | 64 B\n|          |--------------------|\n|          | SIMD AREA          | 256 B\n|          |--------------------|\n|          | OVERFLOW PAD       | 3776 B\n|----------|--------------------|\n| ... (repeat for all actors in the test case)\n</code></pre> <p>The data area is divided into the following regions: * Main and Faulty Areas: These are the two regions of memory that are accessible by the test case code.   This is enforced by the test case generator, which instruments all memory accesses to ensure that they fall within these regions (see code-generation for more details).   Both areas are initialized with the input data from the RBDF.   The main area always has default permissions (RW), while the faulty area has permissions can be configured to cause a fault when accessed.   This configuration originates from the config file. * GPR and SIMD Areas: These regions store the values that will be used by the modules to initialize the general-purpose registers (GPR) and SIMD registers before executing the test case and when switching between actors.   Both areas are initialized with the input data from the RBDF. * Over- and Underflow Pads: These two zero-initialized regions surround the actors' data areas, and their purpose is to determinize the hardware traces on the executor.   Namely, they are needed for the cases when the CPU speculatively bypasses the sandboxing instrumentation inserted by the test case generator, and the bypass leads to an out-of-bounds memory access.   As the pads are zero-initialized, the bypassed memory accesses will produce deterministic results. * Macro stack: This region is used to implement complex macros (e.g., VMENTER) that need to save and restore data on the stack with a guarantee that this data won't be corrupted by the following (randomly-generated) instructions (see macros for more details.)</p>"},{"location":"devel/sandbox/#code-layout","title":"Code Layout","text":"<pre><code>|----------|--------------------|\n| ACTOR 0  | MAIN CODE AREA     | 8192 B\n|          |--------------------|\n|          | MACRO CODE AREA    | 4096 B\n|----------|--------------------|\n| ... (repeat for all actors in the test case)\n</code></pre> <p>The code area is divided into two regions: * Main Code Area: This region contains the binary of the actor's code.   The code comes from the RCDF file.   The first instruction in the code area of actor 0 is the entry point of the test case, and the last instruction of actor 0 is the exit point of the test case. * Macro Code Area: This region contains code of the expanded macros for each actor.   (see macros for more details on the macro expansion process.)</p>"},{"location":"devel/sandbox/#references","title":"References","text":"<ul> <li>Executor: src/x86/executor/include/sandbox_manager.h</li> <li>Unicorn backend: src/sandbox.py</li> </ul>"},{"location":"devel/sandbox/#sandbox-initialization","title":"Sandbox Initialization","text":"<p>The sandbox is initialized based on the test case code (normally in RCBD format) and the input data (normally in RDBF format). The following diagram shows the mapping between the RCBF/RDBF files and the sandbox memory layout:</p> <pre><code>                                        |--------------------|\n                   zero initialized -&gt;  | MACRO STACK        |\n                                        |--------------------|\n                   zero initialized -&gt;  | UNDERFLOW PAD      |\n                                        |--------------------|\n      RDBF.data[actor_id].main_area -&gt;  | MAIN AREA          |\n                                        |--------------------|\n    RDBF.data[actor_id].faulty_area -&gt;  | FAULTY AREA        |\n                                        |--------------------|\nRDBF.data[actor_id].reg_init_region -&gt;  | GPR AREA           |\n                                        |--------------------|\nRDBF.data[actor_id].reg_init_region -&gt;  | SIMD AREA          |\n                                        |--------------------|\n                   zero initialized -&gt;  | OVERFLOW PAD       |\n                                        |--------------------|\n\n\n     RCBF.tc_section[actor_id].code -&gt;  | MAIN CODE AREA     |\n                                        |--------------------|\n     expanded macro code (executor) -&gt;  | MACRO CODE AREA    |\n</code></pre>"},{"location":"devel/sandbox/#fault-isolation","title":"Fault Isolation","text":"<p>UNDER CONSTRUCTION</p>"},{"location":"devel/tc-representation/","title":"Test Case Code Representation","text":"<p>This document describes the internal representation of test case code in Revizor.</p> <p>UNDER CONSTRUCTION</p> <p>If you are interested in this topic, please contact us by opening an issue on GitHub, and we will prioritize this document.</p>"},{"location":"devel/unicorn-model/","title":"Unicorn-based Model Backend","text":"<p>UNDER CONSTRUCTION</p> <p>If you are interested in this topic, please contact us by opening an issue on GitHub, and we will prioritize this document.</p>"},{"location":"user/cli/","title":"Command-Line Interface","text":"<p>Revizor is controlled via two interfaces: command line and configuration file. Command line arguments specify the mode of operation and set high-level parameters (e.g., file paths, number of fuzzing rounds). Configuration files specify details of the fuzzing campaign (e.g., the target contract, generation parameters, etc).</p> <p>This document describes the command-line interface. For information on configuration files, see the configuration documentation.</p>"},{"location":"user/cli/#modes","title":"Modes","text":"<p>The command line options depend on the selected mode of operation (see modes page for their descriptions). To select a mode on the command-line, begin your command with:</p> <pre><code>rvzr MODE # ... arguments go here\n\n# Where MODE can be:\n#   fuzz            fuzzing mode\n#   tfuzz           template fuzzing mode\n#   reproduce       reproduce mode\n#   minimize        test case minimization mode\n#   analyse         stand-alone trace analysis mode\n#   generate        stand-alone generation mode\n#   download_spec   call the script that downloads the instruction set specification\n</code></pre>"},{"location":"user/cli/#fuzzing-mode","title":"Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>fuzz</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  -t TESTCASE, --testcase TESTCASE\n                        Use an existing test case [DEPRECATED - see reproduce]\n  --timeout TIMEOUT     Run fuzzing with a time limit [seconds]. No timeout when set to zero.\n  --nonstop             Don't stop after detecting an unexpected result\n  --save-violations SAVE_VIOLATIONS\n                        If set, store all detected violations in working directory.\n</code></pre>"},{"location":"user/cli/#template-fuzzing-mode","title":"Template Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>analyse</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  -t TEMPLATE, --template TEMPLATE\n                        The template to use for generating test cases\n  --timeout TIMEOUT     Run fuzzing with a time limit [seconds]. No timeout when set to zero.\n  --nonstop             Don't stop after detecting an unexpected result\n  --save-violations SAVE_VIOLATIONS\n                        If set, store all detected violations in working directory.\n</code></pre>"},{"location":"user/cli/#reproduce-mode","title":"Reproduce Mode","text":"<p>The following command-line arguments are supported in <code>reproduce</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -t TESTCASE, --testcase TESTCASE\n                        Path to the test case\n  -i [INPUTS ...], --inputs [INPUTS ...]\n                        Path to the directory with inputs\n  -n NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case. [IGNORED if --input-dir is set]\n</code></pre>"},{"location":"user/cli/#minimize-mode","title":"Minimize Mode","text":"<p>The following command-line arguments are supported in <code>minimize</code> mode. See also the minimization documentation for a list of available minimization passes.</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  --testcase TESTCASE, -t TESTCASE\n                        Path to the test case program that needs to be minimized.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs to the program that will be used during minimization.\n  --testcase-outfile TESTCASE_OUTFILE, -o TESTCASE_OUTFILE\n                        Output path for the minimized test case program.\n  --input-outdir INPUT_OUTDIR\n                        Output directory for storing minimized inputs.\n  --num-attempts NUM_ATTEMPTS\n                        Number of attempts to minimize the test case.\n  --enable-&lt;pass&gt;       Enable a specific pass during minimization.\n</code></pre>"},{"location":"user/cli/#stand-alone-trace-analysis-mode","title":"Stand-alone Trace Analysis Mode","text":"<p>The following command-line arguments are supported in <code>analyse</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  --ctraces CTRACES\n  --htraces HTRACES\n</code></pre>"},{"location":"user/cli/#stand-alone-generation-mode","title":"Stand-alone Generation Mode","text":"<p>The following command-line arguments are supported in <code>generate</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to the configuration file (YAML) that will be used during fuzzing.\n  -I INCLUDE_DIR, --include-dir INCLUDE_DIR\n                        Path to the directory containing configuration files that included by the main configuration file (received\n                        via --config).\n  -s INSTRUCTION_SET, --instruction-set INSTRUCTION_SET\n                        Path to the instruction set specification (JSON) file.\n  -r SEED, --seed SEED  Add seed to generate test case.\n  -n NUM_TEST_CASES, --num-test-cases NUM_TEST_CASES\n                        Number of test cases.\n  -i NUM_INPUTS, --num-inputs NUM_INPUTS\n                        Number of inputs per test case.\n  -w WORKING_DIRECTORY, --working-directory WORKING_DIRECTORY\n  --permit-overwrite    Permit overwriting existing files.\n</code></pre>"},{"location":"user/cli/#download-instruction-set-specification","title":"Download Instruction Set Specification","text":"<p>The following command-line arguments are supported in <code>download_spec</code> mode:</p> <pre><code>  -h, --help            show this help message and exit\n  -a ARCHITECTURE, --architecture ARCHITECTURE   The ISA to download the specification for (e.g., x86-64)\n  --outfile OUTFILE, -o OUTFILE   The destination file to save the downloaded specification.\n  --extensions [EXTENSIONS ...]   List of ISA extensions to include in the specification (e.g., SSE, VTX)\n</code></pre>"},{"location":"user/config/","title":"Configuration File","text":"<p>Below is a list of the available configuration options for Revizor, which are passed down to Revizor via a config file. For an example of how to write the config file, see src/tests/big-fuzz.yaml.</p>"},{"location":"user/config/#fuzzing-configuration","title":"Fuzzing Configuration","text":"<pre><code>Name: fuzzer\nDefault: 'basic'\nOptions: 'basic' | 'architectural' | 'archdiff'\n</code></pre> <p>This option selects the fuzzing mode. The available options are:</p> <ul> <li><code>basic</code> - normal model-based fuzzing. A violation in this mode indicates that the CPU exposes more information than predicted by the contract. This option should be used in most testing campaigns.</li> <li><code>architectural</code> - self-fuzzing for architectural mismatches between the model and the executor. This option should be used for testing the fuzzer itself, i.e., a violation in this mode indicates a bug in the fuzzer rather then a bug in the CPU. This is useful when running the fuzzer with a previously-untested instruction set, or when a new contract is implemented.</li> <li><code>archdiff</code> - fuzzing for architectural invariants. This is a special mode targeted for for semi-microarchitectural violations, similar to ZenBleed. This mode is experimental and should be used with caution.</li> </ul> <pre><code>Name: enable_priming\nDefault: True\n</code></pre> <p>This option enables or disables priming. This options should be set to True in most cases, as priming is crucial for eliminating false positives.</p> <p>Priming solves the following problem: Revizor collects hardware traces for inputs in a sequence, and the microarchitectural state is not reset between the inputs. This means that the microarchitectural state for the input at, for example, position 100 is different from the state for the input at position 200. Accordingly, the hardware traces for these inputs may differ because the measurements are taken in different microarchitectural contexts.</p> <p>To address this issue, we uses priming, which swaps the inputs in the sequence and re-runs the tests. For example, if the original sequence is (i1 . . . i99,i100,i101 . . . i199,i200), the priming sequence will be (i1 . . . i99,i200,i101 . . . i199,i100). If the violation persists in this sequence, it is a true positive. If the violation disappears, it is a false positive, and it will be discarded.</p> <pre><code>Name: enable_speculation_filter\nDefault: False\n</code></pre> <p>If enabled, Revizor will discard test cases that do not trigger speculation.</p> <p>This option is useful for improving the throughput of the fuzzer, but it can discard potential violations if the leakage is not caused by speculation.</p> <pre><code>Name: enable_observation_filter\nDefault: False\n</code></pre> <p>If enabled, Revizor will discard test cases that do not leave speculative traces. The filtering is performed by adding an <code>LFENCE</code> after each instruction in the test case, and comparing the resulting hardware traces with the original. If the traces are identical, the test case is discarded.</p> <p>This option is useful for improving the throughput of the fuzzer, but it can discard potential violations if the leakage is not caused by speculation.</p> <pre><code>Name: enable_fast_path_model\nDefault: True\n</code></pre> <p>If enabled, the same contract trace will be used for all inputs in the same taint-based input class.</p> <pre><code>Name: color\nDefault: False\n</code></pre> <p>If enabled, the output will be colored. This option is helps a lot with readability, but may produce corrupted output when redirected to a file.</p> <pre><code>Name: logging_modes\nDefault: ['info', 'stat']\nOptions: 'info' | 'stat' | 'dbg_timestamp' | 'dbg_violation' | 'dbg_dump_htraces' | 'dbg_dump_ctraces' | 'dbg_dump_traces_unlimited' | 'dbg_executor_raw' | 'dbg_model' | 'dbg_coverage' | 'dbg_generator' | 'dbg_priming'\n</code></pre> <p>This option controls the output:</p> <ul> <li><code>info</code> - general information about the progress of fuzzing;</li> <li><code>stat</code> - statistics the end of the fuzzing campaign;</li> <li><code>dbg_timestamp</code> - every 1000 test cases print the timestamp during the fuzzing process;</li> <li><code>dbg_violation</code> - upon detecting a violation, print detailed information about it;</li> <li><code>dbg_dump_htraces</code> - print the first 100 hardware traces for every test case;</li> <li><code>dbg_dump_ctraces</code> - print the first 100 contract traces for every test case;</li> <li><code>dbg_dump_traces_unlimited</code> - print ALL traces (use carefully, produces LOTS of text);</li> <li><code>dbg_executor_raw</code> - prints hardware traces for every stage of the fuzzing process;   this differs from <code>dbg_dump_htraces</code> in that it prints the traces collected by   speculation/observation filters as well as at every iteration of multi-sample collection;</li> <li><code>dbg_model</code> - print a detailed info about EVERY instruction executed on the model (use carefully, produces LOTS of text);</li> <li><code>dbg_coverage</code> - stores instruction coverage information;</li> <li><code>dbg_generator</code> - prints a list of instructions used to generate test cases;</li> <li><code>dbg_priming</code> - prints information about the priming process; only useful for debugging the priming mechanism itself.</li> </ul> <pre><code>Name: multiline_output\nDefault: False\n</code></pre> <p>If enabled, each output message will be printed on a separate line. Otherwise, the fuzzing progress will be continuously overwriting the same line (works only in the terminal).</p>"},{"location":"user/config/#program-generator-configuration","title":"Program Generator Configuration","text":"<pre><code>Name: instruction_set\nDefault: 'x86-64'\nOptions: 'x86-64'\n</code></pre> <p>The instruction set under test. Currently, only x86-64 is supported.</p> <pre><code>Name: instruction_categories\nDefault: ['BASE-BINARY', 'BASE-BITBYTE', 'BASE-COND_BR']\nOptions: (depends on model backend; see &lt;isa&gt;_config.py for details)\n</code></pre> <p>Select a list of instruction categories to be used when generating programs. This list effectively filters out instructions from the ISA descriptor file (e.g., <code>base.json</code>) passed via the command line (<code>-s</code>).</p> <pre><code>Name: instruction_blocklist\nDefault: ['enterw', 'enter', 'leavew', 'leave', 'int', 'encls', 'vmxon', 'stgi', 'skinit', 'ldmxcsr', 'stmxcsr', 'lfence', 'mfence', 'sfence', 'clflush', 'clflushopt', 'divps', 'divss', 'divpd', 'divsd', 'mulss', 'mulps', 'mulpd', 'mulsd', 'rsqrtps', 'rsqrtss', 'sqrtps', 'sqrtss', 'sqrtpd', 'sqrtsd', 'addps', 'addss', 'addpd', 'addsd', 'subps', 'subss', 'subpd', 'subsd', 'addsubpd', 'addsubps', 'haddpd', 'haddps', 'hsubpd', 'hsubps', 'sti', 'cli', 'xlat', 'xlatb', 'cmpxchg8b', 'lock cmpxchg8b', 'cmpxchg16b', 'lock cmpxchg16b', 'cpuid', 'cmpps', 'cmpss', 'cmppd', 'cmpsd', 'movq2dq', 'movdq2q', 'rcpps', 'rcpss', 'pcmpestriq', 'pcmpestrmq', 'vpcmpestriq', 'vpcmpestrmq', 'maskmovdqu', 'maskmovq', 'vmaskmovdqu', 'vmaskmovq']\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions that will NOT be used for generating programs. This list filters out instructions from <code>instruction_categories</code>, but not from <code>instruction_allowlist</code>.</p> <p>The resulting instruction pool is:      (instructions from instruction_categories - instruction_blocklist) + instruction_allowlist</p> <p>The instructions that are blocked by default are known to cause issues in the model or executor, and hence should generally be avoided when fuzzing.</p> <pre><code>Name: instruction_blocklist_append\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions that will be appended to the default instruction blocklist. This option is identical to <code>instruction_blocklist</code>, but the list is added to the previous blocklist instead of replacing it. This is useful when you want to block some instructions in addition to the default blocklist.</p> <pre><code>Name: instruction_allowlist\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>A list of instructions to use for generating programs. This list has priority over <code>instruction_categories</code> and over <code>instruction_blocklist</code>, thus adding instructions on top of the categories.</p> <p>The resulting instruction pool is:      (instructions from instruction_categories - instruction_blocklist) + instruction_allowlist</p> <pre><code>Name: program_generator_seed\nDefault: 0\n</code></pre> <p>Seed of the program generator. If set to zero, a random seed will be used for each run.</p> <pre><code>Name: program_size\nDefault: 24\n</code></pre> <p>Number of instructions per program. The actual size might be larger because of the instrumentation.</p> <pre><code>Name: avg_mem_accesses\nDefault: 12\n</code></pre> <p>Average number of memory accesses in generated programs. The actual number will be random, but the average over all programs will be close to this value.</p> <pre><code>Name: min_bb_per_function\nDefault: 1\n</code></pre> <p>Minimal number of basic blocks per function in generated programs.</p> <pre><code>Name: max_bb_per_function\nDefault: 2\n</code></pre> <p>Maximal number of basic blocks per function in generated programs.</p> <pre><code>Name: min_successors_per_bb\nDefault: 1\n</code></pre> <p>Minimal number of successors for each basic block in generated programs.</p> <p>Note 1: this config option is a hint; it could be ignored if the instruction set does not have the necessary instructions to satisfy it, or if a certain number of successor is required for correctness</p> <p>Note 2: If min_successors_per_bb &gt; max_successors_per_bb, the value is overwritten with max_successors_per_bb</p> <pre><code>Name: max_successors_per_bb\nDefault: 1\n</code></pre> <p>Maximal number of successors for each basic block in generated programs.</p> <p>Note: this config option is a hint; it could be ignored if the instruction set does not have the necessary instructions to satisfy it, or if a certain number of successor is required for correctness</p> <pre><code>Name: register_allowlist\nDefault: []\nOptions: (any register names)\n</code></pre> <p>A list of registers that CAN be used for generating programs.</p> <p>This list has higher priority than <code>register_blocklist</code>. The resulting list is: (all registers - <code>register_blocklist</code>) + <code>register_allowlist</code>.</p> <pre><code>Name: register_blocklist\nDefault: (all but RAX, RBX, RCX, RDX, RDI, RSI, XMM0-XMM7)\nOptions: (any register names)\n</code></pre> <p>A list of registers that will NOT be used for generating programs.</p> <p>This list has lower priority than <code>register_allowlist</code>. The resulting list is: (all registers - <code>register_blocklist</code>) + <code>register_allowlist</code>.</p> <p>The default blocked registers are used by the executor internally, and thus should be avoided.</p> <pre><code>Name: generator_faults_allowlist\nDefault: []\nOptions: 'div-by-zero' | 'div-overflow' | 'opcode-undefined' | 'bounds-range-exceeded' | 'breakpoint' | 'debug-register' | 'non-canonical-access' | 'user-to-kernel-access'\n</code></pre> <p>By default, the generator will produce programs that never trigger exceptions. This option modifies this behavior by permitting the generator to produce 'unsafe' instruction sequences that could potentially trigger an exception. The model and executor will also be configured to handle these exceptions gracefully.</p> <p>The available options are:</p> <ul> <li><code>div-by-zero</code> - generate divisions with unmasked divisor, which can cause a division by zero exception.</li> <li><code>div-overflow</code> - generate divisions with unmasked dividend, which can cause an overflow exception.</li> <li><code>opcode-undefined</code> - generate undefined opcodes, which can cause an undefined opcode exception.</li> <li><code>bounds-range-exceeded</code> - apply MPX instructions for random bounds checks.   This is possible only if MPX is included in the tested instruction set.</li> <li><code>breakpoint</code> - generate breakpoints, which can cause INT3 exceptions.</li> <li><code>debug-register</code> - generate instructions that cause INT1 exceptions.</li> <li><code>non-canonical-access</code> - randomly select a memory access in a generated program and instrument it to access a non-canonical address.</li> <li><code>user-to-kernel-access</code> - randomly select a memory access in a user actor's code and instrument it to access a kernel address; works only if there is at least one user actor.</li> </ul>"},{"location":"user/config/#actor-configuration","title":"Actor Configuration","text":"<p>All actors are defined in the <code>actors</code> list, with the following syntax:</p> <pre><code>actors:\n  - &lt;actor1_name&gt;\n    - &lt;actor_option&gt;: &lt;value&gt;\n    - &lt;actor_option&gt;:\n       - &lt;sub_option1&gt;: &lt;value1&gt;\n       - &lt;sub_option2&gt;: &lt;value2&gt;\n    ...\n  - &lt;actor2_name&gt;\n      ...\n  ...\n</code></pre> <p>The following options are available for each actor:</p> <pre><code>Actor Option: mode\nDefault: 'host'\nOptions: 'host' | 'guest'\n</code></pre> <p>The execution mode of the actor. The available options are:</p> <ul> <li><code>host</code> - the actor runs in the normal, non-virtualized mode.</li> <li><code>guest</code> - the actor runs in a VM (one VM per actor).</li> </ul> <pre><code>Actor Option: privilege_level\nDefault: 'kernel'\nOptions: 'user' | 'kernel'\n</code></pre> <p>The privilege level of the actor. The available options are:</p> <ul> <li><code>user</code> - the actor runs in user mode (CPL=3).</li> <li><code>kernel</code> - the actor runs in kernel mode (CPL=0).</li> </ul> <pre><code>Actor Option: data_properties\nDefault: (see below)\nOptions: 'present' | 'writable' | 'user' | 'accessed'\n         | 'dirty' | 'executable' | 'reserved_bit' | 'randomized'\n</code></pre> <p>The properties of the data memory used by the actor. These properties are applied only to the second page (FAULTY_AREA) of the actor's data region.</p> <p>The available options are:</p> <ul> <li><code>present</code> [default: True] - the value of the Present bit in the page table entry.</li> <li><code>writable</code> [default: True] - the value of the Writable bit in the page table entry.</li> <li><code>user</code> [default: False] - the value of the User/Supervisor bit in the page table entry.</li> <li><code>accessed</code> [default: True] - the value of the Accessed bit in the page table entry.</li> <li><code>dirty</code> [default: True] - the value of the Dirty bit in the page table entry.</li> <li><code>executable</code> [default: False] - the value of the Executable bit in the page table entry.</li> <li><code>reserved_bit</code> [default: False] - the value of the Reserved bit in the page table entry.</li> <li><code>randomized</code> [default: False] - if true, the values of the above properties will be randomized for each test case.</li> </ul> <p>Note that the above properties are set in the host page tables for actors with <code>mode: host</code>, and in the guest page tables for actors with <code>mode: guest</code>.</p> <pre><code>Actor Option: data_ept_properties\nDefault: (see below)\nOptions: 'present' | 'writable' | 'executable' | 'accessed' | 'dirty' | 'user'\n        | 'reserved_bit' | 'randomized'\n</code></pre> <p>The properties of the EPT entry used by the actor (on Intel) or the NPT entry (on AMD). The properties are applied only to the second page (FAULTY_AREA) of the actor's data region.</p> <p>This property has no effect on actors with <code>mode: host</code>.</p> <p>The available options are:</p> <ul> <li><code>present</code> [default: True] - the value of the Present bit in the EPT/NPT entry.</li> <li><code>writable</code> [default: True] - the value of the Writable bit in the EPT/NPT entry.</li> <li><code>executable</code> [default: False] - the value of the Executable bit in the EPT/NPT entry.</li> <li><code>accessed</code> [default: True] - the value of the Accessed bit in the EPT/NPT entry.</li> <li><code>dirty</code> [default: True] - the value of the Dirty bit in the EPT/NPT entry.</li> <li><code>user</code> [default: False] - the value of the User/Supervisor bit in the EPT/NPT entry.</li> <li><code>reserved_bit</code> [default: False] - the value of the Reserved bit in the EPT/NPT entry.</li> <li><code>randomized</code> [default: False] - if true, the values of the above properties will be randomized for each test case.</li> </ul> <pre><code>Actor Option: observer\nDefault: False\n</code></pre> <p>If enabled, the actor will be an observer actor, hence modelling an attacker. This option is only used if the contract is <code>noninterference</code>, and it is ignored otherwise.</p> <pre><code>Actor Option: instruction_blocklist\nDefault: []\nOptions: (any instruction names)\n</code></pre> <p>Actor-specific instruction blocklist. This list has priority over the global <code>instruction_blocklist</code>.</p> <pre><code>Actor Option: fault_blocklist\nDefault: []\nOptions: (any fault names)\n</code></pre> <p>Actor-specific fault blocklist. This list has priority over the global <code>generator_faults_allowlist</code>.</p>"},{"location":"user/config/#input-generator-configuration","title":"Input Generator Configuration","text":"<pre><code>Name: data_generator\nDefault: 'random'\nOptions: 'random'\n</code></pre> <p>The input generator type. Currently, only random input generation is supported.</p> <pre><code>Name: data_generator_seed\nDefault: 10\n</code></pre> <p>Seed of the input generator. If set to zero, a random seed will be used for each run.</p> <pre><code>Name: data_generator_entropy_bits\nDefault: 16\n</code></pre> <p>Entropy of the random values created by the input generator. The maximum value is 31.</p> <pre><code>Name: inputs_per_class\nDefault: 2\n</code></pre> <p>Number of inputs generated for each input class by the Contract-Driven Input Generator. For the explanation of the input classes and the generation algorithm, see (this paper)[https://arxiv.org/pdf/2301.07642], Section 4.D. Contract-driven Input Generator.</p>"},{"location":"user/config/#contract-configuration","title":"Contract Configuration","text":"<pre><code>Name: contract_execution_clause\nDefault: ['seq']\nOptions: 'seq' | 'no_speculation' | 'seq-assist' | 'cond' | 'conditional_br_misprediction' | 'bpas' | 'nullinj-fault' | 'nullinj-assist' | 'delayed-exception-handling' | 'div-zero' | 'div-overflow' | 'meltdown' | 'fault-skip' | 'noncanonical' | 'vspec-ops-div' | 'vspec-ops-memory-faults' | 'vspec-ops-memory-assists' | 'vspec-ops-gp' | 'vspec-all-div' | 'vspec-all-memory-faults' | 'vspec-all-memory-assists'\n</code></pre> <p>The execution clause of the contract.</p> <ul> <li><code>seq</code> - sequential execution.</li> <li><code>no_speculation</code> - sequential execution. Synonym for <code>seq</code>.</li> <li><code>seq-assist</code> - sequential execution with possible microcode assists.</li> <li><code>cond</code> - permitted misprediction of conditional branches.</li> <li><code>conditional_br_misprediction</code> - permitted misprediction of conditional branches. Synonym for <code>cond</code>.</li> <li><code>bpas</code> - permitted speculative store bypass</li> <li><code>nullinj-fault</code> - page faults are permitted to speculatively return zero.</li> <li><code>nullinj-assist</code> - microcode assists are permitted to speculatively return zero.</li> <li><code>delayed-exception-handling</code> - upon an exception or a fault, data-independent instructions that follow the exception are allowed to execute speculatively.</li> <li><code>meltdown</code> - permission-based page faults are permitted to speculatively return the value in the memory.</li> <li><code>fault-skip</code> - upon a fault, the faulting instruction is speculatively skipped.</li> <li><code>noncanonical</code> - permitted speculative non-canonical memory accesses.</li> <li><code>vspec*</code> - experimental contracts for value speculation. See (this paper)[https://www.usenix.org/system/files/usenixsecurity23-hofmann.pdf] for details.</li> <li><code>div-zero</code> - experimental contract; do not use.</li> <li><code>div-overflow</code> - experimental contract; do not use.</li> </ul> <pre><code>Name: contract_observation_clause\nDefault: 'ct'\nOptions: 'none' | 'l1d' | 'memory' | 'pc' | 'ct' | 'loads+stores+pc' | 'ct-nonspecstore' | 'ctr' | 'arch' | 'tct' | 'tcto' | 'ct-ni'\n</code></pre> <p>The observation clause of the contract. In most cases, the default value should be used.</p> <p>For single-actor experiments, the following options are available:</p> <ul> <li><code>none</code> - the model observes nothing. Useful for testing the fuzzer.</li> <li><code>l1d</code> - the model observes the addresses of data accesses, adjusted to imitate the L1D cache trace.   Has very few real applications, and should be generally avoided.</li> <li><code>memory</code> - the model observes the addresses of data accesses.</li> <li><code>ct</code> (constant time tracer) - the model observes the addresses of data accesses and the control flow.</li> <li><code>loads+stores+pc</code> - the model observes the addresses of data accesses and the control flow. Synonym for <code>ct</code>.</li> <li><code>ct-nonspecstore</code> - the model observes the addresses of data accesses and the control flow, but does not observe the addresses of stores during speculation.</li> <li><code>ctr</code> - the model observes the addresses of data accesses and the control flow, as well as the values of the general-purpose registers.</li> <li><code>arch</code> - the model observes the addresses of data accesses and the control flow, as well as the values loaded from memory.   This clause imitates the security guarantees provided by secure speculation mechanisms like STT.</li> <li><code>tct</code> (truncated constant time tracer) - the model observes address of the memory access and of the program counter at cache line granularity.</li> <li><code>tcto</code> (truncated constant time tracer with overflows) - the model address of the memory access and of the program counter at cache line granularity + observe cache line overflows.</li> </ul> <p>In multi-actor context, only one option is available:</p> <ul> <li><code>ct-ni</code> - when executing actors with <code>observer: false</code>, the model observes the same data as as with <code>ct</code>. When executing actors with <code>observer: true</code>, the model observes complete memory of the actor as well as their register values.</li> </ul> <pre><code>Name: model_backend\nDefault: 'unicorn'\nOptions: 'dummy' | 'unicorn' | 'dynamorio'\n</code></pre> <p>The backend used to implement the contract model. The available options are: * <code>unicorn</code> - use the Unicorn emulator. This is the default option and it is recommended for most cases. * <code>dynamorio</code> - use the DynamoRIO dynamic binary instrumentation framework. This option is newly added and experimental. Avoid using it unless you are doing development work on Revizor. * <code>dummy</code> - use a dummy model. This model always returns the same (empty) contract trace, and as such will not produce meaningful results. This option is useful, however, when root-causing violations, because it allows to collect hardware traces without running the model, hence allowing to trace instructions that are not supported by any of the backends.</p> <pre><code>Name: model_min_nesting\nDefault: 1\n</code></pre> <p>Minimum number of nested mispredictions in the model. This value is used to generate the contract traces on the fast path of the fuzzer.</p> <pre><code>Name: model_max_nesting\nDefault: 30\n</code></pre> <p>Maximum number of nested mispredictions in the model. This value is used to generate the contract traces on the slow path of the fuzzer, i.e., when a potential violation is detected and the fuzzer tries to check if it is a true positive.</p> <pre><code>Name: model_max_spec_window\nDefault: 250\n</code></pre> <p>Size of the speculation window in the model.</p>"},{"location":"user/config/#executor-configuration","title":"Executor Configuration","text":"<pre><code>Name: executor\nDefault: (auto-detected)\nOptions: 'x86-64-intel' | 'x86-64-amd'\n</code></pre> <p>The executor type. The default value is auto-detected based on the <code>cpuinfo</code>. Should be changed only if the auto-detection fails.</p> <pre><code>Name: executor_mode\nDefault: 'P+P'\nOptions: 'P+P' | 'F+R' | 'E+R' | 'PP+P' | 'TSC'\n</code></pre> <p>Hardware trace collection mode. The available options are:</p> <ul> <li><code>P+P</code> - prime and probe.</li> <li><code>F+R</code> - flush and reload.</li> <li><code>E+R</code> - evict and reload.</li> <li><code>PP+P</code> - partial prime and probe (i.e., leave a subset of cache lines unprimed).</li> <li><code>TSC</code> - use RDTSCP instruction to measure the time of the execution.</li> </ul> <pre><code>Name: executor_warmups\nDefault: 5\n</code></pre> <p>Number of warmup rounds executed before starting to collect hardware traces.</p> <pre><code>Name: executor_sample_sizes\nDefault: [10, 50, 100, 500]\n</code></pre> <p>A list of sample sizes to be used during the measurements. The executor will first collect the hardware traces with the first sample size in the list, and if a violation is detected, it will try to reproduce it with all the following sample sizes.</p> <pre><code>Name: executor_filtering_repetitions\nDefault: 10\n</code></pre> <p>The sample size to be used by the speculation and observation filters.</p> <pre><code>Name: executor_taskset\nDefault: 0\n</code></pre> <p>The ID of the CPU core on which the executor is running test cases.</p> <pre><code>Name: enable_pre_run_flush\nDefault: True\n</code></pre> <p>If enabled, the executor will do its best to flush the microarchitectural state before running test cases.</p> <pre><code>Name: x86_executor_enable_ssbp_patch\nDefault: True\n</code></pre> <p>Enable a microcode patch against Speculative Store Bypass, if available.</p> <pre><code>Name: x86_executor_enable_prefetcher\nDefault: False\n</code></pre> <p>Enable all prefetchers, if the software controls are available.</p> <pre><code>Name: x86_disable_div64\nDefault: True\n</code></pre> <p>Do not generate 64-bit division instructions. Useful for avoiding certain types of speculation that are specific to 64-bit division.</p> <pre><code>Name: x86_enable_hpa_gpa_collisions\nDefault: False\n</code></pre> <p>When a test case contains at least one guest actor, allocate its memory in the guest physical address space to match the corresponding host physical addresses of the main actor. Useful for testing Foreshadow-like leaks.</p> <pre><code>Name: x86_generator_align_locks\nDefault: True\n</code></pre> <p>When generating memory accesses with locks, apply instrumentation to align the locks to 8 bytes. Useful for avoiding faults on unaligned accesses.</p>"},{"location":"user/config/#analyser-configuration","title":"Analyser Configuration","text":"<pre><code>Name: analyser\nDefault: 'chi2'\nOptions: 'chi2' | 'mwu' | 'sets' | 'bitmaps'\n</code></pre> <p>The type of the analyser that is used to compare the hardware traces and contract traces.</p> <p>The available options are:</p> <ul> <li><code>sets</code> - combine the hardware traces for each input into a set. A violation is reported if two inputs in the same contract-equivalence class have different sets of hardware traces.</li> <li><code>bitmaps</code> - combine the hardware traces for each input into a bitmap. A violation is reported if two inputs in the same contract-equivalence class have different bitmaps of hardware traces.</li> <li><code>chi2</code> - use the chi-squared homogeneity test to compare the hardware traces of inputs in the same contract-equivalence class. This test effectively checks if the hardware traces from two different inputs come from the same distribution. A violation is reported if the test fails.</li> <li><code>mwu</code> - [experimental; both false positives and negatives are possible]   use the Mann-Whitney U test to compare the hardware traces of inputs in the same contract-equivalence class. This test effectively checks if the hardware traces from two different inputs come from the same distribution. A violation is reported if the test fails.</li> </ul> <pre><code>Name: analyser_subsets_is_violation\nDefault: False\n</code></pre> <p>This option is relevant only for the <code>sets</code> and <code>bitmaps</code> analysers.</p> <p>If enabled, the analyser will not label hardware traces as mismatching if they form a subset relation.</p> <pre><code>Name: analyser_outliers_threshold\nDefault: 0.1\n</code></pre> <p>This option is relevant only for the <code>sets</code> and <code>bitmaps</code> analysers.</p> <p>The analyser will ignore the hardware traces that appear in less than this percentage of the repetitions.</p> <pre><code>Name: analyser_stat_threshold\nDefault: 0.5\n</code></pre> <p>This option is relevant only for the <code>chi2</code> and <code>mwu</code> analysers.</p> <p>The threshold for the statistical tests. If a pair of hardware traces has the (normalized) statistics below the threshold, then the traces are considered equivalent.</p> <p>For the chi2 test, the threshold is applied to the <code>statistics / (len(htrace1) + len(htrace2))</code>.</p> <p>For the mwu test, the threshold is applied to the p-value.</p>"},{"location":"user/config/#miscellaneous-configuration","title":"Miscellaneous Configuration","text":"<pre><code>Name: coverage_type\nDefault: 'none'\nOptions: 'none' | 'model_instructions'\n</code></pre> <p>The type of coverage tracking. The available options are:</p> <ul> <li><code>none</code> - disable coverage tracking.</li> <li><code>model_instructions</code> - track how many times the model executed each instruction.</li> </ul> <pre><code>Name: minimizer_retries\nDefault: 1\n</code></pre> <p>Number of minimization retries. When the minimizer performs a check to reduce a test case, each check is attempted this number of times and it succeeds if at least one check is successful.</p>"},{"location":"user/fuzzing-guide/","title":"Tutorial: Root-Causing a Violation Detected by Revizor","text":"<p>This tutorial walks you through analysis of a contract violation detected by Revizor. The goal is to simplify the violation artifacts (program and inputs) and identify the root cause of the violation. The tutorial includes practical examples, explanations of commands, and interpretation of outputs.</p> <p>The examples below will show the process of root-causing a violation of the CT-SEQ contract on an x86-64 CPU. The same general procedure can be applied to other contracts and architectures.</p>"},{"location":"user/fuzzing-guide/#prerequisites","title":"Prerequisites","text":"<ol> <li>Revizor Installed: Ensure Revizor is installed and functional.</li> <li>Detected Violation: Revizor has already surfaced a violation and stored it in a <code>violation-&lt;timestamp&gt;</code> directory.</li> <li>Configuration Files: You have access to the configuration file (<code>config.yaml</code>) used in the fuzzing campaign.</li> </ol>"},{"location":"user/fuzzing-guide/#step-1-locate-the-violation-files","title":"Step 1: Locate the Violation Files","text":"<p>When Revizor detects a violation, it creates a directory (<code>violation-&lt;timestamp&gt;</code>) containing: - <code>program.asm</code>: The test case program that caused the violation. - <code>input_*.bin</code>: A sequence of inputs that triggered the violation. - <code>report.txt</code>: Additional details about the violation, including hardware and contract traces. - <code>org-config.yaml</code>: The original configuration file used in the fuzzing campaign. - <code>reproduce.yaml</code>: A configuration file for reproducing the violation. - <code>minimize.yaml</code>: A configuration file for minimizing the test case.</p>"},{"location":"user/fuzzing-guide/#step-2-reproduce-the-violation","title":"Step 2: Reproduce the Violation","text":"<p>To confirm the violation and analyze its context, reproduce it using the following command:</p> <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t ./violation-&lt;timestamp&gt;/program.asm -i ./violation-&lt;timestamp&gt;/input_*.bin\n</code></pre> <p>If the violation is reproducible, Revizor will print \"Violation detected\" in the terminal output. The distribution of hardware traces in the reproduced violation should be roughly similar to the original violation. If the traces are significantly different, this might be a sign of a bug or a misconfiguration in the fuzzer.</p> <p>Note: The cases of non-reproducible violations are expected to be rare, no more than one or two per machine/week of fuzzing. If your fuzzing campaign produces more, consider adjusting the configuration file to increase noise tolerance (see the Configuration File Documentation).</p>"},{"location":"user/fuzzing-guide/#step-2a-analyze-reproduction-output","title":"Step 2a: Analyze Reproduction Output","text":"<p>The output of the reproduction command provides valuable insights into the violation. Here is an example output:</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 14907365725669422044 (hash)\nHardware traces:\n  Input group 1: [1, 21]\n  Input group 2: [11]\n  ^.^....^.....^.................^...^............^............... [500    | 10    ]\n  ^.^....^.....^................^^...^............^............... [0      | 490   ]\n\n================================ Statistics ===================================\nTest Cases: 1\nInputs per test case: 30.0\nViolations: 1\nEffectiveness:\n  Total Cls: 30.0\n  Effective Cls: 30.0\nDiscarded Test Cases:\n  Speculation Filter: 0\n  Observation Filter: 0\n  Fast Path: 0\n  Max Nesting Check: 0\n  Tainting Check: 0\n  Early Priming Check: 0\n  Large Sample Check: 0\n  Priming Check: 0\n\nDuration: 8.2\nFinished at 12:00:05\n</code></pre>"},{"location":"user/fuzzing-guide/#insights-from-the-output","title":"Insights from the Output","text":"<ul> <li>Violation detected: Indicates that the violation was successfully reproduced.</li> <li>Contract Trace: The value (<code>14907365725669422044</code>) summarizes the contract trace for the inputs that triggered the violation. This value is a hash so it does not provide direct information about the contract trace, but it should match the value from the original violation. If you would like to see the complete contract trace, enable <code>dbg_dump_ctraces</code> in the configuration file.</li> <li>Hardware Traces: The text under the <code>Hardware traces</code> section summarizes the hardware traces that constitute the violation.</li> <li>The text starting with <code>Input group</code> tells us that the violation was triggered by inputs #1, #11, and #21. The inputs #1 and #21 produced the same (or very similar) hardware traces, while input #11 produced a different set of traces - hence they are put into two different groups.</li> <li>The line with <code>^</code> and <code>.</code> characters represents the observed cache changes. Each character encodes the state of the corresponding L1D cache line after the test case has been executed with the given input. Character <code>^</code> indicates that the cache line was accessed (e.g., evicted if P+P mode is used), while <code>.</code> indicates that the cache line was not accessed. The cache sets are numbered left-to-right, starting from zero (TIP: set <code>color: true</code> in config file to improve readability). So, in the above example, the first hardware trace shows the accessed cache sets were 0, 2, 7, 13, 31, 35, and 49: <pre><code>      Set 2 accessed\n      |         Set 13 accessed\n      |          |                    Set 35 accessed\n      |          |                     |\n    ^.^....^.....^.................^...^............^...............\n    |      |                       |                |\n    |      |                       |                Set 49 accessed\n    |      |                       Set 31 accessed\n    |      Set 7 accessed\n    Set 0 accessed\n</code></pre></li> <li>The numbers at the end of the line (<code>[500    | 10    ]</code>) are the numbers of occurrences of the given hardware trace in the sample. Recall that the executor collects each hardware trace multiple times to deal with non-determinism and to filter noise (see <code>executor_sample_sizes</code> configuration option). The first number is the number of occurrences of the trace in the first input group (i.e., inputs #1 and #21), and the second number is the number of occurrences in the second input group (input #11). So, we can tell that the first input group always produced the same hardware trace, while the second input group mainly produced the second hardware trace, but there were a few (10) occurrences of the first trace as well.</li> <li>Statistics: The statistics section can be largely ignored when root-causing the violation. Is it only useful for fine-tuning the fuzzing campaign.</li> </ul>"},{"location":"user/fuzzing-guide/#step-3-minimize-the-program","title":"Step 3: Minimize the Program","text":"<p>The violation program (<code>program.asm</code>) is a large, randomly generated sequence of instructions and it often contains many unnecessary instructions.</p> <p>TIP: If the violation is stable and reproducible, you can try to reduce the sample size to speed up the minimization process. To do so, modify the <code>executor_sample_sizes</code> parameter in the configuration file.</p> <p>Use minimization passes to simplify the program while preserving the violation:</p> <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t ./violation-&lt;timestamp&gt;/program.asm -o minimized.asm -i &lt;num_inputs&gt; \\\n    --num-attempts 10 \\\n    --enable-instruction-pass 1 \\\n    --enable-simplification-pass 1 \\\n    --enable-label-pass 1\n</code></pre>"},{"location":"user/fuzzing-guide/#explanation-of-passes","title":"Explanation of Passes","text":"<ul> <li>The default pass (no flag required) removes unnecessary instructions.</li> <li><code>--enable-simplification-pass</code> replaces complex instructions with simpler ones.</li> <li><code>--enable-label-pass</code> cleans up unused labels.</li> <li>The sequence of three passes is executed 10 time (<code>--num-attempts 10</code>) to ensure the best possible simplification.</li> </ul> <p>This example is the simplest form of minimization. For more advanced minimization options, consider adding the flags described in the Minimization Passes Documentation.</p>"},{"location":"user/fuzzing-guide/#verify-minimization","title":"Verify Minimization","text":"<p>The <code>minimized.asm</code> file contains a reduced version of the original program that still reproduces the violation. Run the <code>reproduce</code> command to ensure the minimizer did not introduce non-determinism. <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t minimized.asm -i &lt;num_inputs&gt;\n</code></pre></p> <p>If the violation is not reproducible, try re-running the minimizer without some some of the passes or decrease the number of attempts.</p>"},{"location":"user/fuzzing-guide/#step-4-minimize-inputs","title":"Step 4: Minimize Inputs","text":"<p>A test case input is the data used to initialize memory and register before executing the test case program. Hence, if we minimize the inputs that trigger the violation, we can isolate the exact conditions causing the violation and the data that leaks.</p> <p>Run the following command to minimize the inputs: <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t minimized.asm -o commented.asm -i &lt;num_inputs&gt; \\\n    --input-outdir ./inputs \\\n    --enable-input-diff-pass 1 \\\n    --enable-comment-pass 1\n</code></pre></p> <p>Result: - <code>./inputs/min_input_*.bin</code>: Minimized input sequence that still trigger the violation. - A printed summary of Leaked bytes in the terminal output. Be sure to record these for further analysis.</p>"},{"location":"user/fuzzing-guide/#insights-from-the-summary","title":"Insights from the Summary","text":"<p>Below is an example of the printed summary from the differential input minimizer: <pre><code>[PASS 2] Differential Input Minimizer\n  &gt; Minimizing the difference between inputs 1 and 11\n\nAddress    +0x0     +0x40    +0x80    +0xc0    +0x100   +0x140   +0x180   +0x1c0\n0x00000000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000200 ........ =....... ........ ........ ........ ........ ........ ........\n0x00000400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00002000 .....^..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2028']\n</code></pre></p> <p>The minimizer goes through the pair of inputs that trigger the violation - inputs #1 and #11 in this case - and tries to minimize the differences between them: * If both inputs already have identical values at a given address, the minimizer prints <code>=</code> for that address. In this example, this is the case for address <code>0x240</code>. * Next, the pass attempts to zero out one byte at a time in both inputs. If the violation persists, then the minimizer prints <code>.</code> for that address. In this example, most of the addresses are zeroed out. * Next, the pass attempts to copy one byte from input #1 into the same address in input #11. If the violation persists, then the minimizer prints <code>+</code> for that address. This example does not have such cases. * If both attempts fail, the pass restores the original values at the given address, prints <code>^</code>, and moves to the next address. In this example, the minimizer restored the original value at address <code>0x2028</code>.</p> <p>The interpretation of these results is case-specific, but generally, the values with <code>+</code> or <code>=</code> are those that create conditions for leakage, and the values with <code>^</code> are the addresses whose value leaks.</p> <p>In this example, the minimizer found that this test case leaks one byte at address <code>0x2028</code> (used to initialize RDI). The minimizer also found that the address <code>0x240</code> must contain specific non-zero values that must be the same in both inputs. This address in the input is used to initialize the corresponding offset in the sandbox of actor 0. See Sandbox Memory Layout for more details about register and memory initialization.</p> <p>TIP 1: The <code>--enable-comment-pass 1</code> flag adds comments to the minimized input files, which can help you understand which instructions used which addresses.</p> <p>TIP 2: Ideally, the minimizer should be able to reduce the leakage to a single byte. If more then a couple bytes leak, it typically indicates that the violation is non-deterministic, and it might be a good idea to re-run the program minimizer or to change the configuration to increase the number of attempts/increase the noise threshold. If no bytes leak, this is a certain sign that something went wrong; re-run the minimizer.</p>"},{"location":"user/fuzzing-guide/#verify-minimization_1","title":"Verify Minimization","text":"<p>Run the minimized program with the reduced inputs to ensure the violation is still reproducible: <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t commented.asm -i ./inputs/min_input*.bin\n</code></pre></p>"},{"location":"user/fuzzing-guide/#step-5-insert-speculation-fences","title":"Step 5: Insert Speculation Fences","text":"<p>To isolate speculative behavior, add fences: <pre><code>rvzr minimize -s base.json -c ./violation-&lt;timestamp&gt;/minimize.yaml \\\n    -t commented.asm -o fenced.asm -i &lt;num_inputs&gt; \\\n    --enable-fence-pass 1\n</code></pre></p> <p>This pass with attempt to insert an <code>LFENCE</code> after every instruction in the program and check if the violation still occurs.</p> <p>In the resulting file (<code>fenced.asm</code>) the region without fences is the one that causes the violation. The remaining instructions are just setting up the data for the violation, and are likely irrelevant.</p> <p>TIP: If an <code>LFENCE</code> is inserted after every instruction in the test case and the violation still occurs, this is most likely due to a bug in the model or the executor. If you are using a custom model, consider checking the model for correctness. If you haven't made changes to the Revizor source code, please, open an issue in the bug tracker.</p>"},{"location":"user/fuzzing-guide/#step-6-map-hardware-traces-to-minimized-program-and-data","title":"Step 6: Map Hardware Traces to Minimized Program and Data","text":"<p>When both program and its inputs are minimized, you should be able to identify which instructions caused the cache accesses in the hardware traces and which data was leaked.</p> <p>When we run the <code>reproduce</code> command with the minimized program and inputs, we will see the following hardware traces:</p> <pre><code>================================ Violations detected ==========================\nContract trace:\n 2362171776002334258 (hash)\nHardware traces:\n  Input group 1: [1]\n  Input group 2: [11]\n  ^...............................................^............... [420    | 0     ]\n  ^............................................................... [80     | 0     ]\n  ^..............^................................................ [0      | 500   ]\n</code></pre> <p>TIP: If in your case the input IDs have changed after minimization, you can either exclude some of the inputs from the arguments of the <code>reproduce</code> command, or re-run the minimizer with fewer passes.</p> <p>We see that the hardware traces have been significantly simplified compared to the original violation, and now there are at most two accessed cache sets in each trace: 0 and 48 for input #1, and 0 and 15 for input #11. This is a good sign: the minimization was successful.</p> <p>We can also tell that the only difference between the two traces is the accessed cache set 48 vs 15 . This is the cache set that is causing the violation, and we should be aiming to find the instruction that does the access.</p> <p>To do so, let's look at the contents of the <code>commented.asm</code> file. This file contains the minimized program with comments that show which memory addresses or cache lines are accessed by each instruction.</p> <pre><code>; ... skipped header ...\n1.  and rax, 0b1111111111111 # instrumentation\n2.  lfence\n3.  mov edx, dword ptr [r14 + rax]\n4.  # mem access: [1] 0x0 cl 0:0 | [11] 0x0 cl 0:0\n5.  or cx, 0b1000 # instrumentation\n6.  and cl, 0b11111000 # instrumentation\n7.  and dx, 0b11 #\n8.  and rsi, 0b1111111111111 #\n9.  add cl, 39 #\n10. mov rbx, 0b1111111111111 #\n11. bt si, dx\n12. jbe .bb_0.1\n13. jmp .exit_0\n14. .bb_0.1:\n15. mov ecx, edi\n16. and rcx, 0b1111111111000 # instrumentation\n17. mov byte ptr [r14 + rcx], 88\n; ... skipped footer ...\n</code></pre> <p>TIP: You can find the same information in a different format if you enable <code>dbg_violation</code> in the configuration file and run the <code>reproduce</code> command.</p> <p>This program contains only two memory accesses, at lines 3 and 17.</p> <p>The annotation at line 4 tells us that the <code>mov</code> instruction accesses memory offset <code>0x0</code> when executed with input 1 (<code>[1]</code>) and the same cache set when executed with input 11 (<code>[11]</code>). The notation <code>0:0</code> stands for cache set <code>0</code> and cache line offset <code>0</code>.</p> <p>This information lets us map this instruction to the first access in the hardware trace:</p> <pre><code>    ^...............................................^...............\n    |\n  This eviction maps to `mov edx, dword ptr [r14 + rax]` at line 3\n</code></pre> <p>The second memory access (line 17) does not have an annotation, which implies that the contract model has not executed this instruction with the inputs provided. It does not, however, mean that the CPU has not executed this instruction, as there is a chance that this instruction was executed speculatively. This is a typical scenario in violations detected by Revizor.</p> <p>If we look at the instructions prior to the memory access, we can see <code>jbe</code> instruction at line 12, which is a conditional jump - a common source of speculation, namely branch prediction. This type of speculation is not permitted by the target contract (CT-SEQ), so it could cause a violation. From this, we can make a hypothesis that the memory access at line 17 is speculative and is the one causing the second cache access:</p> <pre><code> Inputs [1]:\n              Hypothesis: This eviction maps to `mov` at line 17\n                                                  |\n  ^...............................................^...............\n\n Inputs [11]:\n  ^..............^................................................\n                 |\n           Hypothesis: This eviction maps to `mov` at line 17\n</code></pre> <p>To check if our hypothesis is correct, let's cross-reference this information with the leaked bytes from the differential input minimizer:</p> <pre><code>; .. skip zero bytes\n0x00002000 .....^..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2028']\n</code></pre> <p>This summary tells us that <code>rdi</code> has a differing value between inputs #1 and 11. At the same time, the first time <code>rdi</code> is used in the program is at line 15, where it is moved to <code>rcx</code>, and then later used as a part of the address in the memory access at line 17. This would make the speculative memory access at line 17 access different addresses with the two inputs, and would explain the difference between the hardware traces.</p> <p>At this point, the hypothesis is more-or-less confirmed, and we can declare that the root cause of the leak was the misprediction of the <code>jbe</code> branch at line 12, which caused the speculative execution of the memory access at line 17, and which in turn leaked the value of <code>rdi</code>.</p> <p>If we want to further increase our confidence, we can manually inspect the contents of the inputs at the address <code>0x2028</code> to see if the values correspond to the cache set ID that we observe in the hardware traces. This can be done by running the <code>hexdump</code> command on the input files:</p> <pre><code>$ hexdump -C ./inputs/min_input_0001.bin | grep 2020\n00002020  00 00 00 00 00 00 00 00  1e 1c 4a 00 1e 1c 4a 00  |..........J...J.|\n$ hexdump -C ./inputs/min_input_0011.bin | grep 2020\n00002020  00 00 00 00 00 00 00 00  c8 13 58 00 c8 13 58 00  |..........X...X.|\n</code></pre> <p>The values are <code>0x4a1c1e004a1c1e</code> for input #1 and <code>0x5813c8005813c8</code> for input #11. These are masked with <code>0b1111111111000</code> by <code>and</code> at line 16 and become <code>7192</code> and <code>5064</code> respectively. If we translate these values to cache set IDs (<code>id = (addr % 0x1000) // 64</code>), we get <code>48</code> and <code>15</code>. These values match the cache set IDs that we observed in the hardware traces, which confirms our hypothesis.</p> <p>If we want even more confidence, we can manually modify the input files (e.g, with <code>hexedit</code> tool) to see if the hardware traces change when we modify the value of <code>rdi</code> in the input files.</p>"},{"location":"user/fuzzing-guide/#step-7-modify-the-program","title":"Step 7: Modify the Program","text":"<p>In many cases, the minimization process will not provide a clear result as in the example above and you will not be able to make a specific hypothesis about the root cause of the violation. In such cases, you can try to modify the program in various ways to see if the violation still occurs. There are no strict rules on which modifications to make and you will have to rely on your intuition and knowledge of the target microarchitecture, but here are some general guidelines:</p> <ol> <li>Simplify Instructions: Start by trying to manually replace instructions in <code>minimized.asm</code> with simpler ones. For example, replace complex instructions with memory operands with simple loads or stores.</li> <li>Increase/Decrease Aliasing: Try to change the addresses of memory accesses to match (or not match if they already do) the addresses of other instruction. Such aliasing often triggers speculation (e.g., in Speculative Store Bypass or MDS attacks).</li> <li>Add/Remove Dependent Instructions: If you have a hypothesis about which instruction triggers speculation, try adding or removing data-dependent instructions before it. This will change the size of the speculative window and might change hardware traces, which will give you more insight into the violation.</li> <li>Change Memory Permissions: If the violation is related to memory accesses, try changing the permissions of the memory regions that are accessed by the program. For example, if the memory is read-only, try changing it to read-write. If the violation disappears, it might indicate that the violation is related to the permission checks in the CPU.</li> <li>Change Instruction Operands: Try changing operands to add or remove data dependencies between instructions. For example, if you have a sequence of two moves <code>mov rax, [rax]; mov rbx, [rax]</code>, try changing the second move to <code>mov rbx, [rbx]</code> to see if the violation still occurs if there are no data dependencies between the instructions.</li> </ol> <p>After each modification, run the <code>reproduce</code> command to see if the violation still occurs:</p> <pre><code>rvzr reproduce -s base.json -c ./violation-&lt;timestamp&gt;/reproduce.yaml \\\n    -t modified.asm -i ./inputs/min_input*.bin\n</code></pre> <p>NOTE: If you find any other strategies that work well, please consider sharing them by opening a pull request to this documentation. We would love to hear about your experiences and learn from them.</p>"},{"location":"user/fuzzing-guide/#additional-resources","title":"Additional Resources","text":"<ul> <li>Command Line Interface</li> <li>Minimization Passes</li> <li>Configuration File Documentation</li> <li>Sandbox Memory Layout</li> </ul>"},{"location":"user/minimization/","title":"Minimization of Violation Artifacts","text":"<p><code>minimize</code> mode of Revizor performs post-processing of the violation artifacts produced as a result of testing a CPU in the <code>fuzz</code> mode. This mode takes a violating program and its sequence of inputs, and it performs a series of transformation passes to simplify the program and the inputs while preserving the violation. The goal is to produce a minimal artifact that would be easier to understand and analyze by a human.</p>"},{"location":"user/minimization/#usage","title":"Usage","text":"<p>To run the minimization mode, you need a program that violates the contract (e.g., <code>program.asm</code>), a configuration file that was used to detect the violation (e.g., <code>config.yaml</code>), a specification of the instruction set (e.g., <code>base.json</code>). The config file must set the input generation seed (<code>data_generator_seed</code>) to the value that matches the seed used in the <code>fuzz</code> mode to generate the violating inputs.</p> <p>The syntax of the command is as follows:</p> <pre><code>rvzr minimize -s &lt;spec_file&gt; -c &lt;config_file&gt; -t &lt;program_file&gt; -o &lt;output_file&gt; -i &lt;num_inputs&gt; --input-outdir &lt;input_outdir&gt; --num-attempts &lt;num_attempts&gt; &lt;pass_list&gt;\n</code></pre> <p>A typical example of the command is:</p> <pre><code>rvzr minimize -s base.json -c config.yaml -i 25 -t program.asm -o min.asm --input-outdir ./inputs --num-attempts 10 --enable-instruction-pass 1\n</code></pre> <p>This example command will take the program <code>program.asm</code>, generate an input sequence of length 25 based on the seed in <code>config.yaml</code>, and then apply a series of transformation passes (see the list of supported passes below) to simplify the program and the inputs. The passes will be applied 10 times. The resulting simplified program will be written to <code>min.asm</code>, and the simplified input sequence will be written to the directory <code>&lt;dir&gt;</code>.</p>"},{"location":"user/minimization/#supported-passes","title":"Supported Passes","text":"<p><code>minimize</code> mode supports three types of passes: program passes modify the program, input passes modify the input sequence, and analysis passes provide additional information about the violation, usually by adding comments to the program.</p>"},{"location":"user/minimization/#program-passes","title":"Program Passes","text":"<pre><code>--enable-instruction-pass\n</code></pre> <p>Enables the instruction minimization pass that iteratively removes instructions from the program while preserving the violation.</p> <pre><code>--enable-simplification-pass\n</code></pre> <p>Enables the instruction simplification pass that replaces complex instructions with simpler ones while preserving the violation.</p> <pre><code>--enable-nop-pass\n</code></pre> <p>Enables the NOP replacement pass that iteratively replaces instructions with NOPs of the same size while preserving the violation.</p> <pre><code>--enable-constant-pass\n</code></pre> <p>Enables the constant simplification pass that replaces immediate arguments of instructions with 0s while preserving the violation.</p> <pre><code>--enable-mask-pass\n</code></pre> <p>Enables the mask simplification pass that reduces the size of the instrumentation masks while preserving the violation.</p> <pre><code>--enable-label-pass\n</code></pre> <p>Enables the label removal pass that removes unused labels from the assembly file.</p> <pre><code>--enable-fence-pass\n</code></pre> <p>Enables the fence insertion pass that adds LFENCEs after instructions while preserving the violation.</p>"},{"location":"user/minimization/#input-passes","title":"Input Passes","text":"<pre><code>--enable-input-seq-pass\n</code></pre> <p>Enables the input sequence minimization pass that removes inputs from the original generated sequence while preserving the violation.</p> <pre><code>--enable-input-diff-pass\n</code></pre> <p>Enables the violating input difference minimization pass that operates on the pair of (contract-equivalent) inputs that triggered the violation and attempts to minimize the difference between the two inputs. It does so by iterating over all bytes in the inputs, and (1) attempting to replace each byte with zero, and if it fails, (2) copying the byte from the first input to the second input.</p>"},{"location":"user/minimization/#analysis-passes","title":"Analysis Passes","text":"<pre><code>--enable-source-analysis\n</code></pre> <p>Enables the speculation source identification pass that analyzes the program to identify suspected sources of speculation, and adds the corresponding comments to the assembly file. Note that the analysis is not guaranteed to be correct, and it may produce false results.</p> <pre><code>--enable-comment-pass\n</code></pre> <p>Enables the violation comment pass that adds comments to the assembly file with details about the violation. Namely, it adds comments to every memory access in the following format:</p> <p><code># mem access: [input1_id] [load_addr]-[store_addr] CL [cache_set_id]:[cache_line_offset] | [input2_id] [load_addr]-[store_addr] CL [cache_set_id]:[cache_line_offset]</code></p> <p>The comment indicates the addresses (<code>load_addr</code> and <code>store_addr</code>) of the given memory operation when executed with the two inputs that triggered the violation (<code>input1_id</code> and <code>input2_id</code>). For convenience, it also provides the L1D cache set ID and line offset that correspond to the addresses of the memory operation.</p> <p>For example, this comment</p> <p><code># mem access: [1] 0x800-0x800 CL 32:0 | [11] 0x710-0x710 CL 28:10</code></p> <p>indicates that the memory operation preceded by this comment was executed with two inputs, <code>1</code> and <code>11</code>, and the memory operation accessed the addresses <code>0x800</code> and <code>0x710</code> in the two inputs, respectively. The address <code>0x800</code> corresponded to cache set <code>32</code> and line offset <code>0</code>, while the address <code>0x710</code> corresponded to cache set <code>28</code> and line offset <code>10</code>.</p>"},{"location":"user/minimization/#interpreting-the-output","title":"Interpreting the Output","text":"<p>When a pass executes, it prints out the progress into the console.</p>"},{"location":"user/minimization/#output-of-program-passes","title":"Output of Program Passes","text":"<p>Most of the passes print out one character per instruction, with <code>.</code> indicating that the pass succeeded, and <code>-</code> indicating that the pass failed on the given instruction. For example, if <code>--enable-instruction-pass</code> is enabled, the output may look like this:</p> <p><pre><code>[Pass 2] Instruction Removal Pass\n\n.............-.....--.-------..----\n</code></pre> This means that the pass successfully removed the last 13 instructions, failed to remove the 14th instruction, succeeded on the 15th instruction, and so on. Note that the pass iterates from bottom to top, hence the output is printed in reverse order.</p>"},{"location":"user/minimization/#output-of-input-passes","title":"Output of Input Passes","text":"<p>The <code>input-diff</code> pass has a slightly different output format. It prints out a compact representation of the input difference, with each character representing a byte in the input sequence: * <code>.</code> indicates that zeroing the byte succeeded * <code>+</code> indicates that copying the byte succeeded * <code>=</code> indicates that the byte was already the same in both inputs * <code>^</code> indicates that the pass failed to minimize the byte, and it remained different in the two inputs</p> <p>For example, the output of the <code>input-diff</code> pass may look like this:</p> <pre><code>Address    +0x0     +0x40    +0x80    +0xc0    +0x100   +0x140   +0x180   +0x1c0\n0x00000000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00000e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001000 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001200 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001400 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001600 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001800 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001a00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001c00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00001e00 ........ ........ ........ ........ ........ ........ ........ ........\n0x00002000 ====^=..\n0x00002040 ........ ........ ........ ........\n  &gt; Result: Leaked 1 bytes\n  &gt; Addresses: ['0x2020']\n</code></pre> <p>This output indicates that the pass successfully minimized the input difference for all bytes except for the byte at address <code>0x2020</code>, which remained different in the two inputs, and the bytes at addresses <code>0x2000-0x2018</code> and <code>0x2028</code> were already the same in both inputs.</p>"},{"location":"user/minimization/#usage-example","title":"Usage Example","text":"<p>The following example demonstrates a typical workflow of using the <code>minimize</code> mode to simplify a violating program and its input sequence.</p> <p>Let's assume that a violation artifact was produces as a result of a fuzzing campaign like this:</p> <pre><code>rvzr fuzz -s base.json -c config.yaml -n 1000 -i 25 -w .\n</code></pre> <p>The first step is to minimize the violating program by enabling all program passes:</p> <pre><code>rvzr minimize -s base.json -c ./violation-000000-000000/minimize.yaml \\\n     -t ./violation/violation-000000-000000/program.asm \\\n     -o min.asm -i 25 --num-attempts 3 \\\n     --enable-instruction-pass 1 \\\n     --enable-simplification-pass 1 \\\n     --enable-nop-pass 1 \\\n     --enable-constant-pass 1 \\\n     --enable-mask-pass 1 \\\n     --enable-label-pass 1\n</code></pre> <p>Then verify the violation is preserved by reproducing it with the minimized program and the original input sequence:</p> <pre><code>rvzr fuzz -s base.json -c minimize.yaml -t min.asm -i 25\n</code></pre> <p>If the violation is detected, move to the next step. Otherwise, re-run the first command with a lower number of <code>--num-attempts</code> or try to disable some of the passes.</p> <p>The next step is to minimize the inputs by enabling all input passes, and to add analysis comments:</p> <pre><code>rvzr minimize -s base.json -c ./violation/violation-240712-132351/minimize.yaml \\\n    -t min.asm \\\n    -o commented.asm -i 25  \\\n    --input-outdir ./inputs \\\n    --enable-input-diff-pass 1 \\\n    --enable-input-seq-pass 1 \\\n    --enable-source-analysis 1 \\\n    --enable-comment-pass 1\n</code></pre> <p>The final step is to try to reproduce the violation with the minimized program and inputs to verify that the violation is preserved:</p> <pre><code>rvzr reproduce -s base.json -c ./violation/violation-240712-132351/reproduce.yaml \\\n    -t commented.asm -i ./inputs/min_input*.bin\n</code></pre> <p>If the violation is detected, the minimized program and inputs can be used for further analysis.</p>"},{"location":"user/modes/","title":"Modes of Operation","text":"<p>Revizor supports several modes of operation, each targeting a different use cases. The selection of the mode is described in the CLI documentation. Below is a brief description of each mode.</p> Mode CLI Key Use Case Description Fuzzing fuzz General Testing Test a CPU against a contract model. Test cases generated randomly Template Fuzzing tfuzz Targeted Testing Test a CPU against a contract model. Test cases generated based on a template Reproduce reproduce Reproducing a Violation Reproduce a violation found by fuzzing OR run a manually-written test case Minimization minimize Violation Simplification Simplify a test case by applying a series of simplification passes to the test case program and its inputs Trace Analysis analyse Stand-alone Analysis Analyze pre-recorded traces for violations Generation generate Stand-alone Generation Only generate test cases, without testing them ISA Spec Install download_spec Tool Installation Call a script that downloads the instruction set specification"},{"location":"user/modes/#fuzzing-and-template-fuzzing-modes","title":"Fuzzing and Template Fuzzing Modes","text":"<p>Two main modes of operation in revizor are fuzzing and template fuzzing. These modes are used to test a CPU against a contract model. In both modes, revizor generates test cases and executes them on the target CPU and the model, records the corresponding traces, and checks if the hardware traces contain the same (or less) information as the contract traces.</p> <p>In the fuzzing mode, test cases are generated randomly, with the instruction set and size of test cases defined by the config file. This mode is used for broad testing of the CPU.</p> <p>In the template fuzzing mode, test cases are generated based on a template: The generator takes an assembly template as an input, and produces a test case by expanding the <code>random_instructions</code> macro in the template. This mode is used to narrow down the fuzzing space and focus on specific scenarios, such as testing microarchitectural patches or certain interactions between actors.</p>"},{"location":"user/modes/#reproduce","title":"Reproduce","text":"<p>In this mode, Revizor loads a test case from a set of files and runs a single round of the fuzzer with this test case. The test case is usually a violation previously found in the (template) fuzzing mode, but it can also be written manually.</p> <p>There are three main use cases for this mode:</p> <ol> <li>Analysis of the violation: to understand the root cause of the violation, the user may manually modify the test case and re-run it in the reproduce mode to see if the violation is still present.</li> <li>Reproducibility check: to check if a violation is reproducible on different CPUs, or on different configurations of the same CPU (e.g., after a microcode patch has been applied).</li> <li>Manual testing: to test a manually-written test case.</li> </ol>"},{"location":"user/modes/#minimization","title":"Minimization","text":"<p>In this mode, Revizor takes a test case that causes a violation and applies a series of simplification passes to the test case program and its inputs. The goal is to reduce the test case to its minimal form to simplify the root cause analysis of the violation. Revizor supports an extensive list of passes, described in the minimization documentation.</p>"},{"location":"user/modes/#stand-alone-interfaces","title":"Stand-alone Interfaces","text":"<p>The <code>analyse</code> and <code>generate</code> modes are used to perform stand-alone access to modules of Revizor. In the <code>analyse</code> mode, the user can analyze pre-recorded traces for violations. In the <code>generate</code> mode, the user can generate test cases without testing them.</p>"},{"location":"user/modes/#isa-spec-install","title":"ISA Spec Install","text":"<p>The <code>download_spec</code> mode isn't used for testing, but rather for tool installation. It provides an interface to download, parse, and store the instruction specifications for the tested ISA in the JSON format.</p>"}]}